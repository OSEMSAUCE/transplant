
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model audit_log_entries
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type audit_log_entries = $Result.DefaultSelection<Prisma.$audit_log_entriesPayload>
/**
 * Model flow_state
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type flow_state = $Result.DefaultSelection<Prisma.$flow_statePayload>
/**
 * Model identities
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type identities = $Result.DefaultSelection<Prisma.$identitiesPayload>
/**
 * Model instances
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type instances = $Result.DefaultSelection<Prisma.$instancesPayload>
/**
 * Model mfa_amr_claims
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type mfa_amr_claims = $Result.DefaultSelection<Prisma.$mfa_amr_claimsPayload>
/**
 * Model mfa_challenges
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type mfa_challenges = $Result.DefaultSelection<Prisma.$mfa_challengesPayload>
/**
 * Model mfa_factors
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type mfa_factors = $Result.DefaultSelection<Prisma.$mfa_factorsPayload>
/**
 * Model one_time_tokens
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type one_time_tokens = $Result.DefaultSelection<Prisma.$one_time_tokensPayload>
/**
 * Model refresh_tokens
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type refresh_tokens = $Result.DefaultSelection<Prisma.$refresh_tokensPayload>
/**
 * Model saml_providers
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type saml_providers = $Result.DefaultSelection<Prisma.$saml_providersPayload>
/**
 * Model saml_relay_states
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type saml_relay_states = $Result.DefaultSelection<Prisma.$saml_relay_statesPayload>
/**
 * Model schema_migrations
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type schema_migrations = $Result.DefaultSelection<Prisma.$schema_migrationsPayload>
/**
 * Model sessions
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model sso_domains
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type sso_domains = $Result.DefaultSelection<Prisma.$sso_domainsPayload>
/**
 * Model sso_providers
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type sso_providers = $Result.DefaultSelection<Prisma.$sso_providersPayload>
/**
 * Model users
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model cropStakeholdersTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type cropStakeholdersTable = $Result.DefaultSelection<Prisma.$cropStakeholdersTablePayload>
/**
 * Model cropTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type cropTable = $Result.DefaultSelection<Prisma.$cropTablePayload>
/**
 * Model csvObjTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type csvObjTable = $Result.DefaultSelection<Prisma.$csvObjTablePayload>
/**
 * Model landStakeholdersTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type landStakeholdersTable = $Result.DefaultSelection<Prisma.$landStakeholdersTablePayload>
/**
 * Model landTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type landTable = $Result.DefaultSelection<Prisma.$landTablePayload>
/**
 * Model metadataTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type metadataTable = $Result.DefaultSelection<Prisma.$metadataTablePayload>
/**
 * Model nurseryTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type nurseryTable = $Result.DefaultSelection<Prisma.$nurseryTablePayload>
/**
 * Model organizationsTable
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type organizationsTable = $Result.DefaultSelection<Prisma.$organizationsTablePayload>
/**
 * Model plantingTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type plantingTable = $Result.DefaultSelection<Prisma.$plantingTablePayload>
/**
 * Model profilesTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type profilesTable = $Result.DefaultSelection<Prisma.$profilesTablePayload>
/**
 * Model projectStakeholdersTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type projectStakeholdersTable = $Result.DefaultSelection<Prisma.$projectStakeholdersTablePayload>
/**
 * Model projectsTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type projectsTable = $Result.DefaultSelection<Prisma.$projectsTablePayload>
/**
 * Model speciesTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type speciesTable = $Result.DefaultSelection<Prisma.$speciesTablePayload>
/**
 * Model stakeholderTypesTable
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type stakeholderTypesTable = $Result.DefaultSelection<Prisma.$stakeholderTypesTablePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Preparation: {
  raw: 'raw',
  mechanical: 'mechanical',
  chemical: 'chemical',
  burned: 'burned',
  grass_seed: 'grass_seed',
  landscaped: 'landscaped'
};

export type Preparation = (typeof Preparation)[keyof typeof Preparation]


export const aal_level: {
  aal1: 'aal1',
  aal2: 'aal2',
  aal3: 'aal3'
};

export type aal_level = (typeof aal_level)[keyof typeof aal_level]


export const code_challenge_method: {
  s256: 's256',
  plain: 'plain'
};

export type code_challenge_method = (typeof code_challenge_method)[keyof typeof code_challenge_method]


export const factor_status: {
  unverified: 'unverified',
  verified: 'verified'
};

export type factor_status = (typeof factor_status)[keyof typeof factor_status]


export const factor_type: {
  totp: 'totp',
  webauthn: 'webauthn',
  phone: 'phone'
};

export type factor_type = (typeof factor_type)[keyof typeof factor_type]


export const one_time_token_type: {
  confirmation_token: 'confirmation_token',
  reauthentication_token: 'reauthentication_token',
  recovery_token: 'recovery_token',
  email_change_token_new: 'email_change_token_new',
  email_change_token_current: 'email_change_token_current',
  phone_change_token: 'phone_change_token'
};

export type one_time_token_type = (typeof one_time_token_type)[keyof typeof one_time_token_type]


export const user_role: {
  user: 'user',
  manager: 'manager',
  admin: 'admin',
  superAdmin: 'superAdmin'
};

export type user_role = (typeof user_role)[keyof typeof user_role]

}

export type Preparation = $Enums.Preparation

export const Preparation: typeof $Enums.Preparation

export type aal_level = $Enums.aal_level

export const aal_level: typeof $Enums.aal_level

export type code_challenge_method = $Enums.code_challenge_method

export const code_challenge_method: typeof $Enums.code_challenge_method

export type factor_status = $Enums.factor_status

export const factor_status: typeof $Enums.factor_status

export type factor_type = $Enums.factor_type

export const factor_type: typeof $Enums.factor_type

export type one_time_token_type = $Enums.one_time_token_type

export const one_time_token_type: typeof $Enums.one_time_token_type

export type user_role = $Enums.user_role

export const user_role: typeof $Enums.user_role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Audit_log_entries
 * const audit_log_entries = await prisma.audit_log_entries.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Audit_log_entries
   * const audit_log_entries = await prisma.audit_log_entries.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.audit_log_entries`: Exposes CRUD operations for the **audit_log_entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_log_entries
    * const audit_log_entries = await prisma.audit_log_entries.findMany()
    * ```
    */
  get audit_log_entries(): Prisma.audit_log_entriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flow_state`: Exposes CRUD operations for the **flow_state** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flow_states
    * const flow_states = await prisma.flow_state.findMany()
    * ```
    */
  get flow_state(): Prisma.flow_stateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.identities`: Exposes CRUD operations for the **identities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Identities
    * const identities = await prisma.identities.findMany()
    * ```
    */
  get identities(): Prisma.identitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instances`: Exposes CRUD operations for the **instances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instances
    * const instances = await prisma.instances.findMany()
    * ```
    */
  get instances(): Prisma.instancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mfa_amr_claims`: Exposes CRUD operations for the **mfa_amr_claims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mfa_amr_claims
    * const mfa_amr_claims = await prisma.mfa_amr_claims.findMany()
    * ```
    */
  get mfa_amr_claims(): Prisma.mfa_amr_claimsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mfa_challenges`: Exposes CRUD operations for the **mfa_challenges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mfa_challenges
    * const mfa_challenges = await prisma.mfa_challenges.findMany()
    * ```
    */
  get mfa_challenges(): Prisma.mfa_challengesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mfa_factors`: Exposes CRUD operations for the **mfa_factors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mfa_factors
    * const mfa_factors = await prisma.mfa_factors.findMany()
    * ```
    */
  get mfa_factors(): Prisma.mfa_factorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.one_time_tokens`: Exposes CRUD operations for the **one_time_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more One_time_tokens
    * const one_time_tokens = await prisma.one_time_tokens.findMany()
    * ```
    */
  get one_time_tokens(): Prisma.one_time_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refresh_tokens`: Exposes CRUD operations for the **refresh_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refresh_tokens
    * const refresh_tokens = await prisma.refresh_tokens.findMany()
    * ```
    */
  get refresh_tokens(): Prisma.refresh_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saml_providers`: Exposes CRUD operations for the **saml_providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saml_providers
    * const saml_providers = await prisma.saml_providers.findMany()
    * ```
    */
  get saml_providers(): Prisma.saml_providersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saml_relay_states`: Exposes CRUD operations for the **saml_relay_states** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saml_relay_states
    * const saml_relay_states = await prisma.saml_relay_states.findMany()
    * ```
    */
  get saml_relay_states(): Prisma.saml_relay_statesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schema_migrations`: Exposes CRUD operations for the **schema_migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schema_migrations
    * const schema_migrations = await prisma.schema_migrations.findMany()
    * ```
    */
  get schema_migrations(): Prisma.schema_migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sso_domains`: Exposes CRUD operations for the **sso_domains** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sso_domains
    * const sso_domains = await prisma.sso_domains.findMany()
    * ```
    */
  get sso_domains(): Prisma.sso_domainsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sso_providers`: Exposes CRUD operations for the **sso_providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sso_providers
    * const sso_providers = await prisma.sso_providers.findMany()
    * ```
    */
  get sso_providers(): Prisma.sso_providersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cropStakeholdersTable`: Exposes CRUD operations for the **cropStakeholdersTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CropStakeholdersTables
    * const cropStakeholdersTables = await prisma.cropStakeholdersTable.findMany()
    * ```
    */
  get cropStakeholdersTable(): Prisma.cropStakeholdersTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cropTable`: Exposes CRUD operations for the **cropTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CropTables
    * const cropTables = await prisma.cropTable.findMany()
    * ```
    */
  get cropTable(): Prisma.cropTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.csvObjTable`: Exposes CRUD operations for the **csvObjTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CsvObjTables
    * const csvObjTables = await prisma.csvObjTable.findMany()
    * ```
    */
  get csvObjTable(): Prisma.csvObjTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landStakeholdersTable`: Exposes CRUD operations for the **landStakeholdersTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LandStakeholdersTables
    * const landStakeholdersTables = await prisma.landStakeholdersTable.findMany()
    * ```
    */
  get landStakeholdersTable(): Prisma.landStakeholdersTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landTable`: Exposes CRUD operations for the **landTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LandTables
    * const landTables = await prisma.landTable.findMany()
    * ```
    */
  get landTable(): Prisma.landTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metadataTable`: Exposes CRUD operations for the **metadataTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetadataTables
    * const metadataTables = await prisma.metadataTable.findMany()
    * ```
    */
  get metadataTable(): Prisma.metadataTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nurseryTable`: Exposes CRUD operations for the **nurseryTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NurseryTables
    * const nurseryTables = await prisma.nurseryTable.findMany()
    * ```
    */
  get nurseryTable(): Prisma.nurseryTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationsTable`: Exposes CRUD operations for the **organizationsTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationsTables
    * const organizationsTables = await prisma.organizationsTable.findMany()
    * ```
    */
  get organizationsTable(): Prisma.organizationsTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantingTable`: Exposes CRUD operations for the **plantingTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantingTables
    * const plantingTables = await prisma.plantingTable.findMany()
    * ```
    */
  get plantingTable(): Prisma.plantingTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profilesTable`: Exposes CRUD operations for the **profilesTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfilesTables
    * const profilesTables = await prisma.profilesTable.findMany()
    * ```
    */
  get profilesTable(): Prisma.profilesTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectStakeholdersTable`: Exposes CRUD operations for the **projectStakeholdersTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStakeholdersTables
    * const projectStakeholdersTables = await prisma.projectStakeholdersTable.findMany()
    * ```
    */
  get projectStakeholdersTable(): Prisma.projectStakeholdersTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectsTable`: Exposes CRUD operations for the **projectsTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectsTables
    * const projectsTables = await prisma.projectsTable.findMany()
    * ```
    */
  get projectsTable(): Prisma.projectsTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speciesTable`: Exposes CRUD operations for the **speciesTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeciesTables
    * const speciesTables = await prisma.speciesTable.findMany()
    * ```
    */
  get speciesTable(): Prisma.speciesTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stakeholderTypesTable`: Exposes CRUD operations for the **stakeholderTypesTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StakeholderTypesTables
    * const stakeholderTypesTables = await prisma.stakeholderTypesTable.findMany()
    * ```
    */
  get stakeholderTypesTable(): Prisma.stakeholderTypesTableDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    audit_log_entries: 'audit_log_entries',
    flow_state: 'flow_state',
    identities: 'identities',
    instances: 'instances',
    mfa_amr_claims: 'mfa_amr_claims',
    mfa_challenges: 'mfa_challenges',
    mfa_factors: 'mfa_factors',
    one_time_tokens: 'one_time_tokens',
    refresh_tokens: 'refresh_tokens',
    saml_providers: 'saml_providers',
    saml_relay_states: 'saml_relay_states',
    schema_migrations: 'schema_migrations',
    sessions: 'sessions',
    sso_domains: 'sso_domains',
    sso_providers: 'sso_providers',
    users: 'users',
    cropStakeholdersTable: 'cropStakeholdersTable',
    cropTable: 'cropTable',
    csvObjTable: 'csvObjTable',
    landStakeholdersTable: 'landStakeholdersTable',
    landTable: 'landTable',
    metadataTable: 'metadataTable',
    nurseryTable: 'nurseryTable',
    organizationsTable: 'organizationsTable',
    plantingTable: 'plantingTable',
    profilesTable: 'profilesTable',
    projectStakeholdersTable: 'projectStakeholdersTable',
    projectsTable: 'projectsTable',
    speciesTable: 'speciesTable',
    stakeholderTypesTable: 'stakeholderTypesTable'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "audit_log_entries" | "flow_state" | "identities" | "instances" | "mfa_amr_claims" | "mfa_challenges" | "mfa_factors" | "one_time_tokens" | "refresh_tokens" | "saml_providers" | "saml_relay_states" | "schema_migrations" | "sessions" | "sso_domains" | "sso_providers" | "users" | "cropStakeholdersTable" | "cropTable" | "csvObjTable" | "landStakeholdersTable" | "landTable" | "metadataTable" | "nurseryTable" | "organizationsTable" | "plantingTable" | "profilesTable" | "projectStakeholdersTable" | "projectsTable" | "speciesTable" | "stakeholderTypesTable"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      audit_log_entries: {
        payload: Prisma.$audit_log_entriesPayload<ExtArgs>
        fields: Prisma.audit_log_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_log_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_log_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>
          }
          findFirst: {
            args: Prisma.audit_log_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_log_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>
          }
          findMany: {
            args: Prisma.audit_log_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>[]
          }
          create: {
            args: Prisma.audit_log_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>
          }
          createMany: {
            args: Prisma.audit_log_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.audit_log_entriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>[]
          }
          delete: {
            args: Prisma.audit_log_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>
          }
          update: {
            args: Prisma.audit_log_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>
          }
          deleteMany: {
            args: Prisma.audit_log_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_log_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.audit_log_entriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>[]
          }
          upsert: {
            args: Prisma.audit_log_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_log_entriesPayload>
          }
          aggregate: {
            args: Prisma.Audit_log_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_log_entries>
          }
          groupBy: {
            args: Prisma.audit_log_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_log_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_log_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_log_entriesCountAggregateOutputType> | number
          }
        }
      }
      flow_state: {
        payload: Prisma.$flow_statePayload<ExtArgs>
        fields: Prisma.flow_stateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.flow_stateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.flow_stateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>
          }
          findFirst: {
            args: Prisma.flow_stateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.flow_stateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>
          }
          findMany: {
            args: Prisma.flow_stateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>[]
          }
          create: {
            args: Prisma.flow_stateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>
          }
          createMany: {
            args: Prisma.flow_stateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.flow_stateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>[]
          }
          delete: {
            args: Prisma.flow_stateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>
          }
          update: {
            args: Prisma.flow_stateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>
          }
          deleteMany: {
            args: Prisma.flow_stateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.flow_stateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.flow_stateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>[]
          }
          upsert: {
            args: Prisma.flow_stateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flow_statePayload>
          }
          aggregate: {
            args: Prisma.Flow_stateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlow_state>
          }
          groupBy: {
            args: Prisma.flow_stateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Flow_stateGroupByOutputType>[]
          }
          count: {
            args: Prisma.flow_stateCountArgs<ExtArgs>
            result: $Utils.Optional<Flow_stateCountAggregateOutputType> | number
          }
        }
      }
      identities: {
        payload: Prisma.$identitiesPayload<ExtArgs>
        fields: Prisma.identitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.identitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.identitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>
          }
          findFirst: {
            args: Prisma.identitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.identitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>
          }
          findMany: {
            args: Prisma.identitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>[]
          }
          create: {
            args: Prisma.identitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>
          }
          createMany: {
            args: Prisma.identitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.identitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>[]
          }
          delete: {
            args: Prisma.identitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>
          }
          update: {
            args: Prisma.identitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>
          }
          deleteMany: {
            args: Prisma.identitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.identitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.identitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>[]
          }
          upsert: {
            args: Prisma.identitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$identitiesPayload>
          }
          aggregate: {
            args: Prisma.IdentitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentities>
          }
          groupBy: {
            args: Prisma.identitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdentitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.identitiesCountArgs<ExtArgs>
            result: $Utils.Optional<IdentitiesCountAggregateOutputType> | number
          }
        }
      }
      instances: {
        payload: Prisma.$instancesPayload<ExtArgs>
        fields: Prisma.instancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.instancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.instancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>
          }
          findFirst: {
            args: Prisma.instancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.instancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>
          }
          findMany: {
            args: Prisma.instancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>[]
          }
          create: {
            args: Prisma.instancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>
          }
          createMany: {
            args: Prisma.instancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.instancesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>[]
          }
          delete: {
            args: Prisma.instancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>
          }
          update: {
            args: Prisma.instancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>
          }
          deleteMany: {
            args: Prisma.instancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.instancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.instancesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>[]
          }
          upsert: {
            args: Prisma.instancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$instancesPayload>
          }
          aggregate: {
            args: Prisma.InstancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstances>
          }
          groupBy: {
            args: Prisma.instancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.instancesCountArgs<ExtArgs>
            result: $Utils.Optional<InstancesCountAggregateOutputType> | number
          }
        }
      }
      mfa_amr_claims: {
        payload: Prisma.$mfa_amr_claimsPayload<ExtArgs>
        fields: Prisma.mfa_amr_claimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mfa_amr_claimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mfa_amr_claimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>
          }
          findFirst: {
            args: Prisma.mfa_amr_claimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mfa_amr_claimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>
          }
          findMany: {
            args: Prisma.mfa_amr_claimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>[]
          }
          create: {
            args: Prisma.mfa_amr_claimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>
          }
          createMany: {
            args: Prisma.mfa_amr_claimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mfa_amr_claimsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>[]
          }
          delete: {
            args: Prisma.mfa_amr_claimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>
          }
          update: {
            args: Prisma.mfa_amr_claimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>
          }
          deleteMany: {
            args: Prisma.mfa_amr_claimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mfa_amr_claimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mfa_amr_claimsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>[]
          }
          upsert: {
            args: Prisma.mfa_amr_claimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_amr_claimsPayload>
          }
          aggregate: {
            args: Prisma.Mfa_amr_claimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMfa_amr_claims>
          }
          groupBy: {
            args: Prisma.mfa_amr_claimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mfa_amr_claimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mfa_amr_claimsCountArgs<ExtArgs>
            result: $Utils.Optional<Mfa_amr_claimsCountAggregateOutputType> | number
          }
        }
      }
      mfa_challenges: {
        payload: Prisma.$mfa_challengesPayload<ExtArgs>
        fields: Prisma.mfa_challengesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mfa_challengesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mfa_challengesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>
          }
          findFirst: {
            args: Prisma.mfa_challengesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mfa_challengesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>
          }
          findMany: {
            args: Prisma.mfa_challengesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>[]
          }
          create: {
            args: Prisma.mfa_challengesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>
          }
          createMany: {
            args: Prisma.mfa_challengesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mfa_challengesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>[]
          }
          delete: {
            args: Prisma.mfa_challengesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>
          }
          update: {
            args: Prisma.mfa_challengesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>
          }
          deleteMany: {
            args: Prisma.mfa_challengesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mfa_challengesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mfa_challengesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>[]
          }
          upsert: {
            args: Prisma.mfa_challengesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_challengesPayload>
          }
          aggregate: {
            args: Prisma.Mfa_challengesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMfa_challenges>
          }
          groupBy: {
            args: Prisma.mfa_challengesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mfa_challengesGroupByOutputType>[]
          }
          count: {
            args: Prisma.mfa_challengesCountArgs<ExtArgs>
            result: $Utils.Optional<Mfa_challengesCountAggregateOutputType> | number
          }
        }
      }
      mfa_factors: {
        payload: Prisma.$mfa_factorsPayload<ExtArgs>
        fields: Prisma.mfa_factorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mfa_factorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mfa_factorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>
          }
          findFirst: {
            args: Prisma.mfa_factorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mfa_factorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>
          }
          findMany: {
            args: Prisma.mfa_factorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>[]
          }
          create: {
            args: Prisma.mfa_factorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>
          }
          createMany: {
            args: Prisma.mfa_factorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mfa_factorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>[]
          }
          delete: {
            args: Prisma.mfa_factorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>
          }
          update: {
            args: Prisma.mfa_factorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>
          }
          deleteMany: {
            args: Prisma.mfa_factorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mfa_factorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mfa_factorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>[]
          }
          upsert: {
            args: Prisma.mfa_factorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mfa_factorsPayload>
          }
          aggregate: {
            args: Prisma.Mfa_factorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMfa_factors>
          }
          groupBy: {
            args: Prisma.mfa_factorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mfa_factorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mfa_factorsCountArgs<ExtArgs>
            result: $Utils.Optional<Mfa_factorsCountAggregateOutputType> | number
          }
        }
      }
      one_time_tokens: {
        payload: Prisma.$one_time_tokensPayload<ExtArgs>
        fields: Prisma.one_time_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.one_time_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.one_time_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>
          }
          findFirst: {
            args: Prisma.one_time_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.one_time_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>
          }
          findMany: {
            args: Prisma.one_time_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>[]
          }
          create: {
            args: Prisma.one_time_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>
          }
          createMany: {
            args: Prisma.one_time_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.one_time_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>[]
          }
          delete: {
            args: Prisma.one_time_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>
          }
          update: {
            args: Prisma.one_time_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>
          }
          deleteMany: {
            args: Prisma.one_time_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.one_time_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.one_time_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>[]
          }
          upsert: {
            args: Prisma.one_time_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$one_time_tokensPayload>
          }
          aggregate: {
            args: Prisma.One_time_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOne_time_tokens>
          }
          groupBy: {
            args: Prisma.one_time_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<One_time_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.one_time_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<One_time_tokensCountAggregateOutputType> | number
          }
        }
      }
      refresh_tokens: {
        payload: Prisma.$refresh_tokensPayload<ExtArgs>
        fields: Prisma.refresh_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refresh_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refresh_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          findFirst: {
            args: Prisma.refresh_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refresh_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          findMany: {
            args: Prisma.refresh_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          create: {
            args: Prisma.refresh_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          createMany: {
            args: Prisma.refresh_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.refresh_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          delete: {
            args: Prisma.refresh_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          update: {
            args: Prisma.refresh_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          deleteMany: {
            args: Prisma.refresh_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refresh_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.refresh_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          upsert: {
            args: Prisma.refresh_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          aggregate: {
            args: Prisma.Refresh_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefresh_tokens>
          }
          groupBy: {
            args: Prisma.refresh_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.refresh_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokensCountAggregateOutputType> | number
          }
        }
      }
      saml_providers: {
        payload: Prisma.$saml_providersPayload<ExtArgs>
        fields: Prisma.saml_providersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saml_providersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saml_providersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>
          }
          findFirst: {
            args: Prisma.saml_providersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saml_providersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>
          }
          findMany: {
            args: Prisma.saml_providersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>[]
          }
          create: {
            args: Prisma.saml_providersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>
          }
          createMany: {
            args: Prisma.saml_providersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saml_providersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>[]
          }
          delete: {
            args: Prisma.saml_providersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>
          }
          update: {
            args: Prisma.saml_providersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>
          }
          deleteMany: {
            args: Prisma.saml_providersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saml_providersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saml_providersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>[]
          }
          upsert: {
            args: Prisma.saml_providersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_providersPayload>
          }
          aggregate: {
            args: Prisma.Saml_providersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaml_providers>
          }
          groupBy: {
            args: Prisma.saml_providersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Saml_providersGroupByOutputType>[]
          }
          count: {
            args: Prisma.saml_providersCountArgs<ExtArgs>
            result: $Utils.Optional<Saml_providersCountAggregateOutputType> | number
          }
        }
      }
      saml_relay_states: {
        payload: Prisma.$saml_relay_statesPayload<ExtArgs>
        fields: Prisma.saml_relay_statesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saml_relay_statesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saml_relay_statesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>
          }
          findFirst: {
            args: Prisma.saml_relay_statesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saml_relay_statesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>
          }
          findMany: {
            args: Prisma.saml_relay_statesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>[]
          }
          create: {
            args: Prisma.saml_relay_statesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>
          }
          createMany: {
            args: Prisma.saml_relay_statesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saml_relay_statesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>[]
          }
          delete: {
            args: Prisma.saml_relay_statesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>
          }
          update: {
            args: Prisma.saml_relay_statesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>
          }
          deleteMany: {
            args: Prisma.saml_relay_statesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saml_relay_statesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saml_relay_statesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>[]
          }
          upsert: {
            args: Prisma.saml_relay_statesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saml_relay_statesPayload>
          }
          aggregate: {
            args: Prisma.Saml_relay_statesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaml_relay_states>
          }
          groupBy: {
            args: Prisma.saml_relay_statesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Saml_relay_statesGroupByOutputType>[]
          }
          count: {
            args: Prisma.saml_relay_statesCountArgs<ExtArgs>
            result: $Utils.Optional<Saml_relay_statesCountAggregateOutputType> | number
          }
        }
      }
      schema_migrations: {
        payload: Prisma.$schema_migrationsPayload<ExtArgs>
        fields: Prisma.schema_migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.schema_migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.schema_migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          findFirst: {
            args: Prisma.schema_migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.schema_migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          findMany: {
            args: Prisma.schema_migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          create: {
            args: Prisma.schema_migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          createMany: {
            args: Prisma.schema_migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.schema_migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          delete: {
            args: Prisma.schema_migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          update: {
            args: Prisma.schema_migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          deleteMany: {
            args: Prisma.schema_migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.schema_migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.schema_migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          upsert: {
            args: Prisma.schema_migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          aggregate: {
            args: Prisma.Schema_migrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchema_migrations>
          }
          groupBy: {
            args: Prisma.schema_migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Schema_migrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.schema_migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<Schema_migrationsCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      sso_domains: {
        payload: Prisma.$sso_domainsPayload<ExtArgs>
        fields: Prisma.sso_domainsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sso_domainsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sso_domainsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>
          }
          findFirst: {
            args: Prisma.sso_domainsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sso_domainsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>
          }
          findMany: {
            args: Prisma.sso_domainsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>[]
          }
          create: {
            args: Prisma.sso_domainsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>
          }
          createMany: {
            args: Prisma.sso_domainsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sso_domainsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>[]
          }
          delete: {
            args: Prisma.sso_domainsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>
          }
          update: {
            args: Prisma.sso_domainsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>
          }
          deleteMany: {
            args: Prisma.sso_domainsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sso_domainsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sso_domainsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>[]
          }
          upsert: {
            args: Prisma.sso_domainsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_domainsPayload>
          }
          aggregate: {
            args: Prisma.Sso_domainsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSso_domains>
          }
          groupBy: {
            args: Prisma.sso_domainsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sso_domainsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sso_domainsCountArgs<ExtArgs>
            result: $Utils.Optional<Sso_domainsCountAggregateOutputType> | number
          }
        }
      }
      sso_providers: {
        payload: Prisma.$sso_providersPayload<ExtArgs>
        fields: Prisma.sso_providersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sso_providersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sso_providersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>
          }
          findFirst: {
            args: Prisma.sso_providersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sso_providersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>
          }
          findMany: {
            args: Prisma.sso_providersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>[]
          }
          create: {
            args: Prisma.sso_providersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>
          }
          createMany: {
            args: Prisma.sso_providersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sso_providersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>[]
          }
          delete: {
            args: Prisma.sso_providersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>
          }
          update: {
            args: Prisma.sso_providersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>
          }
          deleteMany: {
            args: Prisma.sso_providersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sso_providersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sso_providersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>[]
          }
          upsert: {
            args: Prisma.sso_providersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sso_providersPayload>
          }
          aggregate: {
            args: Prisma.Sso_providersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSso_providers>
          }
          groupBy: {
            args: Prisma.sso_providersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sso_providersGroupByOutputType>[]
          }
          count: {
            args: Prisma.sso_providersCountArgs<ExtArgs>
            result: $Utils.Optional<Sso_providersCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      cropStakeholdersTable: {
        payload: Prisma.$cropStakeholdersTablePayload<ExtArgs>
        fields: Prisma.cropStakeholdersTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cropStakeholdersTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cropStakeholdersTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>
          }
          findFirst: {
            args: Prisma.cropStakeholdersTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cropStakeholdersTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>
          }
          findMany: {
            args: Prisma.cropStakeholdersTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>[]
          }
          create: {
            args: Prisma.cropStakeholdersTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>
          }
          createMany: {
            args: Prisma.cropStakeholdersTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cropStakeholdersTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>[]
          }
          delete: {
            args: Prisma.cropStakeholdersTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>
          }
          update: {
            args: Prisma.cropStakeholdersTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>
          }
          deleteMany: {
            args: Prisma.cropStakeholdersTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cropStakeholdersTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cropStakeholdersTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>[]
          }
          upsert: {
            args: Prisma.cropStakeholdersTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropStakeholdersTablePayload>
          }
          aggregate: {
            args: Prisma.CropStakeholdersTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCropStakeholdersTable>
          }
          groupBy: {
            args: Prisma.cropStakeholdersTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropStakeholdersTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.cropStakeholdersTableCountArgs<ExtArgs>
            result: $Utils.Optional<CropStakeholdersTableCountAggregateOutputType> | number
          }
        }
      }
      cropTable: {
        payload: Prisma.$cropTablePayload<ExtArgs>
        fields: Prisma.cropTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cropTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cropTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>
          }
          findFirst: {
            args: Prisma.cropTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cropTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>
          }
          findMany: {
            args: Prisma.cropTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>[]
          }
          create: {
            args: Prisma.cropTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>
          }
          createMany: {
            args: Prisma.cropTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cropTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>[]
          }
          delete: {
            args: Prisma.cropTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>
          }
          update: {
            args: Prisma.cropTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>
          }
          deleteMany: {
            args: Prisma.cropTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cropTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cropTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>[]
          }
          upsert: {
            args: Prisma.cropTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cropTablePayload>
          }
          aggregate: {
            args: Prisma.CropTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCropTable>
          }
          groupBy: {
            args: Prisma.cropTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.cropTableCountArgs<ExtArgs>
            result: $Utils.Optional<CropTableCountAggregateOutputType> | number
          }
        }
      }
      csvObjTable: {
        payload: Prisma.$csvObjTablePayload<ExtArgs>
        fields: Prisma.csvObjTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.csvObjTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.csvObjTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>
          }
          findFirst: {
            args: Prisma.csvObjTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.csvObjTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>
          }
          findMany: {
            args: Prisma.csvObjTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>[]
          }
          create: {
            args: Prisma.csvObjTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>
          }
          createMany: {
            args: Prisma.csvObjTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.csvObjTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>[]
          }
          delete: {
            args: Prisma.csvObjTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>
          }
          update: {
            args: Prisma.csvObjTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>
          }
          deleteMany: {
            args: Prisma.csvObjTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.csvObjTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.csvObjTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>[]
          }
          upsert: {
            args: Prisma.csvObjTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$csvObjTablePayload>
          }
          aggregate: {
            args: Prisma.CsvObjTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCsvObjTable>
          }
          groupBy: {
            args: Prisma.csvObjTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CsvObjTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.csvObjTableCountArgs<ExtArgs>
            result: $Utils.Optional<CsvObjTableCountAggregateOutputType> | number
          }
        }
      }
      landStakeholdersTable: {
        payload: Prisma.$landStakeholdersTablePayload<ExtArgs>
        fields: Prisma.landStakeholdersTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.landStakeholdersTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.landStakeholdersTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>
          }
          findFirst: {
            args: Prisma.landStakeholdersTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.landStakeholdersTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>
          }
          findMany: {
            args: Prisma.landStakeholdersTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>[]
          }
          create: {
            args: Prisma.landStakeholdersTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>
          }
          createMany: {
            args: Prisma.landStakeholdersTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.landStakeholdersTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>[]
          }
          delete: {
            args: Prisma.landStakeholdersTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>
          }
          update: {
            args: Prisma.landStakeholdersTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>
          }
          deleteMany: {
            args: Prisma.landStakeholdersTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.landStakeholdersTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.landStakeholdersTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>[]
          }
          upsert: {
            args: Prisma.landStakeholdersTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landStakeholdersTablePayload>
          }
          aggregate: {
            args: Prisma.LandStakeholdersTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandStakeholdersTable>
          }
          groupBy: {
            args: Prisma.landStakeholdersTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandStakeholdersTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.landStakeholdersTableCountArgs<ExtArgs>
            result: $Utils.Optional<LandStakeholdersTableCountAggregateOutputType> | number
          }
        }
      }
      landTable: {
        payload: Prisma.$landTablePayload<ExtArgs>
        fields: Prisma.landTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.landTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.landTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>
          }
          findFirst: {
            args: Prisma.landTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.landTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>
          }
          findMany: {
            args: Prisma.landTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>[]
          }
          create: {
            args: Prisma.landTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>
          }
          createMany: {
            args: Prisma.landTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.landTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>[]
          }
          delete: {
            args: Prisma.landTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>
          }
          update: {
            args: Prisma.landTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>
          }
          deleteMany: {
            args: Prisma.landTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.landTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.landTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>[]
          }
          upsert: {
            args: Prisma.landTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landTablePayload>
          }
          aggregate: {
            args: Prisma.LandTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandTable>
          }
          groupBy: {
            args: Prisma.landTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.landTableCountArgs<ExtArgs>
            result: $Utils.Optional<LandTableCountAggregateOutputType> | number
          }
        }
      }
      metadataTable: {
        payload: Prisma.$metadataTablePayload<ExtArgs>
        fields: Prisma.metadataTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.metadataTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.metadataTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>
          }
          findFirst: {
            args: Prisma.metadataTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.metadataTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>
          }
          findMany: {
            args: Prisma.metadataTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>[]
          }
          create: {
            args: Prisma.metadataTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>
          }
          createMany: {
            args: Prisma.metadataTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.metadataTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>[]
          }
          delete: {
            args: Prisma.metadataTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>
          }
          update: {
            args: Prisma.metadataTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>
          }
          deleteMany: {
            args: Prisma.metadataTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.metadataTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.metadataTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>[]
          }
          upsert: {
            args: Prisma.metadataTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metadataTablePayload>
          }
          aggregate: {
            args: Prisma.MetadataTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetadataTable>
          }
          groupBy: {
            args: Prisma.metadataTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetadataTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.metadataTableCountArgs<ExtArgs>
            result: $Utils.Optional<MetadataTableCountAggregateOutputType> | number
          }
        }
      }
      nurseryTable: {
        payload: Prisma.$nurseryTablePayload<ExtArgs>
        fields: Prisma.nurseryTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.nurseryTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.nurseryTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>
          }
          findFirst: {
            args: Prisma.nurseryTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.nurseryTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>
          }
          findMany: {
            args: Prisma.nurseryTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>[]
          }
          create: {
            args: Prisma.nurseryTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>
          }
          createMany: {
            args: Prisma.nurseryTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.nurseryTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>[]
          }
          delete: {
            args: Prisma.nurseryTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>
          }
          update: {
            args: Prisma.nurseryTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>
          }
          deleteMany: {
            args: Prisma.nurseryTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.nurseryTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.nurseryTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>[]
          }
          upsert: {
            args: Prisma.nurseryTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nurseryTablePayload>
          }
          aggregate: {
            args: Prisma.NurseryTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNurseryTable>
          }
          groupBy: {
            args: Prisma.nurseryTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<NurseryTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.nurseryTableCountArgs<ExtArgs>
            result: $Utils.Optional<NurseryTableCountAggregateOutputType> | number
          }
        }
      }
      organizationsTable: {
        payload: Prisma.$organizationsTablePayload<ExtArgs>
        fields: Prisma.organizationsTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organizationsTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organizationsTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>
          }
          findFirst: {
            args: Prisma.organizationsTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organizationsTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>
          }
          findMany: {
            args: Prisma.organizationsTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>[]
          }
          create: {
            args: Prisma.organizationsTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>
          }
          createMany: {
            args: Prisma.organizationsTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.organizationsTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>[]
          }
          delete: {
            args: Prisma.organizationsTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>
          }
          update: {
            args: Prisma.organizationsTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>
          }
          deleteMany: {
            args: Prisma.organizationsTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.organizationsTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.organizationsTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>[]
          }
          upsert: {
            args: Prisma.organizationsTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsTablePayload>
          }
          aggregate: {
            args: Prisma.OrganizationsTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationsTable>
          }
          groupBy: {
            args: Prisma.organizationsTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationsTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.organizationsTableCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationsTableCountAggregateOutputType> | number
          }
        }
      }
      plantingTable: {
        payload: Prisma.$plantingTablePayload<ExtArgs>
        fields: Prisma.plantingTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plantingTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plantingTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>
          }
          findFirst: {
            args: Prisma.plantingTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plantingTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>
          }
          findMany: {
            args: Prisma.plantingTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>[]
          }
          create: {
            args: Prisma.plantingTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>
          }
          createMany: {
            args: Prisma.plantingTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.plantingTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>[]
          }
          delete: {
            args: Prisma.plantingTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>
          }
          update: {
            args: Prisma.plantingTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>
          }
          deleteMany: {
            args: Prisma.plantingTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plantingTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.plantingTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>[]
          }
          upsert: {
            args: Prisma.plantingTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantingTablePayload>
          }
          aggregate: {
            args: Prisma.PlantingTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantingTable>
          }
          groupBy: {
            args: Prisma.plantingTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantingTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.plantingTableCountArgs<ExtArgs>
            result: $Utils.Optional<PlantingTableCountAggregateOutputType> | number
          }
        }
      }
      profilesTable: {
        payload: Prisma.$profilesTablePayload<ExtArgs>
        fields: Prisma.profilesTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profilesTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profilesTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>
          }
          findFirst: {
            args: Prisma.profilesTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profilesTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>
          }
          findMany: {
            args: Prisma.profilesTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>[]
          }
          create: {
            args: Prisma.profilesTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>
          }
          createMany: {
            args: Prisma.profilesTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.profilesTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>[]
          }
          delete: {
            args: Prisma.profilesTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>
          }
          update: {
            args: Prisma.profilesTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>
          }
          deleteMany: {
            args: Prisma.profilesTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profilesTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.profilesTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>[]
          }
          upsert: {
            args: Prisma.profilesTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesTablePayload>
          }
          aggregate: {
            args: Prisma.ProfilesTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfilesTable>
          }
          groupBy: {
            args: Prisma.profilesTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfilesTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.profilesTableCountArgs<ExtArgs>
            result: $Utils.Optional<ProfilesTableCountAggregateOutputType> | number
          }
        }
      }
      projectStakeholdersTable: {
        payload: Prisma.$projectStakeholdersTablePayload<ExtArgs>
        fields: Prisma.projectStakeholdersTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectStakeholdersTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectStakeholdersTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>
          }
          findFirst: {
            args: Prisma.projectStakeholdersTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectStakeholdersTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>
          }
          findMany: {
            args: Prisma.projectStakeholdersTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>[]
          }
          create: {
            args: Prisma.projectStakeholdersTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>
          }
          createMany: {
            args: Prisma.projectStakeholdersTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectStakeholdersTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>[]
          }
          delete: {
            args: Prisma.projectStakeholdersTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>
          }
          update: {
            args: Prisma.projectStakeholdersTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>
          }
          deleteMany: {
            args: Prisma.projectStakeholdersTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectStakeholdersTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projectStakeholdersTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>[]
          }
          upsert: {
            args: Prisma.projectStakeholdersTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectStakeholdersTablePayload>
          }
          aggregate: {
            args: Prisma.ProjectStakeholdersTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectStakeholdersTable>
          }
          groupBy: {
            args: Prisma.projectStakeholdersTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectStakeholdersTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectStakeholdersTableCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectStakeholdersTableCountAggregateOutputType> | number
          }
        }
      }
      projectsTable: {
        payload: Prisma.$projectsTablePayload<ExtArgs>
        fields: Prisma.projectsTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectsTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectsTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>
          }
          findFirst: {
            args: Prisma.projectsTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectsTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>
          }
          findMany: {
            args: Prisma.projectsTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>[]
          }
          create: {
            args: Prisma.projectsTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>
          }
          createMany: {
            args: Prisma.projectsTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectsTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>[]
          }
          delete: {
            args: Prisma.projectsTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>
          }
          update: {
            args: Prisma.projectsTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>
          }
          deleteMany: {
            args: Prisma.projectsTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectsTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projectsTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>[]
          }
          upsert: {
            args: Prisma.projectsTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsTablePayload>
          }
          aggregate: {
            args: Prisma.ProjectsTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectsTable>
          }
          groupBy: {
            args: Prisma.projectsTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectsTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectsTableCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectsTableCountAggregateOutputType> | number
          }
        }
      }
      speciesTable: {
        payload: Prisma.$speciesTablePayload<ExtArgs>
        fields: Prisma.speciesTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.speciesTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.speciesTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>
          }
          findFirst: {
            args: Prisma.speciesTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.speciesTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>
          }
          findMany: {
            args: Prisma.speciesTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>[]
          }
          create: {
            args: Prisma.speciesTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>
          }
          createMany: {
            args: Prisma.speciesTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.speciesTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>[]
          }
          delete: {
            args: Prisma.speciesTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>
          }
          update: {
            args: Prisma.speciesTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>
          }
          deleteMany: {
            args: Prisma.speciesTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.speciesTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.speciesTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>[]
          }
          upsert: {
            args: Prisma.speciesTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speciesTablePayload>
          }
          aggregate: {
            args: Prisma.SpeciesTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeciesTable>
          }
          groupBy: {
            args: Prisma.speciesTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeciesTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.speciesTableCountArgs<ExtArgs>
            result: $Utils.Optional<SpeciesTableCountAggregateOutputType> | number
          }
        }
      }
      stakeholderTypesTable: {
        payload: Prisma.$stakeholderTypesTablePayload<ExtArgs>
        fields: Prisma.stakeholderTypesTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stakeholderTypesTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stakeholderTypesTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>
          }
          findFirst: {
            args: Prisma.stakeholderTypesTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stakeholderTypesTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>
          }
          findMany: {
            args: Prisma.stakeholderTypesTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>[]
          }
          create: {
            args: Prisma.stakeholderTypesTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>
          }
          createMany: {
            args: Prisma.stakeholderTypesTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.stakeholderTypesTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>[]
          }
          delete: {
            args: Prisma.stakeholderTypesTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>
          }
          update: {
            args: Prisma.stakeholderTypesTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>
          }
          deleteMany: {
            args: Prisma.stakeholderTypesTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stakeholderTypesTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.stakeholderTypesTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>[]
          }
          upsert: {
            args: Prisma.stakeholderTypesTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stakeholderTypesTablePayload>
          }
          aggregate: {
            args: Prisma.StakeholderTypesTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStakeholderTypesTable>
          }
          groupBy: {
            args: Prisma.stakeholderTypesTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<StakeholderTypesTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.stakeholderTypesTableCountArgs<ExtArgs>
            result: $Utils.Optional<StakeholderTypesTableCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    audit_log_entries?: audit_log_entriesOmit
    flow_state?: flow_stateOmit
    identities?: identitiesOmit
    instances?: instancesOmit
    mfa_amr_claims?: mfa_amr_claimsOmit
    mfa_challenges?: mfa_challengesOmit
    mfa_factors?: mfa_factorsOmit
    one_time_tokens?: one_time_tokensOmit
    refresh_tokens?: refresh_tokensOmit
    saml_providers?: saml_providersOmit
    saml_relay_states?: saml_relay_statesOmit
    schema_migrations?: schema_migrationsOmit
    sessions?: sessionsOmit
    sso_domains?: sso_domainsOmit
    sso_providers?: sso_providersOmit
    users?: usersOmit
    cropStakeholdersTable?: cropStakeholdersTableOmit
    cropTable?: cropTableOmit
    csvObjTable?: csvObjTableOmit
    landStakeholdersTable?: landStakeholdersTableOmit
    landTable?: landTableOmit
    metadataTable?: metadataTableOmit
    nurseryTable?: nurseryTableOmit
    organizationsTable?: organizationsTableOmit
    plantingTable?: plantingTableOmit
    profilesTable?: profilesTableOmit
    projectStakeholdersTable?: projectStakeholdersTableOmit
    projectsTable?: projectsTableOmit
    speciesTable?: speciesTableOmit
    stakeholderTypesTable?: stakeholderTypesTableOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Flow_stateCountOutputType
   */

  export type Flow_stateCountOutputType = {
    saml_relay_states: number
  }

  export type Flow_stateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saml_relay_states?: boolean | Flow_stateCountOutputTypeCountSaml_relay_statesArgs
  }

  // Custom InputTypes
  /**
   * Flow_stateCountOutputType without action
   */
  export type Flow_stateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flow_stateCountOutputType
     */
    select?: Flow_stateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Flow_stateCountOutputType without action
   */
  export type Flow_stateCountOutputTypeCountSaml_relay_statesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saml_relay_statesWhereInput
  }


  /**
   * Count Type Mfa_factorsCountOutputType
   */

  export type Mfa_factorsCountOutputType = {
    mfa_challenges: number
  }

  export type Mfa_factorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa_challenges?: boolean | Mfa_factorsCountOutputTypeCountMfa_challengesArgs
  }

  // Custom InputTypes
  /**
   * Mfa_factorsCountOutputType without action
   */
  export type Mfa_factorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mfa_factorsCountOutputType
     */
    select?: Mfa_factorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Mfa_factorsCountOutputType without action
   */
  export type Mfa_factorsCountOutputTypeCountMfa_challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mfa_challengesWhereInput
  }


  /**
   * Count Type SessionsCountOutputType
   */

  export type SessionsCountOutputType = {
    mfa_amr_claims: number
    refresh_tokens: number
  }

  export type SessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa_amr_claims?: boolean | SessionsCountOutputTypeCountMfa_amr_claimsArgs
    refresh_tokens?: boolean | SessionsCountOutputTypeCountRefresh_tokensArgs
  }

  // Custom InputTypes
  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionsCountOutputType
     */
    select?: SessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountMfa_amr_claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mfa_amr_claimsWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountRefresh_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refresh_tokensWhereInput
  }


  /**
   * Count Type Sso_providersCountOutputType
   */

  export type Sso_providersCountOutputType = {
    saml_providers: number
    saml_relay_states: number
    sso_domains: number
  }

  export type Sso_providersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saml_providers?: boolean | Sso_providersCountOutputTypeCountSaml_providersArgs
    saml_relay_states?: boolean | Sso_providersCountOutputTypeCountSaml_relay_statesArgs
    sso_domains?: boolean | Sso_providersCountOutputTypeCountSso_domainsArgs
  }

  // Custom InputTypes
  /**
   * Sso_providersCountOutputType without action
   */
  export type Sso_providersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sso_providersCountOutputType
     */
    select?: Sso_providersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sso_providersCountOutputType without action
   */
  export type Sso_providersCountOutputTypeCountSaml_providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saml_providersWhereInput
  }

  /**
   * Sso_providersCountOutputType without action
   */
  export type Sso_providersCountOutputTypeCountSaml_relay_statesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saml_relay_statesWhereInput
  }

  /**
   * Sso_providersCountOutputType without action
   */
  export type Sso_providersCountOutputTypeCountSso_domainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sso_domainsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    identities: number
    mfa_factors: number
    one_time_tokens: number
    sessions: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identities?: boolean | UsersCountOutputTypeCountIdentitiesArgs
    mfa_factors?: boolean | UsersCountOutputTypeCountMfa_factorsArgs
    one_time_tokens?: boolean | UsersCountOutputTypeCountOne_time_tokensArgs
    sessions?: boolean | UsersCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountIdentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: identitiesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMfa_factorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mfa_factorsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOne_time_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: one_time_tokensWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }


  /**
   * Count Type CropTableCountOutputType
   */

  export type CropTableCountOutputType = {
    cropStakeholdersTable: number
    plantingTable: number
  }

  export type CropTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropStakeholdersTable?: boolean | CropTableCountOutputTypeCountCropStakeholdersTableArgs
    plantingTable?: boolean | CropTableCountOutputTypeCountPlantingTableArgs
  }

  // Custom InputTypes
  /**
   * CropTableCountOutputType without action
   */
  export type CropTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropTableCountOutputType
     */
    select?: CropTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CropTableCountOutputType without action
   */
  export type CropTableCountOutputTypeCountCropStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropStakeholdersTableWhereInput
  }

  /**
   * CropTableCountOutputType without action
   */
  export type CropTableCountOutputTypeCountPlantingTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plantingTableWhereInput
  }


  /**
   * Count Type CsvObjTableCountOutputType
   */

  export type CsvObjTableCountOutputType = {
    cropTable: number
    landTable: number
    metadataTable: number
    projectsTable: number
  }

  export type CsvObjTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | CsvObjTableCountOutputTypeCountCropTableArgs
    landTable?: boolean | CsvObjTableCountOutputTypeCountLandTableArgs
    metadataTable?: boolean | CsvObjTableCountOutputTypeCountMetadataTableArgs
    projectsTable?: boolean | CsvObjTableCountOutputTypeCountProjectsTableArgs
  }

  // Custom InputTypes
  /**
   * CsvObjTableCountOutputType without action
   */
  export type CsvObjTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CsvObjTableCountOutputType
     */
    select?: CsvObjTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CsvObjTableCountOutputType without action
   */
  export type CsvObjTableCountOutputTypeCountCropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropTableWhereInput
  }

  /**
   * CsvObjTableCountOutputType without action
   */
  export type CsvObjTableCountOutputTypeCountLandTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landTableWhereInput
  }

  /**
   * CsvObjTableCountOutputType without action
   */
  export type CsvObjTableCountOutputTypeCountMetadataTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metadataTableWhereInput
  }

  /**
   * CsvObjTableCountOutputType without action
   */
  export type CsvObjTableCountOutputTypeCountProjectsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectsTableWhereInput
  }


  /**
   * Count Type LandTableCountOutputType
   */

  export type LandTableCountOutputType = {
    landStakeholdersTable: number
    plantingTable: number
  }

  export type LandTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landStakeholdersTable?: boolean | LandTableCountOutputTypeCountLandStakeholdersTableArgs
    plantingTable?: boolean | LandTableCountOutputTypeCountPlantingTableArgs
  }

  // Custom InputTypes
  /**
   * LandTableCountOutputType without action
   */
  export type LandTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandTableCountOutputType
     */
    select?: LandTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LandTableCountOutputType without action
   */
  export type LandTableCountOutputTypeCountLandStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landStakeholdersTableWhereInput
  }

  /**
   * LandTableCountOutputType without action
   */
  export type LandTableCountOutputTypeCountPlantingTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plantingTableWhereInput
  }


  /**
   * Count Type OrganizationsTableCountOutputType
   */

  export type OrganizationsTableCountOutputType = {
    cropStakeholdersTable: number
    cropTable: number
    landStakeholdersTable: number
    profilesTable: number
    projectStakeholdersTable: number
  }

  export type OrganizationsTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropStakeholdersTable?: boolean | OrganizationsTableCountOutputTypeCountCropStakeholdersTableArgs
    cropTable?: boolean | OrganizationsTableCountOutputTypeCountCropTableArgs
    landStakeholdersTable?: boolean | OrganizationsTableCountOutputTypeCountLandStakeholdersTableArgs
    profilesTable?: boolean | OrganizationsTableCountOutputTypeCountProfilesTableArgs
    projectStakeholdersTable?: boolean | OrganizationsTableCountOutputTypeCountProjectStakeholdersTableArgs
  }

  // Custom InputTypes
  /**
   * OrganizationsTableCountOutputType without action
   */
  export type OrganizationsTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationsTableCountOutputType
     */
    select?: OrganizationsTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationsTableCountOutputType without action
   */
  export type OrganizationsTableCountOutputTypeCountCropStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropStakeholdersTableWhereInput
  }

  /**
   * OrganizationsTableCountOutputType without action
   */
  export type OrganizationsTableCountOutputTypeCountCropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropTableWhereInput
  }

  /**
   * OrganizationsTableCountOutputType without action
   */
  export type OrganizationsTableCountOutputTypeCountLandStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landStakeholdersTableWhereInput
  }

  /**
   * OrganizationsTableCountOutputType without action
   */
  export type OrganizationsTableCountOutputTypeCountProfilesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profilesTableWhereInput
  }

  /**
   * OrganizationsTableCountOutputType without action
   */
  export type OrganizationsTableCountOutputTypeCountProjectStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectStakeholdersTableWhereInput
  }


  /**
   * Count Type ProjectsTableCountOutputType
   */

  export type ProjectsTableCountOutputType = {
    cropTable: number
    landTable: number
    projectStakeholdersTable: number
  }

  export type ProjectsTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | ProjectsTableCountOutputTypeCountCropTableArgs
    landTable?: boolean | ProjectsTableCountOutputTypeCountLandTableArgs
    projectStakeholdersTable?: boolean | ProjectsTableCountOutputTypeCountProjectStakeholdersTableArgs
  }

  // Custom InputTypes
  /**
   * ProjectsTableCountOutputType without action
   */
  export type ProjectsTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectsTableCountOutputType
     */
    select?: ProjectsTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectsTableCountOutputType without action
   */
  export type ProjectsTableCountOutputTypeCountCropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropTableWhereInput
  }

  /**
   * ProjectsTableCountOutputType without action
   */
  export type ProjectsTableCountOutputTypeCountLandTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landTableWhereInput
  }

  /**
   * ProjectsTableCountOutputType without action
   */
  export type ProjectsTableCountOutputTypeCountProjectStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectStakeholdersTableWhereInput
  }


  /**
   * Count Type SpeciesTableCountOutputType
   */

  export type SpeciesTableCountOutputType = {
    cropTable: number
  }

  export type SpeciesTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | SpeciesTableCountOutputTypeCountCropTableArgs
  }

  // Custom InputTypes
  /**
   * SpeciesTableCountOutputType without action
   */
  export type SpeciesTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesTableCountOutputType
     */
    select?: SpeciesTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpeciesTableCountOutputType without action
   */
  export type SpeciesTableCountOutputTypeCountCropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropTableWhereInput
  }


  /**
   * Count Type StakeholderTypesTableCountOutputType
   */

  export type StakeholderTypesTableCountOutputType = {
    cropStakeholdersTable: number
    landStakeholdersTable: number
    organizationsTable: number
    projectStakeholdersTable: number
  }

  export type StakeholderTypesTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropStakeholdersTable?: boolean | StakeholderTypesTableCountOutputTypeCountCropStakeholdersTableArgs
    landStakeholdersTable?: boolean | StakeholderTypesTableCountOutputTypeCountLandStakeholdersTableArgs
    organizationsTable?: boolean | StakeholderTypesTableCountOutputTypeCountOrganizationsTableArgs
    projectStakeholdersTable?: boolean | StakeholderTypesTableCountOutputTypeCountProjectStakeholdersTableArgs
  }

  // Custom InputTypes
  /**
   * StakeholderTypesTableCountOutputType without action
   */
  export type StakeholderTypesTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StakeholderTypesTableCountOutputType
     */
    select?: StakeholderTypesTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StakeholderTypesTableCountOutputType without action
   */
  export type StakeholderTypesTableCountOutputTypeCountCropStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropStakeholdersTableWhereInput
  }

  /**
   * StakeholderTypesTableCountOutputType without action
   */
  export type StakeholderTypesTableCountOutputTypeCountLandStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landStakeholdersTableWhereInput
  }

  /**
   * StakeholderTypesTableCountOutputType without action
   */
  export type StakeholderTypesTableCountOutputTypeCountOrganizationsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationsTableWhereInput
  }

  /**
   * StakeholderTypesTableCountOutputType without action
   */
  export type StakeholderTypesTableCountOutputTypeCountProjectStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectStakeholdersTableWhereInput
  }


  /**
   * Models
   */

  /**
   * Model audit_log_entries
   */

  export type AggregateAudit_log_entries = {
    _count: Audit_log_entriesCountAggregateOutputType | null
    _min: Audit_log_entriesMinAggregateOutputType | null
    _max: Audit_log_entriesMaxAggregateOutputType | null
  }

  export type Audit_log_entriesMinAggregateOutputType = {
    instance_id: string | null
    id: string | null
    created_at: Date | null
    ip_address: string | null
  }

  export type Audit_log_entriesMaxAggregateOutputType = {
    instance_id: string | null
    id: string | null
    created_at: Date | null
    ip_address: string | null
  }

  export type Audit_log_entriesCountAggregateOutputType = {
    instance_id: number
    id: number
    payload: number
    created_at: number
    ip_address: number
    _all: number
  }


  export type Audit_log_entriesMinAggregateInputType = {
    instance_id?: true
    id?: true
    created_at?: true
    ip_address?: true
  }

  export type Audit_log_entriesMaxAggregateInputType = {
    instance_id?: true
    id?: true
    created_at?: true
    ip_address?: true
  }

  export type Audit_log_entriesCountAggregateInputType = {
    instance_id?: true
    id?: true
    payload?: true
    created_at?: true
    ip_address?: true
    _all?: true
  }

  export type Audit_log_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_log_entries to aggregate.
     */
    where?: audit_log_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_log_entries to fetch.
     */
    orderBy?: audit_log_entriesOrderByWithRelationInput | audit_log_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_log_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_log_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_log_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_log_entries
    **/
    _count?: true | Audit_log_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_log_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_log_entriesMaxAggregateInputType
  }

  export type GetAudit_log_entriesAggregateType<T extends Audit_log_entriesAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_log_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_log_entries[P]>
      : GetScalarType<T[P], AggregateAudit_log_entries[P]>
  }




  export type audit_log_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_log_entriesWhereInput
    orderBy?: audit_log_entriesOrderByWithAggregationInput | audit_log_entriesOrderByWithAggregationInput[]
    by: Audit_log_entriesScalarFieldEnum[] | Audit_log_entriesScalarFieldEnum
    having?: audit_log_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_log_entriesCountAggregateInputType | true
    _min?: Audit_log_entriesMinAggregateInputType
    _max?: Audit_log_entriesMaxAggregateInputType
  }

  export type Audit_log_entriesGroupByOutputType = {
    instance_id: string | null
    id: string
    payload: JsonValue | null
    created_at: Date | null
    ip_address: string
    _count: Audit_log_entriesCountAggregateOutputType | null
    _min: Audit_log_entriesMinAggregateOutputType | null
    _max: Audit_log_entriesMaxAggregateOutputType | null
  }

  type GetAudit_log_entriesGroupByPayload<T extends audit_log_entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_log_entriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_log_entriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_log_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_log_entriesGroupByOutputType[P]>
        }
      >
    >


  export type audit_log_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    payload?: boolean
    created_at?: boolean
    ip_address?: boolean
  }, ExtArgs["result"]["audit_log_entries"]>

  export type audit_log_entriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    payload?: boolean
    created_at?: boolean
    ip_address?: boolean
  }, ExtArgs["result"]["audit_log_entries"]>

  export type audit_log_entriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    payload?: boolean
    created_at?: boolean
    ip_address?: boolean
  }, ExtArgs["result"]["audit_log_entries"]>

  export type audit_log_entriesSelectScalar = {
    instance_id?: boolean
    id?: boolean
    payload?: boolean
    created_at?: boolean
    ip_address?: boolean
  }

  export type audit_log_entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"instance_id" | "id" | "payload" | "created_at" | "ip_address", ExtArgs["result"]["audit_log_entries"]>

  export type $audit_log_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_log_entries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      instance_id: string | null
      id: string
      payload: Prisma.JsonValue | null
      created_at: Date | null
      ip_address: string
    }, ExtArgs["result"]["audit_log_entries"]>
    composites: {}
  }

  type audit_log_entriesGetPayload<S extends boolean | null | undefined | audit_log_entriesDefaultArgs> = $Result.GetResult<Prisma.$audit_log_entriesPayload, S>

  type audit_log_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_log_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_log_entriesCountAggregateInputType | true
    }

  export interface audit_log_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_log_entries'], meta: { name: 'audit_log_entries' } }
    /**
     * Find zero or one Audit_log_entries that matches the filter.
     * @param {audit_log_entriesFindUniqueArgs} args - Arguments to find a Audit_log_entries
     * @example
     * // Get one Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_log_entriesFindUniqueArgs>(args: SelectSubset<T, audit_log_entriesFindUniqueArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_log_entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_log_entriesFindUniqueOrThrowArgs} args - Arguments to find a Audit_log_entries
     * @example
     * // Get one Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_log_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_log_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_log_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_log_entriesFindFirstArgs} args - Arguments to find a Audit_log_entries
     * @example
     * // Get one Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_log_entriesFindFirstArgs>(args?: SelectSubset<T, audit_log_entriesFindFirstArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_log_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_log_entriesFindFirstOrThrowArgs} args - Arguments to find a Audit_log_entries
     * @example
     * // Get one Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_log_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_log_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_log_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_log_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.findMany()
     * 
     * // Get first 10 Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.findMany({ take: 10 })
     * 
     * // Only select the `instance_id`
     * const audit_log_entriesWithInstance_idOnly = await prisma.audit_log_entries.findMany({ select: { instance_id: true } })
     * 
     */
    findMany<T extends audit_log_entriesFindManyArgs>(args?: SelectSubset<T, audit_log_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_log_entries.
     * @param {audit_log_entriesCreateArgs} args - Arguments to create a Audit_log_entries.
     * @example
     * // Create one Audit_log_entries
     * const Audit_log_entries = await prisma.audit_log_entries.create({
     *   data: {
     *     // ... data to create a Audit_log_entries
     *   }
     * })
     * 
     */
    create<T extends audit_log_entriesCreateArgs>(args: SelectSubset<T, audit_log_entriesCreateArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_log_entries.
     * @param {audit_log_entriesCreateManyArgs} args - Arguments to create many Audit_log_entries.
     * @example
     * // Create many Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_log_entriesCreateManyArgs>(args?: SelectSubset<T, audit_log_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audit_log_entries and returns the data saved in the database.
     * @param {audit_log_entriesCreateManyAndReturnArgs} args - Arguments to create many Audit_log_entries.
     * @example
     * // Create many Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audit_log_entries and only return the `instance_id`
     * const audit_log_entriesWithInstance_idOnly = await prisma.audit_log_entries.createManyAndReturn({
     *   select: { instance_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends audit_log_entriesCreateManyAndReturnArgs>(args?: SelectSubset<T, audit_log_entriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit_log_entries.
     * @param {audit_log_entriesDeleteArgs} args - Arguments to delete one Audit_log_entries.
     * @example
     * // Delete one Audit_log_entries
     * const Audit_log_entries = await prisma.audit_log_entries.delete({
     *   where: {
     *     // ... filter to delete one Audit_log_entries
     *   }
     * })
     * 
     */
    delete<T extends audit_log_entriesDeleteArgs>(args: SelectSubset<T, audit_log_entriesDeleteArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_log_entries.
     * @param {audit_log_entriesUpdateArgs} args - Arguments to update one Audit_log_entries.
     * @example
     * // Update one Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_log_entriesUpdateArgs>(args: SelectSubset<T, audit_log_entriesUpdateArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_log_entries.
     * @param {audit_log_entriesDeleteManyArgs} args - Arguments to filter Audit_log_entries to delete.
     * @example
     * // Delete a few Audit_log_entries
     * const { count } = await prisma.audit_log_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_log_entriesDeleteManyArgs>(args?: SelectSubset<T, audit_log_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_log_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_log_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_log_entriesUpdateManyArgs>(args: SelectSubset<T, audit_log_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_log_entries and returns the data updated in the database.
     * @param {audit_log_entriesUpdateManyAndReturnArgs} args - Arguments to update many Audit_log_entries.
     * @example
     * // Update many Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audit_log_entries and only return the `instance_id`
     * const audit_log_entriesWithInstance_idOnly = await prisma.audit_log_entries.updateManyAndReturn({
     *   select: { instance_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends audit_log_entriesUpdateManyAndReturnArgs>(args: SelectSubset<T, audit_log_entriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit_log_entries.
     * @param {audit_log_entriesUpsertArgs} args - Arguments to update or create a Audit_log_entries.
     * @example
     * // Update or create a Audit_log_entries
     * const audit_log_entries = await prisma.audit_log_entries.upsert({
     *   create: {
     *     // ... data to create a Audit_log_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_log_entries we want to update
     *   }
     * })
     */
    upsert<T extends audit_log_entriesUpsertArgs>(args: SelectSubset<T, audit_log_entriesUpsertArgs<ExtArgs>>): Prisma__audit_log_entriesClient<$Result.GetResult<Prisma.$audit_log_entriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_log_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_log_entriesCountArgs} args - Arguments to filter Audit_log_entries to count.
     * @example
     * // Count the number of Audit_log_entries
     * const count = await prisma.audit_log_entries.count({
     *   where: {
     *     // ... the filter for the Audit_log_entries we want to count
     *   }
     * })
    **/
    count<T extends audit_log_entriesCountArgs>(
      args?: Subset<T, audit_log_entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_log_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_log_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_log_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_log_entriesAggregateArgs>(args: Subset<T, Audit_log_entriesAggregateArgs>): Prisma.PrismaPromise<GetAudit_log_entriesAggregateType<T>>

    /**
     * Group by Audit_log_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_log_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_log_entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_log_entriesGroupByArgs['orderBy'] }
        : { orderBy?: audit_log_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_log_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_log_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_log_entries model
   */
  readonly fields: audit_log_entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_log_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_log_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_log_entries model
   */
  interface audit_log_entriesFieldRefs {
    readonly instance_id: FieldRef<"audit_log_entries", 'String'>
    readonly id: FieldRef<"audit_log_entries", 'String'>
    readonly payload: FieldRef<"audit_log_entries", 'Json'>
    readonly created_at: FieldRef<"audit_log_entries", 'DateTime'>
    readonly ip_address: FieldRef<"audit_log_entries", 'String'>
  }
    

  // Custom InputTypes
  /**
   * audit_log_entries findUnique
   */
  export type audit_log_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * Filter, which audit_log_entries to fetch.
     */
    where: audit_log_entriesWhereUniqueInput
  }

  /**
   * audit_log_entries findUniqueOrThrow
   */
  export type audit_log_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * Filter, which audit_log_entries to fetch.
     */
    where: audit_log_entriesWhereUniqueInput
  }

  /**
   * audit_log_entries findFirst
   */
  export type audit_log_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * Filter, which audit_log_entries to fetch.
     */
    where?: audit_log_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_log_entries to fetch.
     */
    orderBy?: audit_log_entriesOrderByWithRelationInput | audit_log_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_log_entries.
     */
    cursor?: audit_log_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_log_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_log_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_log_entries.
     */
    distinct?: Audit_log_entriesScalarFieldEnum | Audit_log_entriesScalarFieldEnum[]
  }

  /**
   * audit_log_entries findFirstOrThrow
   */
  export type audit_log_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * Filter, which audit_log_entries to fetch.
     */
    where?: audit_log_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_log_entries to fetch.
     */
    orderBy?: audit_log_entriesOrderByWithRelationInput | audit_log_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_log_entries.
     */
    cursor?: audit_log_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_log_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_log_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_log_entries.
     */
    distinct?: Audit_log_entriesScalarFieldEnum | Audit_log_entriesScalarFieldEnum[]
  }

  /**
   * audit_log_entries findMany
   */
  export type audit_log_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * Filter, which audit_log_entries to fetch.
     */
    where?: audit_log_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_log_entries to fetch.
     */
    orderBy?: audit_log_entriesOrderByWithRelationInput | audit_log_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_log_entries.
     */
    cursor?: audit_log_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_log_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_log_entries.
     */
    skip?: number
    distinct?: Audit_log_entriesScalarFieldEnum | Audit_log_entriesScalarFieldEnum[]
  }

  /**
   * audit_log_entries create
   */
  export type audit_log_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * The data needed to create a audit_log_entries.
     */
    data: XOR<audit_log_entriesCreateInput, audit_log_entriesUncheckedCreateInput>
  }

  /**
   * audit_log_entries createMany
   */
  export type audit_log_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_log_entries.
     */
    data: audit_log_entriesCreateManyInput | audit_log_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_log_entries createManyAndReturn
   */
  export type audit_log_entriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * The data used to create many audit_log_entries.
     */
    data: audit_log_entriesCreateManyInput | audit_log_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_log_entries update
   */
  export type audit_log_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * The data needed to update a audit_log_entries.
     */
    data: XOR<audit_log_entriesUpdateInput, audit_log_entriesUncheckedUpdateInput>
    /**
     * Choose, which audit_log_entries to update.
     */
    where: audit_log_entriesWhereUniqueInput
  }

  /**
   * audit_log_entries updateMany
   */
  export type audit_log_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_log_entries.
     */
    data: XOR<audit_log_entriesUpdateManyMutationInput, audit_log_entriesUncheckedUpdateManyInput>
    /**
     * Filter which audit_log_entries to update
     */
    where?: audit_log_entriesWhereInput
    /**
     * Limit how many audit_log_entries to update.
     */
    limit?: number
  }

  /**
   * audit_log_entries updateManyAndReturn
   */
  export type audit_log_entriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * The data used to update audit_log_entries.
     */
    data: XOR<audit_log_entriesUpdateManyMutationInput, audit_log_entriesUncheckedUpdateManyInput>
    /**
     * Filter which audit_log_entries to update
     */
    where?: audit_log_entriesWhereInput
    /**
     * Limit how many audit_log_entries to update.
     */
    limit?: number
  }

  /**
   * audit_log_entries upsert
   */
  export type audit_log_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * The filter to search for the audit_log_entries to update in case it exists.
     */
    where: audit_log_entriesWhereUniqueInput
    /**
     * In case the audit_log_entries found by the `where` argument doesn't exist, create a new audit_log_entries with this data.
     */
    create: XOR<audit_log_entriesCreateInput, audit_log_entriesUncheckedCreateInput>
    /**
     * In case the audit_log_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_log_entriesUpdateInput, audit_log_entriesUncheckedUpdateInput>
  }

  /**
   * audit_log_entries delete
   */
  export type audit_log_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
    /**
     * Filter which audit_log_entries to delete.
     */
    where: audit_log_entriesWhereUniqueInput
  }

  /**
   * audit_log_entries deleteMany
   */
  export type audit_log_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_log_entries to delete
     */
    where?: audit_log_entriesWhereInput
    /**
     * Limit how many audit_log_entries to delete.
     */
    limit?: number
  }

  /**
   * audit_log_entries without action
   */
  export type audit_log_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_log_entries
     */
    select?: audit_log_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_log_entries
     */
    omit?: audit_log_entriesOmit<ExtArgs> | null
  }


  /**
   * Model flow_state
   */

  export type AggregateFlow_state = {
    _count: Flow_stateCountAggregateOutputType | null
    _min: Flow_stateMinAggregateOutputType | null
    _max: Flow_stateMaxAggregateOutputType | null
  }

  export type Flow_stateMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    auth_code: string | null
    code_challenge_method: $Enums.code_challenge_method | null
    code_challenge: string | null
    provider_type: string | null
    provider_access_token: string | null
    provider_refresh_token: string | null
    created_at: Date | null
    updated_at: Date | null
    authentication_method: string | null
    auth_code_issued_at: Date | null
  }

  export type Flow_stateMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    auth_code: string | null
    code_challenge_method: $Enums.code_challenge_method | null
    code_challenge: string | null
    provider_type: string | null
    provider_access_token: string | null
    provider_refresh_token: string | null
    created_at: Date | null
    updated_at: Date | null
    authentication_method: string | null
    auth_code_issued_at: Date | null
  }

  export type Flow_stateCountAggregateOutputType = {
    id: number
    user_id: number
    auth_code: number
    code_challenge_method: number
    code_challenge: number
    provider_type: number
    provider_access_token: number
    provider_refresh_token: number
    created_at: number
    updated_at: number
    authentication_method: number
    auth_code_issued_at: number
    _all: number
  }


  export type Flow_stateMinAggregateInputType = {
    id?: true
    user_id?: true
    auth_code?: true
    code_challenge_method?: true
    code_challenge?: true
    provider_type?: true
    provider_access_token?: true
    provider_refresh_token?: true
    created_at?: true
    updated_at?: true
    authentication_method?: true
    auth_code_issued_at?: true
  }

  export type Flow_stateMaxAggregateInputType = {
    id?: true
    user_id?: true
    auth_code?: true
    code_challenge_method?: true
    code_challenge?: true
    provider_type?: true
    provider_access_token?: true
    provider_refresh_token?: true
    created_at?: true
    updated_at?: true
    authentication_method?: true
    auth_code_issued_at?: true
  }

  export type Flow_stateCountAggregateInputType = {
    id?: true
    user_id?: true
    auth_code?: true
    code_challenge_method?: true
    code_challenge?: true
    provider_type?: true
    provider_access_token?: true
    provider_refresh_token?: true
    created_at?: true
    updated_at?: true
    authentication_method?: true
    auth_code_issued_at?: true
    _all?: true
  }

  export type Flow_stateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flow_state to aggregate.
     */
    where?: flow_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flow_states to fetch.
     */
    orderBy?: flow_stateOrderByWithRelationInput | flow_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: flow_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flow_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flow_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flow_states
    **/
    _count?: true | Flow_stateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Flow_stateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Flow_stateMaxAggregateInputType
  }

  export type GetFlow_stateAggregateType<T extends Flow_stateAggregateArgs> = {
        [P in keyof T & keyof AggregateFlow_state]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlow_state[P]>
      : GetScalarType<T[P], AggregateFlow_state[P]>
  }




  export type flow_stateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flow_stateWhereInput
    orderBy?: flow_stateOrderByWithAggregationInput | flow_stateOrderByWithAggregationInput[]
    by: Flow_stateScalarFieldEnum[] | Flow_stateScalarFieldEnum
    having?: flow_stateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Flow_stateCountAggregateInputType | true
    _min?: Flow_stateMinAggregateInputType
    _max?: Flow_stateMaxAggregateInputType
  }

  export type Flow_stateGroupByOutputType = {
    id: string
    user_id: string | null
    auth_code: string
    code_challenge_method: $Enums.code_challenge_method
    code_challenge: string
    provider_type: string
    provider_access_token: string | null
    provider_refresh_token: string | null
    created_at: Date | null
    updated_at: Date | null
    authentication_method: string
    auth_code_issued_at: Date | null
    _count: Flow_stateCountAggregateOutputType | null
    _min: Flow_stateMinAggregateOutputType | null
    _max: Flow_stateMaxAggregateOutputType | null
  }

  type GetFlow_stateGroupByPayload<T extends flow_stateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Flow_stateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Flow_stateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Flow_stateGroupByOutputType[P]>
            : GetScalarType<T[P], Flow_stateGroupByOutputType[P]>
        }
      >
    >


  export type flow_stateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    auth_code?: boolean
    code_challenge_method?: boolean
    code_challenge?: boolean
    provider_type?: boolean
    provider_access_token?: boolean
    provider_refresh_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    auth_code_issued_at?: boolean
    saml_relay_states?: boolean | flow_state$saml_relay_statesArgs<ExtArgs>
    _count?: boolean | Flow_stateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flow_state"]>

  export type flow_stateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    auth_code?: boolean
    code_challenge_method?: boolean
    code_challenge?: boolean
    provider_type?: boolean
    provider_access_token?: boolean
    provider_refresh_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    auth_code_issued_at?: boolean
  }, ExtArgs["result"]["flow_state"]>

  export type flow_stateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    auth_code?: boolean
    code_challenge_method?: boolean
    code_challenge?: boolean
    provider_type?: boolean
    provider_access_token?: boolean
    provider_refresh_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    auth_code_issued_at?: boolean
  }, ExtArgs["result"]["flow_state"]>

  export type flow_stateSelectScalar = {
    id?: boolean
    user_id?: boolean
    auth_code?: boolean
    code_challenge_method?: boolean
    code_challenge?: boolean
    provider_type?: boolean
    provider_access_token?: boolean
    provider_refresh_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    auth_code_issued_at?: boolean
  }

  export type flow_stateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "auth_code" | "code_challenge_method" | "code_challenge" | "provider_type" | "provider_access_token" | "provider_refresh_token" | "created_at" | "updated_at" | "authentication_method" | "auth_code_issued_at", ExtArgs["result"]["flow_state"]>
  export type flow_stateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saml_relay_states?: boolean | flow_state$saml_relay_statesArgs<ExtArgs>
    _count?: boolean | Flow_stateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type flow_stateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type flow_stateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $flow_statePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "flow_state"
    objects: {
      saml_relay_states: Prisma.$saml_relay_statesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      auth_code: string
      code_challenge_method: $Enums.code_challenge_method
      code_challenge: string
      provider_type: string
      provider_access_token: string | null
      provider_refresh_token: string | null
      created_at: Date | null
      updated_at: Date | null
      authentication_method: string
      auth_code_issued_at: Date | null
    }, ExtArgs["result"]["flow_state"]>
    composites: {}
  }

  type flow_stateGetPayload<S extends boolean | null | undefined | flow_stateDefaultArgs> = $Result.GetResult<Prisma.$flow_statePayload, S>

  type flow_stateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<flow_stateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Flow_stateCountAggregateInputType | true
    }

  export interface flow_stateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['flow_state'], meta: { name: 'flow_state' } }
    /**
     * Find zero or one Flow_state that matches the filter.
     * @param {flow_stateFindUniqueArgs} args - Arguments to find a Flow_state
     * @example
     * // Get one Flow_state
     * const flow_state = await prisma.flow_state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends flow_stateFindUniqueArgs>(args: SelectSubset<T, flow_stateFindUniqueArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flow_state that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {flow_stateFindUniqueOrThrowArgs} args - Arguments to find a Flow_state
     * @example
     * // Get one Flow_state
     * const flow_state = await prisma.flow_state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends flow_stateFindUniqueOrThrowArgs>(args: SelectSubset<T, flow_stateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flow_state that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flow_stateFindFirstArgs} args - Arguments to find a Flow_state
     * @example
     * // Get one Flow_state
     * const flow_state = await prisma.flow_state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends flow_stateFindFirstArgs>(args?: SelectSubset<T, flow_stateFindFirstArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flow_state that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flow_stateFindFirstOrThrowArgs} args - Arguments to find a Flow_state
     * @example
     * // Get one Flow_state
     * const flow_state = await prisma.flow_state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends flow_stateFindFirstOrThrowArgs>(args?: SelectSubset<T, flow_stateFindFirstOrThrowArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flow_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flow_stateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flow_states
     * const flow_states = await prisma.flow_state.findMany()
     * 
     * // Get first 10 Flow_states
     * const flow_states = await prisma.flow_state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flow_stateWithIdOnly = await prisma.flow_state.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends flow_stateFindManyArgs>(args?: SelectSubset<T, flow_stateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flow_state.
     * @param {flow_stateCreateArgs} args - Arguments to create a Flow_state.
     * @example
     * // Create one Flow_state
     * const Flow_state = await prisma.flow_state.create({
     *   data: {
     *     // ... data to create a Flow_state
     *   }
     * })
     * 
     */
    create<T extends flow_stateCreateArgs>(args: SelectSubset<T, flow_stateCreateArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flow_states.
     * @param {flow_stateCreateManyArgs} args - Arguments to create many Flow_states.
     * @example
     * // Create many Flow_states
     * const flow_state = await prisma.flow_state.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends flow_stateCreateManyArgs>(args?: SelectSubset<T, flow_stateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flow_states and returns the data saved in the database.
     * @param {flow_stateCreateManyAndReturnArgs} args - Arguments to create many Flow_states.
     * @example
     * // Create many Flow_states
     * const flow_state = await prisma.flow_state.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flow_states and only return the `id`
     * const flow_stateWithIdOnly = await prisma.flow_state.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends flow_stateCreateManyAndReturnArgs>(args?: SelectSubset<T, flow_stateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flow_state.
     * @param {flow_stateDeleteArgs} args - Arguments to delete one Flow_state.
     * @example
     * // Delete one Flow_state
     * const Flow_state = await prisma.flow_state.delete({
     *   where: {
     *     // ... filter to delete one Flow_state
     *   }
     * })
     * 
     */
    delete<T extends flow_stateDeleteArgs>(args: SelectSubset<T, flow_stateDeleteArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flow_state.
     * @param {flow_stateUpdateArgs} args - Arguments to update one Flow_state.
     * @example
     * // Update one Flow_state
     * const flow_state = await prisma.flow_state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends flow_stateUpdateArgs>(args: SelectSubset<T, flow_stateUpdateArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flow_states.
     * @param {flow_stateDeleteManyArgs} args - Arguments to filter Flow_states to delete.
     * @example
     * // Delete a few Flow_states
     * const { count } = await prisma.flow_state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends flow_stateDeleteManyArgs>(args?: SelectSubset<T, flow_stateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flow_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flow_stateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flow_states
     * const flow_state = await prisma.flow_state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends flow_stateUpdateManyArgs>(args: SelectSubset<T, flow_stateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flow_states and returns the data updated in the database.
     * @param {flow_stateUpdateManyAndReturnArgs} args - Arguments to update many Flow_states.
     * @example
     * // Update many Flow_states
     * const flow_state = await prisma.flow_state.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flow_states and only return the `id`
     * const flow_stateWithIdOnly = await prisma.flow_state.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends flow_stateUpdateManyAndReturnArgs>(args: SelectSubset<T, flow_stateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flow_state.
     * @param {flow_stateUpsertArgs} args - Arguments to update or create a Flow_state.
     * @example
     * // Update or create a Flow_state
     * const flow_state = await prisma.flow_state.upsert({
     *   create: {
     *     // ... data to create a Flow_state
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flow_state we want to update
     *   }
     * })
     */
    upsert<T extends flow_stateUpsertArgs>(args: SelectSubset<T, flow_stateUpsertArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flow_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flow_stateCountArgs} args - Arguments to filter Flow_states to count.
     * @example
     * // Count the number of Flow_states
     * const count = await prisma.flow_state.count({
     *   where: {
     *     // ... the filter for the Flow_states we want to count
     *   }
     * })
    **/
    count<T extends flow_stateCountArgs>(
      args?: Subset<T, flow_stateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Flow_stateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flow_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Flow_stateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Flow_stateAggregateArgs>(args: Subset<T, Flow_stateAggregateArgs>): Prisma.PrismaPromise<GetFlow_stateAggregateType<T>>

    /**
     * Group by Flow_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flow_stateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends flow_stateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: flow_stateGroupByArgs['orderBy'] }
        : { orderBy?: flow_stateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, flow_stateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlow_stateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the flow_state model
   */
  readonly fields: flow_stateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for flow_state.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__flow_stateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saml_relay_states<T extends flow_state$saml_relay_statesArgs<ExtArgs> = {}>(args?: Subset<T, flow_state$saml_relay_statesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the flow_state model
   */
  interface flow_stateFieldRefs {
    readonly id: FieldRef<"flow_state", 'String'>
    readonly user_id: FieldRef<"flow_state", 'String'>
    readonly auth_code: FieldRef<"flow_state", 'String'>
    readonly code_challenge_method: FieldRef<"flow_state", 'code_challenge_method'>
    readonly code_challenge: FieldRef<"flow_state", 'String'>
    readonly provider_type: FieldRef<"flow_state", 'String'>
    readonly provider_access_token: FieldRef<"flow_state", 'String'>
    readonly provider_refresh_token: FieldRef<"flow_state", 'String'>
    readonly created_at: FieldRef<"flow_state", 'DateTime'>
    readonly updated_at: FieldRef<"flow_state", 'DateTime'>
    readonly authentication_method: FieldRef<"flow_state", 'String'>
    readonly auth_code_issued_at: FieldRef<"flow_state", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * flow_state findUnique
   */
  export type flow_stateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * Filter, which flow_state to fetch.
     */
    where: flow_stateWhereUniqueInput
  }

  /**
   * flow_state findUniqueOrThrow
   */
  export type flow_stateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * Filter, which flow_state to fetch.
     */
    where: flow_stateWhereUniqueInput
  }

  /**
   * flow_state findFirst
   */
  export type flow_stateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * Filter, which flow_state to fetch.
     */
    where?: flow_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flow_states to fetch.
     */
    orderBy?: flow_stateOrderByWithRelationInput | flow_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flow_states.
     */
    cursor?: flow_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flow_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flow_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flow_states.
     */
    distinct?: Flow_stateScalarFieldEnum | Flow_stateScalarFieldEnum[]
  }

  /**
   * flow_state findFirstOrThrow
   */
  export type flow_stateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * Filter, which flow_state to fetch.
     */
    where?: flow_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flow_states to fetch.
     */
    orderBy?: flow_stateOrderByWithRelationInput | flow_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flow_states.
     */
    cursor?: flow_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flow_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flow_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flow_states.
     */
    distinct?: Flow_stateScalarFieldEnum | Flow_stateScalarFieldEnum[]
  }

  /**
   * flow_state findMany
   */
  export type flow_stateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * Filter, which flow_states to fetch.
     */
    where?: flow_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flow_states to fetch.
     */
    orderBy?: flow_stateOrderByWithRelationInput | flow_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flow_states.
     */
    cursor?: flow_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flow_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flow_states.
     */
    skip?: number
    distinct?: Flow_stateScalarFieldEnum | Flow_stateScalarFieldEnum[]
  }

  /**
   * flow_state create
   */
  export type flow_stateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * The data needed to create a flow_state.
     */
    data: XOR<flow_stateCreateInput, flow_stateUncheckedCreateInput>
  }

  /**
   * flow_state createMany
   */
  export type flow_stateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many flow_states.
     */
    data: flow_stateCreateManyInput | flow_stateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flow_state createManyAndReturn
   */
  export type flow_stateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * The data used to create many flow_states.
     */
    data: flow_stateCreateManyInput | flow_stateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flow_state update
   */
  export type flow_stateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * The data needed to update a flow_state.
     */
    data: XOR<flow_stateUpdateInput, flow_stateUncheckedUpdateInput>
    /**
     * Choose, which flow_state to update.
     */
    where: flow_stateWhereUniqueInput
  }

  /**
   * flow_state updateMany
   */
  export type flow_stateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update flow_states.
     */
    data: XOR<flow_stateUpdateManyMutationInput, flow_stateUncheckedUpdateManyInput>
    /**
     * Filter which flow_states to update
     */
    where?: flow_stateWhereInput
    /**
     * Limit how many flow_states to update.
     */
    limit?: number
  }

  /**
   * flow_state updateManyAndReturn
   */
  export type flow_stateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * The data used to update flow_states.
     */
    data: XOR<flow_stateUpdateManyMutationInput, flow_stateUncheckedUpdateManyInput>
    /**
     * Filter which flow_states to update
     */
    where?: flow_stateWhereInput
    /**
     * Limit how many flow_states to update.
     */
    limit?: number
  }

  /**
   * flow_state upsert
   */
  export type flow_stateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * The filter to search for the flow_state to update in case it exists.
     */
    where: flow_stateWhereUniqueInput
    /**
     * In case the flow_state found by the `where` argument doesn't exist, create a new flow_state with this data.
     */
    create: XOR<flow_stateCreateInput, flow_stateUncheckedCreateInput>
    /**
     * In case the flow_state was found with the provided `where` argument, update it with this data.
     */
    update: XOR<flow_stateUpdateInput, flow_stateUncheckedUpdateInput>
  }

  /**
   * flow_state delete
   */
  export type flow_stateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    /**
     * Filter which flow_state to delete.
     */
    where: flow_stateWhereUniqueInput
  }

  /**
   * flow_state deleteMany
   */
  export type flow_stateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flow_states to delete
     */
    where?: flow_stateWhereInput
    /**
     * Limit how many flow_states to delete.
     */
    limit?: number
  }

  /**
   * flow_state.saml_relay_states
   */
  export type flow_state$saml_relay_statesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    where?: saml_relay_statesWhereInput
    orderBy?: saml_relay_statesOrderByWithRelationInput | saml_relay_statesOrderByWithRelationInput[]
    cursor?: saml_relay_statesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Saml_relay_statesScalarFieldEnum | Saml_relay_statesScalarFieldEnum[]
  }

  /**
   * flow_state without action
   */
  export type flow_stateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
  }


  /**
   * Model identities
   */

  export type AggregateIdentities = {
    _count: IdentitiesCountAggregateOutputType | null
    _min: IdentitiesMinAggregateOutputType | null
    _max: IdentitiesMaxAggregateOutputType | null
  }

  export type IdentitiesMinAggregateOutputType = {
    provider_id: string | null
    user_id: string | null
    provider: string | null
    last_sign_in_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    email: string | null
    id: string | null
  }

  export type IdentitiesMaxAggregateOutputType = {
    provider_id: string | null
    user_id: string | null
    provider: string | null
    last_sign_in_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    email: string | null
    id: string | null
  }

  export type IdentitiesCountAggregateOutputType = {
    provider_id: number
    user_id: number
    identity_data: number
    provider: number
    last_sign_in_at: number
    created_at: number
    updated_at: number
    email: number
    id: number
    _all: number
  }


  export type IdentitiesMinAggregateInputType = {
    provider_id?: true
    user_id?: true
    provider?: true
    last_sign_in_at?: true
    created_at?: true
    updated_at?: true
    email?: true
    id?: true
  }

  export type IdentitiesMaxAggregateInputType = {
    provider_id?: true
    user_id?: true
    provider?: true
    last_sign_in_at?: true
    created_at?: true
    updated_at?: true
    email?: true
    id?: true
  }

  export type IdentitiesCountAggregateInputType = {
    provider_id?: true
    user_id?: true
    identity_data?: true
    provider?: true
    last_sign_in_at?: true
    created_at?: true
    updated_at?: true
    email?: true
    id?: true
    _all?: true
  }

  export type IdentitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which identities to aggregate.
     */
    where?: identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of identities to fetch.
     */
    orderBy?: identitiesOrderByWithRelationInput | identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned identities
    **/
    _count?: true | IdentitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentitiesMaxAggregateInputType
  }

  export type GetIdentitiesAggregateType<T extends IdentitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentities[P]>
      : GetScalarType<T[P], AggregateIdentities[P]>
  }




  export type identitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: identitiesWhereInput
    orderBy?: identitiesOrderByWithAggregationInput | identitiesOrderByWithAggregationInput[]
    by: IdentitiesScalarFieldEnum[] | IdentitiesScalarFieldEnum
    having?: identitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentitiesCountAggregateInputType | true
    _min?: IdentitiesMinAggregateInputType
    _max?: IdentitiesMaxAggregateInputType
  }

  export type IdentitiesGroupByOutputType = {
    provider_id: string
    user_id: string
    identity_data: JsonValue
    provider: string
    last_sign_in_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    email: string | null
    id: string
    _count: IdentitiesCountAggregateOutputType | null
    _min: IdentitiesMinAggregateOutputType | null
    _max: IdentitiesMaxAggregateOutputType | null
  }

  type GetIdentitiesGroupByPayload<T extends identitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdentitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentitiesGroupByOutputType[P]>
            : GetScalarType<T[P], IdentitiesGroupByOutputType[P]>
        }
      >
    >


  export type identitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    user_id?: boolean
    identity_data?: boolean
    provider?: boolean
    last_sign_in_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identities"]>

  export type identitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    user_id?: boolean
    identity_data?: boolean
    provider?: boolean
    last_sign_in_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identities"]>

  export type identitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    user_id?: boolean
    identity_data?: boolean
    provider?: boolean
    last_sign_in_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identities"]>

  export type identitiesSelectScalar = {
    provider_id?: boolean
    user_id?: boolean
    identity_data?: boolean
    provider?: boolean
    last_sign_in_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    id?: boolean
  }

  export type identitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"provider_id" | "user_id" | "identity_data" | "provider" | "last_sign_in_at" | "created_at" | "updated_at" | "email" | "id", ExtArgs["result"]["identities"]>
  export type identitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type identitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type identitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $identitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "identities"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      provider_id: string
      user_id: string
      identity_data: Prisma.JsonValue
      provider: string
      last_sign_in_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      email: string | null
      id: string
    }, ExtArgs["result"]["identities"]>
    composites: {}
  }

  type identitiesGetPayload<S extends boolean | null | undefined | identitiesDefaultArgs> = $Result.GetResult<Prisma.$identitiesPayload, S>

  type identitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<identitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdentitiesCountAggregateInputType | true
    }

  export interface identitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['identities'], meta: { name: 'identities' } }
    /**
     * Find zero or one Identities that matches the filter.
     * @param {identitiesFindUniqueArgs} args - Arguments to find a Identities
     * @example
     * // Get one Identities
     * const identities = await prisma.identities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends identitiesFindUniqueArgs>(args: SelectSubset<T, identitiesFindUniqueArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Identities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {identitiesFindUniqueOrThrowArgs} args - Arguments to find a Identities
     * @example
     * // Get one Identities
     * const identities = await prisma.identities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends identitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, identitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {identitiesFindFirstArgs} args - Arguments to find a Identities
     * @example
     * // Get one Identities
     * const identities = await prisma.identities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends identitiesFindFirstArgs>(args?: SelectSubset<T, identitiesFindFirstArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {identitiesFindFirstOrThrowArgs} args - Arguments to find a Identities
     * @example
     * // Get one Identities
     * const identities = await prisma.identities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends identitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, identitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Identities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {identitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Identities
     * const identities = await prisma.identities.findMany()
     * 
     * // Get first 10 Identities
     * const identities = await prisma.identities.findMany({ take: 10 })
     * 
     * // Only select the `provider_id`
     * const identitiesWithProvider_idOnly = await prisma.identities.findMany({ select: { provider_id: true } })
     * 
     */
    findMany<T extends identitiesFindManyArgs>(args?: SelectSubset<T, identitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Identities.
     * @param {identitiesCreateArgs} args - Arguments to create a Identities.
     * @example
     * // Create one Identities
     * const Identities = await prisma.identities.create({
     *   data: {
     *     // ... data to create a Identities
     *   }
     * })
     * 
     */
    create<T extends identitiesCreateArgs>(args: SelectSubset<T, identitiesCreateArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Identities.
     * @param {identitiesCreateManyArgs} args - Arguments to create many Identities.
     * @example
     * // Create many Identities
     * const identities = await prisma.identities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends identitiesCreateManyArgs>(args?: SelectSubset<T, identitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Identities and returns the data saved in the database.
     * @param {identitiesCreateManyAndReturnArgs} args - Arguments to create many Identities.
     * @example
     * // Create many Identities
     * const identities = await prisma.identities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Identities and only return the `provider_id`
     * const identitiesWithProvider_idOnly = await prisma.identities.createManyAndReturn({
     *   select: { provider_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends identitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, identitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Identities.
     * @param {identitiesDeleteArgs} args - Arguments to delete one Identities.
     * @example
     * // Delete one Identities
     * const Identities = await prisma.identities.delete({
     *   where: {
     *     // ... filter to delete one Identities
     *   }
     * })
     * 
     */
    delete<T extends identitiesDeleteArgs>(args: SelectSubset<T, identitiesDeleteArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Identities.
     * @param {identitiesUpdateArgs} args - Arguments to update one Identities.
     * @example
     * // Update one Identities
     * const identities = await prisma.identities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends identitiesUpdateArgs>(args: SelectSubset<T, identitiesUpdateArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Identities.
     * @param {identitiesDeleteManyArgs} args - Arguments to filter Identities to delete.
     * @example
     * // Delete a few Identities
     * const { count } = await prisma.identities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends identitiesDeleteManyArgs>(args?: SelectSubset<T, identitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {identitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Identities
     * const identities = await prisma.identities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends identitiesUpdateManyArgs>(args: SelectSubset<T, identitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identities and returns the data updated in the database.
     * @param {identitiesUpdateManyAndReturnArgs} args - Arguments to update many Identities.
     * @example
     * // Update many Identities
     * const identities = await prisma.identities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Identities and only return the `provider_id`
     * const identitiesWithProvider_idOnly = await prisma.identities.updateManyAndReturn({
     *   select: { provider_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends identitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, identitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Identities.
     * @param {identitiesUpsertArgs} args - Arguments to update or create a Identities.
     * @example
     * // Update or create a Identities
     * const identities = await prisma.identities.upsert({
     *   create: {
     *     // ... data to create a Identities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Identities we want to update
     *   }
     * })
     */
    upsert<T extends identitiesUpsertArgs>(args: SelectSubset<T, identitiesUpsertArgs<ExtArgs>>): Prisma__identitiesClient<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {identitiesCountArgs} args - Arguments to filter Identities to count.
     * @example
     * // Count the number of Identities
     * const count = await prisma.identities.count({
     *   where: {
     *     // ... the filter for the Identities we want to count
     *   }
     * })
    **/
    count<T extends identitiesCountArgs>(
      args?: Subset<T, identitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentitiesAggregateArgs>(args: Subset<T, IdentitiesAggregateArgs>): Prisma.PrismaPromise<GetIdentitiesAggregateType<T>>

    /**
     * Group by Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {identitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends identitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: identitiesGroupByArgs['orderBy'] }
        : { orderBy?: identitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, identitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the identities model
   */
  readonly fields: identitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for identities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__identitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the identities model
   */
  interface identitiesFieldRefs {
    readonly provider_id: FieldRef<"identities", 'String'>
    readonly user_id: FieldRef<"identities", 'String'>
    readonly identity_data: FieldRef<"identities", 'Json'>
    readonly provider: FieldRef<"identities", 'String'>
    readonly last_sign_in_at: FieldRef<"identities", 'DateTime'>
    readonly created_at: FieldRef<"identities", 'DateTime'>
    readonly updated_at: FieldRef<"identities", 'DateTime'>
    readonly email: FieldRef<"identities", 'String'>
    readonly id: FieldRef<"identities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * identities findUnique
   */
  export type identitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * Filter, which identities to fetch.
     */
    where: identitiesWhereUniqueInput
  }

  /**
   * identities findUniqueOrThrow
   */
  export type identitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * Filter, which identities to fetch.
     */
    where: identitiesWhereUniqueInput
  }

  /**
   * identities findFirst
   */
  export type identitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * Filter, which identities to fetch.
     */
    where?: identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of identities to fetch.
     */
    orderBy?: identitiesOrderByWithRelationInput | identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for identities.
     */
    cursor?: identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of identities.
     */
    distinct?: IdentitiesScalarFieldEnum | IdentitiesScalarFieldEnum[]
  }

  /**
   * identities findFirstOrThrow
   */
  export type identitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * Filter, which identities to fetch.
     */
    where?: identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of identities to fetch.
     */
    orderBy?: identitiesOrderByWithRelationInput | identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for identities.
     */
    cursor?: identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of identities.
     */
    distinct?: IdentitiesScalarFieldEnum | IdentitiesScalarFieldEnum[]
  }

  /**
   * identities findMany
   */
  export type identitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * Filter, which identities to fetch.
     */
    where?: identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of identities to fetch.
     */
    orderBy?: identitiesOrderByWithRelationInput | identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing identities.
     */
    cursor?: identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` identities.
     */
    skip?: number
    distinct?: IdentitiesScalarFieldEnum | IdentitiesScalarFieldEnum[]
  }

  /**
   * identities create
   */
  export type identitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a identities.
     */
    data: XOR<identitiesCreateInput, identitiesUncheckedCreateInput>
  }

  /**
   * identities createMany
   */
  export type identitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many identities.
     */
    data: identitiesCreateManyInput | identitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * identities createManyAndReturn
   */
  export type identitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * The data used to create many identities.
     */
    data: identitiesCreateManyInput | identitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * identities update
   */
  export type identitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a identities.
     */
    data: XOR<identitiesUpdateInput, identitiesUncheckedUpdateInput>
    /**
     * Choose, which identities to update.
     */
    where: identitiesWhereUniqueInput
  }

  /**
   * identities updateMany
   */
  export type identitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update identities.
     */
    data: XOR<identitiesUpdateManyMutationInput, identitiesUncheckedUpdateManyInput>
    /**
     * Filter which identities to update
     */
    where?: identitiesWhereInput
    /**
     * Limit how many identities to update.
     */
    limit?: number
  }

  /**
   * identities updateManyAndReturn
   */
  export type identitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * The data used to update identities.
     */
    data: XOR<identitiesUpdateManyMutationInput, identitiesUncheckedUpdateManyInput>
    /**
     * Filter which identities to update
     */
    where?: identitiesWhereInput
    /**
     * Limit how many identities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * identities upsert
   */
  export type identitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the identities to update in case it exists.
     */
    where: identitiesWhereUniqueInput
    /**
     * In case the identities found by the `where` argument doesn't exist, create a new identities with this data.
     */
    create: XOR<identitiesCreateInput, identitiesUncheckedCreateInput>
    /**
     * In case the identities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<identitiesUpdateInput, identitiesUncheckedUpdateInput>
  }

  /**
   * identities delete
   */
  export type identitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    /**
     * Filter which identities to delete.
     */
    where: identitiesWhereUniqueInput
  }

  /**
   * identities deleteMany
   */
  export type identitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which identities to delete
     */
    where?: identitiesWhereInput
    /**
     * Limit how many identities to delete.
     */
    limit?: number
  }

  /**
   * identities without action
   */
  export type identitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
  }


  /**
   * Model instances
   */

  export type AggregateInstances = {
    _count: InstancesCountAggregateOutputType | null
    _min: InstancesMinAggregateOutputType | null
    _max: InstancesMaxAggregateOutputType | null
  }

  export type InstancesMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    raw_base_config: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InstancesMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    raw_base_config: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InstancesCountAggregateOutputType = {
    id: number
    uuid: number
    raw_base_config: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InstancesMinAggregateInputType = {
    id?: true
    uuid?: true
    raw_base_config?: true
    created_at?: true
    updated_at?: true
  }

  export type InstancesMaxAggregateInputType = {
    id?: true
    uuid?: true
    raw_base_config?: true
    created_at?: true
    updated_at?: true
  }

  export type InstancesCountAggregateInputType = {
    id?: true
    uuid?: true
    raw_base_config?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InstancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which instances to aggregate.
     */
    where?: instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instances to fetch.
     */
    orderBy?: instancesOrderByWithRelationInput | instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned instances
    **/
    _count?: true | InstancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstancesMaxAggregateInputType
  }

  export type GetInstancesAggregateType<T extends InstancesAggregateArgs> = {
        [P in keyof T & keyof AggregateInstances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstances[P]>
      : GetScalarType<T[P], AggregateInstances[P]>
  }




  export type instancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: instancesWhereInput
    orderBy?: instancesOrderByWithAggregationInput | instancesOrderByWithAggregationInput[]
    by: InstancesScalarFieldEnum[] | InstancesScalarFieldEnum
    having?: instancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstancesCountAggregateInputType | true
    _min?: InstancesMinAggregateInputType
    _max?: InstancesMaxAggregateInputType
  }

  export type InstancesGroupByOutputType = {
    id: string
    uuid: string | null
    raw_base_config: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: InstancesCountAggregateOutputType | null
    _min: InstancesMinAggregateOutputType | null
    _max: InstancesMaxAggregateOutputType | null
  }

  type GetInstancesGroupByPayload<T extends instancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstancesGroupByOutputType[P]>
            : GetScalarType<T[P], InstancesGroupByOutputType[P]>
        }
      >
    >


  export type instancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    raw_base_config?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["instances"]>

  export type instancesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    raw_base_config?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["instances"]>

  export type instancesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    raw_base_config?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["instances"]>

  export type instancesSelectScalar = {
    id?: boolean
    uuid?: boolean
    raw_base_config?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type instancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "raw_base_config" | "created_at" | "updated_at", ExtArgs["result"]["instances"]>

  export type $instancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "instances"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string | null
      raw_base_config: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["instances"]>
    composites: {}
  }

  type instancesGetPayload<S extends boolean | null | undefined | instancesDefaultArgs> = $Result.GetResult<Prisma.$instancesPayload, S>

  type instancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<instancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstancesCountAggregateInputType | true
    }

  export interface instancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['instances'], meta: { name: 'instances' } }
    /**
     * Find zero or one Instances that matches the filter.
     * @param {instancesFindUniqueArgs} args - Arguments to find a Instances
     * @example
     * // Get one Instances
     * const instances = await prisma.instances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends instancesFindUniqueArgs>(args: SelectSubset<T, instancesFindUniqueArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {instancesFindUniqueOrThrowArgs} args - Arguments to find a Instances
     * @example
     * // Get one Instances
     * const instances = await prisma.instances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends instancesFindUniqueOrThrowArgs>(args: SelectSubset<T, instancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instancesFindFirstArgs} args - Arguments to find a Instances
     * @example
     * // Get one Instances
     * const instances = await prisma.instances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends instancesFindFirstArgs>(args?: SelectSubset<T, instancesFindFirstArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instancesFindFirstOrThrowArgs} args - Arguments to find a Instances
     * @example
     * // Get one Instances
     * const instances = await prisma.instances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends instancesFindFirstOrThrowArgs>(args?: SelectSubset<T, instancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instances
     * const instances = await prisma.instances.findMany()
     * 
     * // Get first 10 Instances
     * const instances = await prisma.instances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instancesWithIdOnly = await prisma.instances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends instancesFindManyArgs>(args?: SelectSubset<T, instancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instances.
     * @param {instancesCreateArgs} args - Arguments to create a Instances.
     * @example
     * // Create one Instances
     * const Instances = await prisma.instances.create({
     *   data: {
     *     // ... data to create a Instances
     *   }
     * })
     * 
     */
    create<T extends instancesCreateArgs>(args: SelectSubset<T, instancesCreateArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instances.
     * @param {instancesCreateManyArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instances = await prisma.instances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends instancesCreateManyArgs>(args?: SelectSubset<T, instancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instances and returns the data saved in the database.
     * @param {instancesCreateManyAndReturnArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instances = await prisma.instances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instances and only return the `id`
     * const instancesWithIdOnly = await prisma.instances.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends instancesCreateManyAndReturnArgs>(args?: SelectSubset<T, instancesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instances.
     * @param {instancesDeleteArgs} args - Arguments to delete one Instances.
     * @example
     * // Delete one Instances
     * const Instances = await prisma.instances.delete({
     *   where: {
     *     // ... filter to delete one Instances
     *   }
     * })
     * 
     */
    delete<T extends instancesDeleteArgs>(args: SelectSubset<T, instancesDeleteArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instances.
     * @param {instancesUpdateArgs} args - Arguments to update one Instances.
     * @example
     * // Update one Instances
     * const instances = await prisma.instances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends instancesUpdateArgs>(args: SelectSubset<T, instancesUpdateArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instances.
     * @param {instancesDeleteManyArgs} args - Arguments to filter Instances to delete.
     * @example
     * // Delete a few Instances
     * const { count } = await prisma.instances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends instancesDeleteManyArgs>(args?: SelectSubset<T, instancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instances
     * const instances = await prisma.instances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends instancesUpdateManyArgs>(args: SelectSubset<T, instancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances and returns the data updated in the database.
     * @param {instancesUpdateManyAndReturnArgs} args - Arguments to update many Instances.
     * @example
     * // Update many Instances
     * const instances = await prisma.instances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instances and only return the `id`
     * const instancesWithIdOnly = await prisma.instances.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends instancesUpdateManyAndReturnArgs>(args: SelectSubset<T, instancesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instances.
     * @param {instancesUpsertArgs} args - Arguments to update or create a Instances.
     * @example
     * // Update or create a Instances
     * const instances = await prisma.instances.upsert({
     *   create: {
     *     // ... data to create a Instances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instances we want to update
     *   }
     * })
     */
    upsert<T extends instancesUpsertArgs>(args: SelectSubset<T, instancesUpsertArgs<ExtArgs>>): Prisma__instancesClient<$Result.GetResult<Prisma.$instancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instancesCountArgs} args - Arguments to filter Instances to count.
     * @example
     * // Count the number of Instances
     * const count = await prisma.instances.count({
     *   where: {
     *     // ... the filter for the Instances we want to count
     *   }
     * })
    **/
    count<T extends instancesCountArgs>(
      args?: Subset<T, instancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstancesAggregateArgs>(args: Subset<T, InstancesAggregateArgs>): Prisma.PrismaPromise<GetInstancesAggregateType<T>>

    /**
     * Group by Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends instancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: instancesGroupByArgs['orderBy'] }
        : { orderBy?: instancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, instancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the instances model
   */
  readonly fields: instancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for instances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__instancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the instances model
   */
  interface instancesFieldRefs {
    readonly id: FieldRef<"instances", 'String'>
    readonly uuid: FieldRef<"instances", 'String'>
    readonly raw_base_config: FieldRef<"instances", 'String'>
    readonly created_at: FieldRef<"instances", 'DateTime'>
    readonly updated_at: FieldRef<"instances", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * instances findUnique
   */
  export type instancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * Filter, which instances to fetch.
     */
    where: instancesWhereUniqueInput
  }

  /**
   * instances findUniqueOrThrow
   */
  export type instancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * Filter, which instances to fetch.
     */
    where: instancesWhereUniqueInput
  }

  /**
   * instances findFirst
   */
  export type instancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * Filter, which instances to fetch.
     */
    where?: instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instances to fetch.
     */
    orderBy?: instancesOrderByWithRelationInput | instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instances.
     */
    cursor?: instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instances.
     */
    distinct?: InstancesScalarFieldEnum | InstancesScalarFieldEnum[]
  }

  /**
   * instances findFirstOrThrow
   */
  export type instancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * Filter, which instances to fetch.
     */
    where?: instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instances to fetch.
     */
    orderBy?: instancesOrderByWithRelationInput | instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instances.
     */
    cursor?: instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instances.
     */
    distinct?: InstancesScalarFieldEnum | InstancesScalarFieldEnum[]
  }

  /**
   * instances findMany
   */
  export type instancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * Filter, which instances to fetch.
     */
    where?: instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instances to fetch.
     */
    orderBy?: instancesOrderByWithRelationInput | instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing instances.
     */
    cursor?: instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instances.
     */
    skip?: number
    distinct?: InstancesScalarFieldEnum | InstancesScalarFieldEnum[]
  }

  /**
   * instances create
   */
  export type instancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * The data needed to create a instances.
     */
    data: XOR<instancesCreateInput, instancesUncheckedCreateInput>
  }

  /**
   * instances createMany
   */
  export type instancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many instances.
     */
    data: instancesCreateManyInput | instancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * instances createManyAndReturn
   */
  export type instancesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * The data used to create many instances.
     */
    data: instancesCreateManyInput | instancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * instances update
   */
  export type instancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * The data needed to update a instances.
     */
    data: XOR<instancesUpdateInput, instancesUncheckedUpdateInput>
    /**
     * Choose, which instances to update.
     */
    where: instancesWhereUniqueInput
  }

  /**
   * instances updateMany
   */
  export type instancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update instances.
     */
    data: XOR<instancesUpdateManyMutationInput, instancesUncheckedUpdateManyInput>
    /**
     * Filter which instances to update
     */
    where?: instancesWhereInput
    /**
     * Limit how many instances to update.
     */
    limit?: number
  }

  /**
   * instances updateManyAndReturn
   */
  export type instancesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * The data used to update instances.
     */
    data: XOR<instancesUpdateManyMutationInput, instancesUncheckedUpdateManyInput>
    /**
     * Filter which instances to update
     */
    where?: instancesWhereInput
    /**
     * Limit how many instances to update.
     */
    limit?: number
  }

  /**
   * instances upsert
   */
  export type instancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * The filter to search for the instances to update in case it exists.
     */
    where: instancesWhereUniqueInput
    /**
     * In case the instances found by the `where` argument doesn't exist, create a new instances with this data.
     */
    create: XOR<instancesCreateInput, instancesUncheckedCreateInput>
    /**
     * In case the instances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<instancesUpdateInput, instancesUncheckedUpdateInput>
  }

  /**
   * instances delete
   */
  export type instancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
    /**
     * Filter which instances to delete.
     */
    where: instancesWhereUniqueInput
  }

  /**
   * instances deleteMany
   */
  export type instancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which instances to delete
     */
    where?: instancesWhereInput
    /**
     * Limit how many instances to delete.
     */
    limit?: number
  }

  /**
   * instances without action
   */
  export type instancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instances
     */
    select?: instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the instances
     */
    omit?: instancesOmit<ExtArgs> | null
  }


  /**
   * Model mfa_amr_claims
   */

  export type AggregateMfa_amr_claims = {
    _count: Mfa_amr_claimsCountAggregateOutputType | null
    _min: Mfa_amr_claimsMinAggregateOutputType | null
    _max: Mfa_amr_claimsMaxAggregateOutputType | null
  }

  export type Mfa_amr_claimsMinAggregateOutputType = {
    session_id: string | null
    created_at: Date | null
    updated_at: Date | null
    authentication_method: string | null
    id: string | null
  }

  export type Mfa_amr_claimsMaxAggregateOutputType = {
    session_id: string | null
    created_at: Date | null
    updated_at: Date | null
    authentication_method: string | null
    id: string | null
  }

  export type Mfa_amr_claimsCountAggregateOutputType = {
    session_id: number
    created_at: number
    updated_at: number
    authentication_method: number
    id: number
    _all: number
  }


  export type Mfa_amr_claimsMinAggregateInputType = {
    session_id?: true
    created_at?: true
    updated_at?: true
    authentication_method?: true
    id?: true
  }

  export type Mfa_amr_claimsMaxAggregateInputType = {
    session_id?: true
    created_at?: true
    updated_at?: true
    authentication_method?: true
    id?: true
  }

  export type Mfa_amr_claimsCountAggregateInputType = {
    session_id?: true
    created_at?: true
    updated_at?: true
    authentication_method?: true
    id?: true
    _all?: true
  }

  export type Mfa_amr_claimsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mfa_amr_claims to aggregate.
     */
    where?: mfa_amr_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_amr_claims to fetch.
     */
    orderBy?: mfa_amr_claimsOrderByWithRelationInput | mfa_amr_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mfa_amr_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_amr_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_amr_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mfa_amr_claims
    **/
    _count?: true | Mfa_amr_claimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mfa_amr_claimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mfa_amr_claimsMaxAggregateInputType
  }

  export type GetMfa_amr_claimsAggregateType<T extends Mfa_amr_claimsAggregateArgs> = {
        [P in keyof T & keyof AggregateMfa_amr_claims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMfa_amr_claims[P]>
      : GetScalarType<T[P], AggregateMfa_amr_claims[P]>
  }




  export type mfa_amr_claimsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mfa_amr_claimsWhereInput
    orderBy?: mfa_amr_claimsOrderByWithAggregationInput | mfa_amr_claimsOrderByWithAggregationInput[]
    by: Mfa_amr_claimsScalarFieldEnum[] | Mfa_amr_claimsScalarFieldEnum
    having?: mfa_amr_claimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mfa_amr_claimsCountAggregateInputType | true
    _min?: Mfa_amr_claimsMinAggregateInputType
    _max?: Mfa_amr_claimsMaxAggregateInputType
  }

  export type Mfa_amr_claimsGroupByOutputType = {
    session_id: string
    created_at: Date
    updated_at: Date
    authentication_method: string
    id: string
    _count: Mfa_amr_claimsCountAggregateOutputType | null
    _min: Mfa_amr_claimsMinAggregateOutputType | null
    _max: Mfa_amr_claimsMaxAggregateOutputType | null
  }

  type GetMfa_amr_claimsGroupByPayload<T extends mfa_amr_claimsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mfa_amr_claimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mfa_amr_claimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mfa_amr_claimsGroupByOutputType[P]>
            : GetScalarType<T[P], Mfa_amr_claimsGroupByOutputType[P]>
        }
      >
    >


  export type mfa_amr_claimsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    id?: boolean
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_amr_claims"]>

  export type mfa_amr_claimsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    id?: boolean
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_amr_claims"]>

  export type mfa_amr_claimsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    id?: boolean
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_amr_claims"]>

  export type mfa_amr_claimsSelectScalar = {
    session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    authentication_method?: boolean
    id?: boolean
  }

  export type mfa_amr_claimsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"session_id" | "created_at" | "updated_at" | "authentication_method" | "id", ExtArgs["result"]["mfa_amr_claims"]>
  export type mfa_amr_claimsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }
  export type mfa_amr_claimsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }
  export type mfa_amr_claimsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }

  export type $mfa_amr_claimsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mfa_amr_claims"
    objects: {
      sessions: Prisma.$sessionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      session_id: string
      created_at: Date
      updated_at: Date
      authentication_method: string
      id: string
    }, ExtArgs["result"]["mfa_amr_claims"]>
    composites: {}
  }

  type mfa_amr_claimsGetPayload<S extends boolean | null | undefined | mfa_amr_claimsDefaultArgs> = $Result.GetResult<Prisma.$mfa_amr_claimsPayload, S>

  type mfa_amr_claimsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mfa_amr_claimsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mfa_amr_claimsCountAggregateInputType | true
    }

  export interface mfa_amr_claimsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mfa_amr_claims'], meta: { name: 'mfa_amr_claims' } }
    /**
     * Find zero or one Mfa_amr_claims that matches the filter.
     * @param {mfa_amr_claimsFindUniqueArgs} args - Arguments to find a Mfa_amr_claims
     * @example
     * // Get one Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mfa_amr_claimsFindUniqueArgs>(args: SelectSubset<T, mfa_amr_claimsFindUniqueArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mfa_amr_claims that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mfa_amr_claimsFindUniqueOrThrowArgs} args - Arguments to find a Mfa_amr_claims
     * @example
     * // Get one Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mfa_amr_claimsFindUniqueOrThrowArgs>(args: SelectSubset<T, mfa_amr_claimsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mfa_amr_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_amr_claimsFindFirstArgs} args - Arguments to find a Mfa_amr_claims
     * @example
     * // Get one Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mfa_amr_claimsFindFirstArgs>(args?: SelectSubset<T, mfa_amr_claimsFindFirstArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mfa_amr_claims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_amr_claimsFindFirstOrThrowArgs} args - Arguments to find a Mfa_amr_claims
     * @example
     * // Get one Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mfa_amr_claimsFindFirstOrThrowArgs>(args?: SelectSubset<T, mfa_amr_claimsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mfa_amr_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_amr_claimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.findMany()
     * 
     * // Get first 10 Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.findMany({ take: 10 })
     * 
     * // Only select the `session_id`
     * const mfa_amr_claimsWithSession_idOnly = await prisma.mfa_amr_claims.findMany({ select: { session_id: true } })
     * 
     */
    findMany<T extends mfa_amr_claimsFindManyArgs>(args?: SelectSubset<T, mfa_amr_claimsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mfa_amr_claims.
     * @param {mfa_amr_claimsCreateArgs} args - Arguments to create a Mfa_amr_claims.
     * @example
     * // Create one Mfa_amr_claims
     * const Mfa_amr_claims = await prisma.mfa_amr_claims.create({
     *   data: {
     *     // ... data to create a Mfa_amr_claims
     *   }
     * })
     * 
     */
    create<T extends mfa_amr_claimsCreateArgs>(args: SelectSubset<T, mfa_amr_claimsCreateArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mfa_amr_claims.
     * @param {mfa_amr_claimsCreateManyArgs} args - Arguments to create many Mfa_amr_claims.
     * @example
     * // Create many Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mfa_amr_claimsCreateManyArgs>(args?: SelectSubset<T, mfa_amr_claimsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mfa_amr_claims and returns the data saved in the database.
     * @param {mfa_amr_claimsCreateManyAndReturnArgs} args - Arguments to create many Mfa_amr_claims.
     * @example
     * // Create many Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mfa_amr_claims and only return the `session_id`
     * const mfa_amr_claimsWithSession_idOnly = await prisma.mfa_amr_claims.createManyAndReturn({
     *   select: { session_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mfa_amr_claimsCreateManyAndReturnArgs>(args?: SelectSubset<T, mfa_amr_claimsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mfa_amr_claims.
     * @param {mfa_amr_claimsDeleteArgs} args - Arguments to delete one Mfa_amr_claims.
     * @example
     * // Delete one Mfa_amr_claims
     * const Mfa_amr_claims = await prisma.mfa_amr_claims.delete({
     *   where: {
     *     // ... filter to delete one Mfa_amr_claims
     *   }
     * })
     * 
     */
    delete<T extends mfa_amr_claimsDeleteArgs>(args: SelectSubset<T, mfa_amr_claimsDeleteArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mfa_amr_claims.
     * @param {mfa_amr_claimsUpdateArgs} args - Arguments to update one Mfa_amr_claims.
     * @example
     * // Update one Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mfa_amr_claimsUpdateArgs>(args: SelectSubset<T, mfa_amr_claimsUpdateArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mfa_amr_claims.
     * @param {mfa_amr_claimsDeleteManyArgs} args - Arguments to filter Mfa_amr_claims to delete.
     * @example
     * // Delete a few Mfa_amr_claims
     * const { count } = await prisma.mfa_amr_claims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mfa_amr_claimsDeleteManyArgs>(args?: SelectSubset<T, mfa_amr_claimsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mfa_amr_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_amr_claimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mfa_amr_claimsUpdateManyArgs>(args: SelectSubset<T, mfa_amr_claimsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mfa_amr_claims and returns the data updated in the database.
     * @param {mfa_amr_claimsUpdateManyAndReturnArgs} args - Arguments to update many Mfa_amr_claims.
     * @example
     * // Update many Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mfa_amr_claims and only return the `session_id`
     * const mfa_amr_claimsWithSession_idOnly = await prisma.mfa_amr_claims.updateManyAndReturn({
     *   select: { session_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mfa_amr_claimsUpdateManyAndReturnArgs>(args: SelectSubset<T, mfa_amr_claimsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mfa_amr_claims.
     * @param {mfa_amr_claimsUpsertArgs} args - Arguments to update or create a Mfa_amr_claims.
     * @example
     * // Update or create a Mfa_amr_claims
     * const mfa_amr_claims = await prisma.mfa_amr_claims.upsert({
     *   create: {
     *     // ... data to create a Mfa_amr_claims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mfa_amr_claims we want to update
     *   }
     * })
     */
    upsert<T extends mfa_amr_claimsUpsertArgs>(args: SelectSubset<T, mfa_amr_claimsUpsertArgs<ExtArgs>>): Prisma__mfa_amr_claimsClient<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mfa_amr_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_amr_claimsCountArgs} args - Arguments to filter Mfa_amr_claims to count.
     * @example
     * // Count the number of Mfa_amr_claims
     * const count = await prisma.mfa_amr_claims.count({
     *   where: {
     *     // ... the filter for the Mfa_amr_claims we want to count
     *   }
     * })
    **/
    count<T extends mfa_amr_claimsCountArgs>(
      args?: Subset<T, mfa_amr_claimsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mfa_amr_claimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mfa_amr_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mfa_amr_claimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mfa_amr_claimsAggregateArgs>(args: Subset<T, Mfa_amr_claimsAggregateArgs>): Prisma.PrismaPromise<GetMfa_amr_claimsAggregateType<T>>

    /**
     * Group by Mfa_amr_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_amr_claimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mfa_amr_claimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mfa_amr_claimsGroupByArgs['orderBy'] }
        : { orderBy?: mfa_amr_claimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mfa_amr_claimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMfa_amr_claimsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mfa_amr_claims model
   */
  readonly fields: mfa_amr_claimsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mfa_amr_claims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mfa_amr_claimsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sessionsDefaultArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mfa_amr_claims model
   */
  interface mfa_amr_claimsFieldRefs {
    readonly session_id: FieldRef<"mfa_amr_claims", 'String'>
    readonly created_at: FieldRef<"mfa_amr_claims", 'DateTime'>
    readonly updated_at: FieldRef<"mfa_amr_claims", 'DateTime'>
    readonly authentication_method: FieldRef<"mfa_amr_claims", 'String'>
    readonly id: FieldRef<"mfa_amr_claims", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mfa_amr_claims findUnique
   */
  export type mfa_amr_claimsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_amr_claims to fetch.
     */
    where: mfa_amr_claimsWhereUniqueInput
  }

  /**
   * mfa_amr_claims findUniqueOrThrow
   */
  export type mfa_amr_claimsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_amr_claims to fetch.
     */
    where: mfa_amr_claimsWhereUniqueInput
  }

  /**
   * mfa_amr_claims findFirst
   */
  export type mfa_amr_claimsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_amr_claims to fetch.
     */
    where?: mfa_amr_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_amr_claims to fetch.
     */
    orderBy?: mfa_amr_claimsOrderByWithRelationInput | mfa_amr_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mfa_amr_claims.
     */
    cursor?: mfa_amr_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_amr_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_amr_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mfa_amr_claims.
     */
    distinct?: Mfa_amr_claimsScalarFieldEnum | Mfa_amr_claimsScalarFieldEnum[]
  }

  /**
   * mfa_amr_claims findFirstOrThrow
   */
  export type mfa_amr_claimsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_amr_claims to fetch.
     */
    where?: mfa_amr_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_amr_claims to fetch.
     */
    orderBy?: mfa_amr_claimsOrderByWithRelationInput | mfa_amr_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mfa_amr_claims.
     */
    cursor?: mfa_amr_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_amr_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_amr_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mfa_amr_claims.
     */
    distinct?: Mfa_amr_claimsScalarFieldEnum | Mfa_amr_claimsScalarFieldEnum[]
  }

  /**
   * mfa_amr_claims findMany
   */
  export type mfa_amr_claimsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_amr_claims to fetch.
     */
    where?: mfa_amr_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_amr_claims to fetch.
     */
    orderBy?: mfa_amr_claimsOrderByWithRelationInput | mfa_amr_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mfa_amr_claims.
     */
    cursor?: mfa_amr_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_amr_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_amr_claims.
     */
    skip?: number
    distinct?: Mfa_amr_claimsScalarFieldEnum | Mfa_amr_claimsScalarFieldEnum[]
  }

  /**
   * mfa_amr_claims create
   */
  export type mfa_amr_claimsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * The data needed to create a mfa_amr_claims.
     */
    data: XOR<mfa_amr_claimsCreateInput, mfa_amr_claimsUncheckedCreateInput>
  }

  /**
   * mfa_amr_claims createMany
   */
  export type mfa_amr_claimsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mfa_amr_claims.
     */
    data: mfa_amr_claimsCreateManyInput | mfa_amr_claimsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mfa_amr_claims createManyAndReturn
   */
  export type mfa_amr_claimsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * The data used to create many mfa_amr_claims.
     */
    data: mfa_amr_claimsCreateManyInput | mfa_amr_claimsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mfa_amr_claims update
   */
  export type mfa_amr_claimsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * The data needed to update a mfa_amr_claims.
     */
    data: XOR<mfa_amr_claimsUpdateInput, mfa_amr_claimsUncheckedUpdateInput>
    /**
     * Choose, which mfa_amr_claims to update.
     */
    where: mfa_amr_claimsWhereUniqueInput
  }

  /**
   * mfa_amr_claims updateMany
   */
  export type mfa_amr_claimsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mfa_amr_claims.
     */
    data: XOR<mfa_amr_claimsUpdateManyMutationInput, mfa_amr_claimsUncheckedUpdateManyInput>
    /**
     * Filter which mfa_amr_claims to update
     */
    where?: mfa_amr_claimsWhereInput
    /**
     * Limit how many mfa_amr_claims to update.
     */
    limit?: number
  }

  /**
   * mfa_amr_claims updateManyAndReturn
   */
  export type mfa_amr_claimsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * The data used to update mfa_amr_claims.
     */
    data: XOR<mfa_amr_claimsUpdateManyMutationInput, mfa_amr_claimsUncheckedUpdateManyInput>
    /**
     * Filter which mfa_amr_claims to update
     */
    where?: mfa_amr_claimsWhereInput
    /**
     * Limit how many mfa_amr_claims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mfa_amr_claims upsert
   */
  export type mfa_amr_claimsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * The filter to search for the mfa_amr_claims to update in case it exists.
     */
    where: mfa_amr_claimsWhereUniqueInput
    /**
     * In case the mfa_amr_claims found by the `where` argument doesn't exist, create a new mfa_amr_claims with this data.
     */
    create: XOR<mfa_amr_claimsCreateInput, mfa_amr_claimsUncheckedCreateInput>
    /**
     * In case the mfa_amr_claims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mfa_amr_claimsUpdateInput, mfa_amr_claimsUncheckedUpdateInput>
  }

  /**
   * mfa_amr_claims delete
   */
  export type mfa_amr_claimsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    /**
     * Filter which mfa_amr_claims to delete.
     */
    where: mfa_amr_claimsWhereUniqueInput
  }

  /**
   * mfa_amr_claims deleteMany
   */
  export type mfa_amr_claimsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mfa_amr_claims to delete
     */
    where?: mfa_amr_claimsWhereInput
    /**
     * Limit how many mfa_amr_claims to delete.
     */
    limit?: number
  }

  /**
   * mfa_amr_claims without action
   */
  export type mfa_amr_claimsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
  }


  /**
   * Model mfa_challenges
   */

  export type AggregateMfa_challenges = {
    _count: Mfa_challengesCountAggregateOutputType | null
    _min: Mfa_challengesMinAggregateOutputType | null
    _max: Mfa_challengesMaxAggregateOutputType | null
  }

  export type Mfa_challengesMinAggregateOutputType = {
    id: string | null
    factor_id: string | null
    created_at: Date | null
    verified_at: Date | null
    ip_address: string | null
    otp_code: string | null
  }

  export type Mfa_challengesMaxAggregateOutputType = {
    id: string | null
    factor_id: string | null
    created_at: Date | null
    verified_at: Date | null
    ip_address: string | null
    otp_code: string | null
  }

  export type Mfa_challengesCountAggregateOutputType = {
    id: number
    factor_id: number
    created_at: number
    verified_at: number
    ip_address: number
    otp_code: number
    web_authn_session_data: number
    _all: number
  }


  export type Mfa_challengesMinAggregateInputType = {
    id?: true
    factor_id?: true
    created_at?: true
    verified_at?: true
    ip_address?: true
    otp_code?: true
  }

  export type Mfa_challengesMaxAggregateInputType = {
    id?: true
    factor_id?: true
    created_at?: true
    verified_at?: true
    ip_address?: true
    otp_code?: true
  }

  export type Mfa_challengesCountAggregateInputType = {
    id?: true
    factor_id?: true
    created_at?: true
    verified_at?: true
    ip_address?: true
    otp_code?: true
    web_authn_session_data?: true
    _all?: true
  }

  export type Mfa_challengesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mfa_challenges to aggregate.
     */
    where?: mfa_challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_challenges to fetch.
     */
    orderBy?: mfa_challengesOrderByWithRelationInput | mfa_challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mfa_challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mfa_challenges
    **/
    _count?: true | Mfa_challengesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mfa_challengesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mfa_challengesMaxAggregateInputType
  }

  export type GetMfa_challengesAggregateType<T extends Mfa_challengesAggregateArgs> = {
        [P in keyof T & keyof AggregateMfa_challenges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMfa_challenges[P]>
      : GetScalarType<T[P], AggregateMfa_challenges[P]>
  }




  export type mfa_challengesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mfa_challengesWhereInput
    orderBy?: mfa_challengesOrderByWithAggregationInput | mfa_challengesOrderByWithAggregationInput[]
    by: Mfa_challengesScalarFieldEnum[] | Mfa_challengesScalarFieldEnum
    having?: mfa_challengesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mfa_challengesCountAggregateInputType | true
    _min?: Mfa_challengesMinAggregateInputType
    _max?: Mfa_challengesMaxAggregateInputType
  }

  export type Mfa_challengesGroupByOutputType = {
    id: string
    factor_id: string
    created_at: Date
    verified_at: Date | null
    ip_address: string
    otp_code: string | null
    web_authn_session_data: JsonValue | null
    _count: Mfa_challengesCountAggregateOutputType | null
    _min: Mfa_challengesMinAggregateOutputType | null
    _max: Mfa_challengesMaxAggregateOutputType | null
  }

  type GetMfa_challengesGroupByPayload<T extends mfa_challengesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mfa_challengesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mfa_challengesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mfa_challengesGroupByOutputType[P]>
            : GetScalarType<T[P], Mfa_challengesGroupByOutputType[P]>
        }
      >
    >


  export type mfa_challengesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factor_id?: boolean
    created_at?: boolean
    verified_at?: boolean
    ip_address?: boolean
    otp_code?: boolean
    web_authn_session_data?: boolean
    mfa_factors?: boolean | mfa_factorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_challenges"]>

  export type mfa_challengesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factor_id?: boolean
    created_at?: boolean
    verified_at?: boolean
    ip_address?: boolean
    otp_code?: boolean
    web_authn_session_data?: boolean
    mfa_factors?: boolean | mfa_factorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_challenges"]>

  export type mfa_challengesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factor_id?: boolean
    created_at?: boolean
    verified_at?: boolean
    ip_address?: boolean
    otp_code?: boolean
    web_authn_session_data?: boolean
    mfa_factors?: boolean | mfa_factorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_challenges"]>

  export type mfa_challengesSelectScalar = {
    id?: boolean
    factor_id?: boolean
    created_at?: boolean
    verified_at?: boolean
    ip_address?: boolean
    otp_code?: boolean
    web_authn_session_data?: boolean
  }

  export type mfa_challengesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "factor_id" | "created_at" | "verified_at" | "ip_address" | "otp_code" | "web_authn_session_data", ExtArgs["result"]["mfa_challenges"]>
  export type mfa_challengesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa_factors?: boolean | mfa_factorsDefaultArgs<ExtArgs>
  }
  export type mfa_challengesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa_factors?: boolean | mfa_factorsDefaultArgs<ExtArgs>
  }
  export type mfa_challengesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa_factors?: boolean | mfa_factorsDefaultArgs<ExtArgs>
  }

  export type $mfa_challengesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mfa_challenges"
    objects: {
      mfa_factors: Prisma.$mfa_factorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      factor_id: string
      created_at: Date
      verified_at: Date | null
      ip_address: string
      otp_code: string | null
      web_authn_session_data: Prisma.JsonValue | null
    }, ExtArgs["result"]["mfa_challenges"]>
    composites: {}
  }

  type mfa_challengesGetPayload<S extends boolean | null | undefined | mfa_challengesDefaultArgs> = $Result.GetResult<Prisma.$mfa_challengesPayload, S>

  type mfa_challengesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mfa_challengesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mfa_challengesCountAggregateInputType | true
    }

  export interface mfa_challengesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mfa_challenges'], meta: { name: 'mfa_challenges' } }
    /**
     * Find zero or one Mfa_challenges that matches the filter.
     * @param {mfa_challengesFindUniqueArgs} args - Arguments to find a Mfa_challenges
     * @example
     * // Get one Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mfa_challengesFindUniqueArgs>(args: SelectSubset<T, mfa_challengesFindUniqueArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mfa_challenges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mfa_challengesFindUniqueOrThrowArgs} args - Arguments to find a Mfa_challenges
     * @example
     * // Get one Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mfa_challengesFindUniqueOrThrowArgs>(args: SelectSubset<T, mfa_challengesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mfa_challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_challengesFindFirstArgs} args - Arguments to find a Mfa_challenges
     * @example
     * // Get one Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mfa_challengesFindFirstArgs>(args?: SelectSubset<T, mfa_challengesFindFirstArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mfa_challenges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_challengesFindFirstOrThrowArgs} args - Arguments to find a Mfa_challenges
     * @example
     * // Get one Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mfa_challengesFindFirstOrThrowArgs>(args?: SelectSubset<T, mfa_challengesFindFirstOrThrowArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mfa_challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_challengesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.findMany()
     * 
     * // Get first 10 Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mfa_challengesWithIdOnly = await prisma.mfa_challenges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mfa_challengesFindManyArgs>(args?: SelectSubset<T, mfa_challengesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mfa_challenges.
     * @param {mfa_challengesCreateArgs} args - Arguments to create a Mfa_challenges.
     * @example
     * // Create one Mfa_challenges
     * const Mfa_challenges = await prisma.mfa_challenges.create({
     *   data: {
     *     // ... data to create a Mfa_challenges
     *   }
     * })
     * 
     */
    create<T extends mfa_challengesCreateArgs>(args: SelectSubset<T, mfa_challengesCreateArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mfa_challenges.
     * @param {mfa_challengesCreateManyArgs} args - Arguments to create many Mfa_challenges.
     * @example
     * // Create many Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mfa_challengesCreateManyArgs>(args?: SelectSubset<T, mfa_challengesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mfa_challenges and returns the data saved in the database.
     * @param {mfa_challengesCreateManyAndReturnArgs} args - Arguments to create many Mfa_challenges.
     * @example
     * // Create many Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mfa_challenges and only return the `id`
     * const mfa_challengesWithIdOnly = await prisma.mfa_challenges.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mfa_challengesCreateManyAndReturnArgs>(args?: SelectSubset<T, mfa_challengesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mfa_challenges.
     * @param {mfa_challengesDeleteArgs} args - Arguments to delete one Mfa_challenges.
     * @example
     * // Delete one Mfa_challenges
     * const Mfa_challenges = await prisma.mfa_challenges.delete({
     *   where: {
     *     // ... filter to delete one Mfa_challenges
     *   }
     * })
     * 
     */
    delete<T extends mfa_challengesDeleteArgs>(args: SelectSubset<T, mfa_challengesDeleteArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mfa_challenges.
     * @param {mfa_challengesUpdateArgs} args - Arguments to update one Mfa_challenges.
     * @example
     * // Update one Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mfa_challengesUpdateArgs>(args: SelectSubset<T, mfa_challengesUpdateArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mfa_challenges.
     * @param {mfa_challengesDeleteManyArgs} args - Arguments to filter Mfa_challenges to delete.
     * @example
     * // Delete a few Mfa_challenges
     * const { count } = await prisma.mfa_challenges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mfa_challengesDeleteManyArgs>(args?: SelectSubset<T, mfa_challengesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mfa_challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_challengesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mfa_challengesUpdateManyArgs>(args: SelectSubset<T, mfa_challengesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mfa_challenges and returns the data updated in the database.
     * @param {mfa_challengesUpdateManyAndReturnArgs} args - Arguments to update many Mfa_challenges.
     * @example
     * // Update many Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mfa_challenges and only return the `id`
     * const mfa_challengesWithIdOnly = await prisma.mfa_challenges.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mfa_challengesUpdateManyAndReturnArgs>(args: SelectSubset<T, mfa_challengesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mfa_challenges.
     * @param {mfa_challengesUpsertArgs} args - Arguments to update or create a Mfa_challenges.
     * @example
     * // Update or create a Mfa_challenges
     * const mfa_challenges = await prisma.mfa_challenges.upsert({
     *   create: {
     *     // ... data to create a Mfa_challenges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mfa_challenges we want to update
     *   }
     * })
     */
    upsert<T extends mfa_challengesUpsertArgs>(args: SelectSubset<T, mfa_challengesUpsertArgs<ExtArgs>>): Prisma__mfa_challengesClient<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mfa_challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_challengesCountArgs} args - Arguments to filter Mfa_challenges to count.
     * @example
     * // Count the number of Mfa_challenges
     * const count = await prisma.mfa_challenges.count({
     *   where: {
     *     // ... the filter for the Mfa_challenges we want to count
     *   }
     * })
    **/
    count<T extends mfa_challengesCountArgs>(
      args?: Subset<T, mfa_challengesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mfa_challengesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mfa_challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mfa_challengesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mfa_challengesAggregateArgs>(args: Subset<T, Mfa_challengesAggregateArgs>): Prisma.PrismaPromise<GetMfa_challengesAggregateType<T>>

    /**
     * Group by Mfa_challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_challengesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mfa_challengesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mfa_challengesGroupByArgs['orderBy'] }
        : { orderBy?: mfa_challengesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mfa_challengesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMfa_challengesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mfa_challenges model
   */
  readonly fields: mfa_challengesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mfa_challenges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mfa_challengesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mfa_factors<T extends mfa_factorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mfa_factorsDefaultArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mfa_challenges model
   */
  interface mfa_challengesFieldRefs {
    readonly id: FieldRef<"mfa_challenges", 'String'>
    readonly factor_id: FieldRef<"mfa_challenges", 'String'>
    readonly created_at: FieldRef<"mfa_challenges", 'DateTime'>
    readonly verified_at: FieldRef<"mfa_challenges", 'DateTime'>
    readonly ip_address: FieldRef<"mfa_challenges", 'String'>
    readonly otp_code: FieldRef<"mfa_challenges", 'String'>
    readonly web_authn_session_data: FieldRef<"mfa_challenges", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * mfa_challenges findUnique
   */
  export type mfa_challengesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * Filter, which mfa_challenges to fetch.
     */
    where: mfa_challengesWhereUniqueInput
  }

  /**
   * mfa_challenges findUniqueOrThrow
   */
  export type mfa_challengesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * Filter, which mfa_challenges to fetch.
     */
    where: mfa_challengesWhereUniqueInput
  }

  /**
   * mfa_challenges findFirst
   */
  export type mfa_challengesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * Filter, which mfa_challenges to fetch.
     */
    where?: mfa_challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_challenges to fetch.
     */
    orderBy?: mfa_challengesOrderByWithRelationInput | mfa_challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mfa_challenges.
     */
    cursor?: mfa_challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mfa_challenges.
     */
    distinct?: Mfa_challengesScalarFieldEnum | Mfa_challengesScalarFieldEnum[]
  }

  /**
   * mfa_challenges findFirstOrThrow
   */
  export type mfa_challengesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * Filter, which mfa_challenges to fetch.
     */
    where?: mfa_challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_challenges to fetch.
     */
    orderBy?: mfa_challengesOrderByWithRelationInput | mfa_challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mfa_challenges.
     */
    cursor?: mfa_challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mfa_challenges.
     */
    distinct?: Mfa_challengesScalarFieldEnum | Mfa_challengesScalarFieldEnum[]
  }

  /**
   * mfa_challenges findMany
   */
  export type mfa_challengesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * Filter, which mfa_challenges to fetch.
     */
    where?: mfa_challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_challenges to fetch.
     */
    orderBy?: mfa_challengesOrderByWithRelationInput | mfa_challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mfa_challenges.
     */
    cursor?: mfa_challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_challenges.
     */
    skip?: number
    distinct?: Mfa_challengesScalarFieldEnum | Mfa_challengesScalarFieldEnum[]
  }

  /**
   * mfa_challenges create
   */
  export type mfa_challengesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * The data needed to create a mfa_challenges.
     */
    data: XOR<mfa_challengesCreateInput, mfa_challengesUncheckedCreateInput>
  }

  /**
   * mfa_challenges createMany
   */
  export type mfa_challengesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mfa_challenges.
     */
    data: mfa_challengesCreateManyInput | mfa_challengesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mfa_challenges createManyAndReturn
   */
  export type mfa_challengesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * The data used to create many mfa_challenges.
     */
    data: mfa_challengesCreateManyInput | mfa_challengesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mfa_challenges update
   */
  export type mfa_challengesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * The data needed to update a mfa_challenges.
     */
    data: XOR<mfa_challengesUpdateInput, mfa_challengesUncheckedUpdateInput>
    /**
     * Choose, which mfa_challenges to update.
     */
    where: mfa_challengesWhereUniqueInput
  }

  /**
   * mfa_challenges updateMany
   */
  export type mfa_challengesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mfa_challenges.
     */
    data: XOR<mfa_challengesUpdateManyMutationInput, mfa_challengesUncheckedUpdateManyInput>
    /**
     * Filter which mfa_challenges to update
     */
    where?: mfa_challengesWhereInput
    /**
     * Limit how many mfa_challenges to update.
     */
    limit?: number
  }

  /**
   * mfa_challenges updateManyAndReturn
   */
  export type mfa_challengesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * The data used to update mfa_challenges.
     */
    data: XOR<mfa_challengesUpdateManyMutationInput, mfa_challengesUncheckedUpdateManyInput>
    /**
     * Filter which mfa_challenges to update
     */
    where?: mfa_challengesWhereInput
    /**
     * Limit how many mfa_challenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mfa_challenges upsert
   */
  export type mfa_challengesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * The filter to search for the mfa_challenges to update in case it exists.
     */
    where: mfa_challengesWhereUniqueInput
    /**
     * In case the mfa_challenges found by the `where` argument doesn't exist, create a new mfa_challenges with this data.
     */
    create: XOR<mfa_challengesCreateInput, mfa_challengesUncheckedCreateInput>
    /**
     * In case the mfa_challenges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mfa_challengesUpdateInput, mfa_challengesUncheckedUpdateInput>
  }

  /**
   * mfa_challenges delete
   */
  export type mfa_challengesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    /**
     * Filter which mfa_challenges to delete.
     */
    where: mfa_challengesWhereUniqueInput
  }

  /**
   * mfa_challenges deleteMany
   */
  export type mfa_challengesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mfa_challenges to delete
     */
    where?: mfa_challengesWhereInput
    /**
     * Limit how many mfa_challenges to delete.
     */
    limit?: number
  }

  /**
   * mfa_challenges without action
   */
  export type mfa_challengesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
  }


  /**
   * Model mfa_factors
   */

  export type AggregateMfa_factors = {
    _count: Mfa_factorsCountAggregateOutputType | null
    _min: Mfa_factorsMinAggregateOutputType | null
    _max: Mfa_factorsMaxAggregateOutputType | null
  }

  export type Mfa_factorsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    friendly_name: string | null
    factor_type: $Enums.factor_type | null
    status: $Enums.factor_status | null
    created_at: Date | null
    updated_at: Date | null
    secret: string | null
    phone: string | null
    last_challenged_at: Date | null
    web_authn_aaguid: string | null
  }

  export type Mfa_factorsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    friendly_name: string | null
    factor_type: $Enums.factor_type | null
    status: $Enums.factor_status | null
    created_at: Date | null
    updated_at: Date | null
    secret: string | null
    phone: string | null
    last_challenged_at: Date | null
    web_authn_aaguid: string | null
  }

  export type Mfa_factorsCountAggregateOutputType = {
    id: number
    user_id: number
    friendly_name: number
    factor_type: number
    status: number
    created_at: number
    updated_at: number
    secret: number
    phone: number
    last_challenged_at: number
    web_authn_credential: number
    web_authn_aaguid: number
    _all: number
  }


  export type Mfa_factorsMinAggregateInputType = {
    id?: true
    user_id?: true
    friendly_name?: true
    factor_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    secret?: true
    phone?: true
    last_challenged_at?: true
    web_authn_aaguid?: true
  }

  export type Mfa_factorsMaxAggregateInputType = {
    id?: true
    user_id?: true
    friendly_name?: true
    factor_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    secret?: true
    phone?: true
    last_challenged_at?: true
    web_authn_aaguid?: true
  }

  export type Mfa_factorsCountAggregateInputType = {
    id?: true
    user_id?: true
    friendly_name?: true
    factor_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    secret?: true
    phone?: true
    last_challenged_at?: true
    web_authn_credential?: true
    web_authn_aaguid?: true
    _all?: true
  }

  export type Mfa_factorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mfa_factors to aggregate.
     */
    where?: mfa_factorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_factors to fetch.
     */
    orderBy?: mfa_factorsOrderByWithRelationInput | mfa_factorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mfa_factorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_factors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mfa_factors
    **/
    _count?: true | Mfa_factorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mfa_factorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mfa_factorsMaxAggregateInputType
  }

  export type GetMfa_factorsAggregateType<T extends Mfa_factorsAggregateArgs> = {
        [P in keyof T & keyof AggregateMfa_factors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMfa_factors[P]>
      : GetScalarType<T[P], AggregateMfa_factors[P]>
  }




  export type mfa_factorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mfa_factorsWhereInput
    orderBy?: mfa_factorsOrderByWithAggregationInput | mfa_factorsOrderByWithAggregationInput[]
    by: Mfa_factorsScalarFieldEnum[] | Mfa_factorsScalarFieldEnum
    having?: mfa_factorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mfa_factorsCountAggregateInputType | true
    _min?: Mfa_factorsMinAggregateInputType
    _max?: Mfa_factorsMaxAggregateInputType
  }

  export type Mfa_factorsGroupByOutputType = {
    id: string
    user_id: string
    friendly_name: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date
    updated_at: Date
    secret: string | null
    phone: string | null
    last_challenged_at: Date | null
    web_authn_credential: JsonValue | null
    web_authn_aaguid: string | null
    _count: Mfa_factorsCountAggregateOutputType | null
    _min: Mfa_factorsMinAggregateOutputType | null
    _max: Mfa_factorsMaxAggregateOutputType | null
  }

  type GetMfa_factorsGroupByPayload<T extends mfa_factorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mfa_factorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mfa_factorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mfa_factorsGroupByOutputType[P]>
            : GetScalarType<T[P], Mfa_factorsGroupByOutputType[P]>
        }
      >
    >


  export type mfa_factorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    friendly_name?: boolean
    factor_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    secret?: boolean
    phone?: boolean
    last_challenged_at?: boolean
    web_authn_credential?: boolean
    web_authn_aaguid?: boolean
    mfa_challenges?: boolean | mfa_factors$mfa_challengesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Mfa_factorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_factors"]>

  export type mfa_factorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    friendly_name?: boolean
    factor_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    secret?: boolean
    phone?: boolean
    last_challenged_at?: boolean
    web_authn_credential?: boolean
    web_authn_aaguid?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_factors"]>

  export type mfa_factorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    friendly_name?: boolean
    factor_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    secret?: boolean
    phone?: boolean
    last_challenged_at?: boolean
    web_authn_credential?: boolean
    web_authn_aaguid?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfa_factors"]>

  export type mfa_factorsSelectScalar = {
    id?: boolean
    user_id?: boolean
    friendly_name?: boolean
    factor_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    secret?: boolean
    phone?: boolean
    last_challenged_at?: boolean
    web_authn_credential?: boolean
    web_authn_aaguid?: boolean
  }

  export type mfa_factorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "friendly_name" | "factor_type" | "status" | "created_at" | "updated_at" | "secret" | "phone" | "last_challenged_at" | "web_authn_credential" | "web_authn_aaguid", ExtArgs["result"]["mfa_factors"]>
  export type mfa_factorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa_challenges?: boolean | mfa_factors$mfa_challengesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Mfa_factorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mfa_factorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type mfa_factorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $mfa_factorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mfa_factors"
    objects: {
      mfa_challenges: Prisma.$mfa_challengesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      friendly_name: string | null
      factor_type: $Enums.factor_type
      status: $Enums.factor_status
      created_at: Date
      updated_at: Date
      secret: string | null
      phone: string | null
      last_challenged_at: Date | null
      web_authn_credential: Prisma.JsonValue | null
      web_authn_aaguid: string | null
    }, ExtArgs["result"]["mfa_factors"]>
    composites: {}
  }

  type mfa_factorsGetPayload<S extends boolean | null | undefined | mfa_factorsDefaultArgs> = $Result.GetResult<Prisma.$mfa_factorsPayload, S>

  type mfa_factorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mfa_factorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mfa_factorsCountAggregateInputType | true
    }

  export interface mfa_factorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mfa_factors'], meta: { name: 'mfa_factors' } }
    /**
     * Find zero or one Mfa_factors that matches the filter.
     * @param {mfa_factorsFindUniqueArgs} args - Arguments to find a Mfa_factors
     * @example
     * // Get one Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mfa_factorsFindUniqueArgs>(args: SelectSubset<T, mfa_factorsFindUniqueArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mfa_factors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mfa_factorsFindUniqueOrThrowArgs} args - Arguments to find a Mfa_factors
     * @example
     * // Get one Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mfa_factorsFindUniqueOrThrowArgs>(args: SelectSubset<T, mfa_factorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mfa_factors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_factorsFindFirstArgs} args - Arguments to find a Mfa_factors
     * @example
     * // Get one Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mfa_factorsFindFirstArgs>(args?: SelectSubset<T, mfa_factorsFindFirstArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mfa_factors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_factorsFindFirstOrThrowArgs} args - Arguments to find a Mfa_factors
     * @example
     * // Get one Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mfa_factorsFindFirstOrThrowArgs>(args?: SelectSubset<T, mfa_factorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mfa_factors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_factorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.findMany()
     * 
     * // Get first 10 Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mfa_factorsWithIdOnly = await prisma.mfa_factors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mfa_factorsFindManyArgs>(args?: SelectSubset<T, mfa_factorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mfa_factors.
     * @param {mfa_factorsCreateArgs} args - Arguments to create a Mfa_factors.
     * @example
     * // Create one Mfa_factors
     * const Mfa_factors = await prisma.mfa_factors.create({
     *   data: {
     *     // ... data to create a Mfa_factors
     *   }
     * })
     * 
     */
    create<T extends mfa_factorsCreateArgs>(args: SelectSubset<T, mfa_factorsCreateArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mfa_factors.
     * @param {mfa_factorsCreateManyArgs} args - Arguments to create many Mfa_factors.
     * @example
     * // Create many Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mfa_factorsCreateManyArgs>(args?: SelectSubset<T, mfa_factorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mfa_factors and returns the data saved in the database.
     * @param {mfa_factorsCreateManyAndReturnArgs} args - Arguments to create many Mfa_factors.
     * @example
     * // Create many Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mfa_factors and only return the `id`
     * const mfa_factorsWithIdOnly = await prisma.mfa_factors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mfa_factorsCreateManyAndReturnArgs>(args?: SelectSubset<T, mfa_factorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mfa_factors.
     * @param {mfa_factorsDeleteArgs} args - Arguments to delete one Mfa_factors.
     * @example
     * // Delete one Mfa_factors
     * const Mfa_factors = await prisma.mfa_factors.delete({
     *   where: {
     *     // ... filter to delete one Mfa_factors
     *   }
     * })
     * 
     */
    delete<T extends mfa_factorsDeleteArgs>(args: SelectSubset<T, mfa_factorsDeleteArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mfa_factors.
     * @param {mfa_factorsUpdateArgs} args - Arguments to update one Mfa_factors.
     * @example
     * // Update one Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mfa_factorsUpdateArgs>(args: SelectSubset<T, mfa_factorsUpdateArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mfa_factors.
     * @param {mfa_factorsDeleteManyArgs} args - Arguments to filter Mfa_factors to delete.
     * @example
     * // Delete a few Mfa_factors
     * const { count } = await prisma.mfa_factors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mfa_factorsDeleteManyArgs>(args?: SelectSubset<T, mfa_factorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mfa_factors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_factorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mfa_factorsUpdateManyArgs>(args: SelectSubset<T, mfa_factorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mfa_factors and returns the data updated in the database.
     * @param {mfa_factorsUpdateManyAndReturnArgs} args - Arguments to update many Mfa_factors.
     * @example
     * // Update many Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mfa_factors and only return the `id`
     * const mfa_factorsWithIdOnly = await prisma.mfa_factors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mfa_factorsUpdateManyAndReturnArgs>(args: SelectSubset<T, mfa_factorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mfa_factors.
     * @param {mfa_factorsUpsertArgs} args - Arguments to update or create a Mfa_factors.
     * @example
     * // Update or create a Mfa_factors
     * const mfa_factors = await prisma.mfa_factors.upsert({
     *   create: {
     *     // ... data to create a Mfa_factors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mfa_factors we want to update
     *   }
     * })
     */
    upsert<T extends mfa_factorsUpsertArgs>(args: SelectSubset<T, mfa_factorsUpsertArgs<ExtArgs>>): Prisma__mfa_factorsClient<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mfa_factors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_factorsCountArgs} args - Arguments to filter Mfa_factors to count.
     * @example
     * // Count the number of Mfa_factors
     * const count = await prisma.mfa_factors.count({
     *   where: {
     *     // ... the filter for the Mfa_factors we want to count
     *   }
     * })
    **/
    count<T extends mfa_factorsCountArgs>(
      args?: Subset<T, mfa_factorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mfa_factorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mfa_factors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mfa_factorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mfa_factorsAggregateArgs>(args: Subset<T, Mfa_factorsAggregateArgs>): Prisma.PrismaPromise<GetMfa_factorsAggregateType<T>>

    /**
     * Group by Mfa_factors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mfa_factorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mfa_factorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mfa_factorsGroupByArgs['orderBy'] }
        : { orderBy?: mfa_factorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mfa_factorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMfa_factorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mfa_factors model
   */
  readonly fields: mfa_factorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mfa_factors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mfa_factorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mfa_challenges<T extends mfa_factors$mfa_challengesArgs<ExtArgs> = {}>(args?: Subset<T, mfa_factors$mfa_challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_challengesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mfa_factors model
   */
  interface mfa_factorsFieldRefs {
    readonly id: FieldRef<"mfa_factors", 'String'>
    readonly user_id: FieldRef<"mfa_factors", 'String'>
    readonly friendly_name: FieldRef<"mfa_factors", 'String'>
    readonly factor_type: FieldRef<"mfa_factors", 'factor_type'>
    readonly status: FieldRef<"mfa_factors", 'factor_status'>
    readonly created_at: FieldRef<"mfa_factors", 'DateTime'>
    readonly updated_at: FieldRef<"mfa_factors", 'DateTime'>
    readonly secret: FieldRef<"mfa_factors", 'String'>
    readonly phone: FieldRef<"mfa_factors", 'String'>
    readonly last_challenged_at: FieldRef<"mfa_factors", 'DateTime'>
    readonly web_authn_credential: FieldRef<"mfa_factors", 'Json'>
    readonly web_authn_aaguid: FieldRef<"mfa_factors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mfa_factors findUnique
   */
  export type mfa_factorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_factors to fetch.
     */
    where: mfa_factorsWhereUniqueInput
  }

  /**
   * mfa_factors findUniqueOrThrow
   */
  export type mfa_factorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_factors to fetch.
     */
    where: mfa_factorsWhereUniqueInput
  }

  /**
   * mfa_factors findFirst
   */
  export type mfa_factorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_factors to fetch.
     */
    where?: mfa_factorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_factors to fetch.
     */
    orderBy?: mfa_factorsOrderByWithRelationInput | mfa_factorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mfa_factors.
     */
    cursor?: mfa_factorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_factors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mfa_factors.
     */
    distinct?: Mfa_factorsScalarFieldEnum | Mfa_factorsScalarFieldEnum[]
  }

  /**
   * mfa_factors findFirstOrThrow
   */
  export type mfa_factorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_factors to fetch.
     */
    where?: mfa_factorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_factors to fetch.
     */
    orderBy?: mfa_factorsOrderByWithRelationInput | mfa_factorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mfa_factors.
     */
    cursor?: mfa_factorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_factors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mfa_factors.
     */
    distinct?: Mfa_factorsScalarFieldEnum | Mfa_factorsScalarFieldEnum[]
  }

  /**
   * mfa_factors findMany
   */
  export type mfa_factorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * Filter, which mfa_factors to fetch.
     */
    where?: mfa_factorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mfa_factors to fetch.
     */
    orderBy?: mfa_factorsOrderByWithRelationInput | mfa_factorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mfa_factors.
     */
    cursor?: mfa_factorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mfa_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mfa_factors.
     */
    skip?: number
    distinct?: Mfa_factorsScalarFieldEnum | Mfa_factorsScalarFieldEnum[]
  }

  /**
   * mfa_factors create
   */
  export type mfa_factorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * The data needed to create a mfa_factors.
     */
    data: XOR<mfa_factorsCreateInput, mfa_factorsUncheckedCreateInput>
  }

  /**
   * mfa_factors createMany
   */
  export type mfa_factorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mfa_factors.
     */
    data: mfa_factorsCreateManyInput | mfa_factorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mfa_factors createManyAndReturn
   */
  export type mfa_factorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * The data used to create many mfa_factors.
     */
    data: mfa_factorsCreateManyInput | mfa_factorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mfa_factors update
   */
  export type mfa_factorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * The data needed to update a mfa_factors.
     */
    data: XOR<mfa_factorsUpdateInput, mfa_factorsUncheckedUpdateInput>
    /**
     * Choose, which mfa_factors to update.
     */
    where: mfa_factorsWhereUniqueInput
  }

  /**
   * mfa_factors updateMany
   */
  export type mfa_factorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mfa_factors.
     */
    data: XOR<mfa_factorsUpdateManyMutationInput, mfa_factorsUncheckedUpdateManyInput>
    /**
     * Filter which mfa_factors to update
     */
    where?: mfa_factorsWhereInput
    /**
     * Limit how many mfa_factors to update.
     */
    limit?: number
  }

  /**
   * mfa_factors updateManyAndReturn
   */
  export type mfa_factorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * The data used to update mfa_factors.
     */
    data: XOR<mfa_factorsUpdateManyMutationInput, mfa_factorsUncheckedUpdateManyInput>
    /**
     * Filter which mfa_factors to update
     */
    where?: mfa_factorsWhereInput
    /**
     * Limit how many mfa_factors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mfa_factors upsert
   */
  export type mfa_factorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * The filter to search for the mfa_factors to update in case it exists.
     */
    where: mfa_factorsWhereUniqueInput
    /**
     * In case the mfa_factors found by the `where` argument doesn't exist, create a new mfa_factors with this data.
     */
    create: XOR<mfa_factorsCreateInput, mfa_factorsUncheckedCreateInput>
    /**
     * In case the mfa_factors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mfa_factorsUpdateInput, mfa_factorsUncheckedUpdateInput>
  }

  /**
   * mfa_factors delete
   */
  export type mfa_factorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    /**
     * Filter which mfa_factors to delete.
     */
    where: mfa_factorsWhereUniqueInput
  }

  /**
   * mfa_factors deleteMany
   */
  export type mfa_factorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mfa_factors to delete
     */
    where?: mfa_factorsWhereInput
    /**
     * Limit how many mfa_factors to delete.
     */
    limit?: number
  }

  /**
   * mfa_factors.mfa_challenges
   */
  export type mfa_factors$mfa_challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_challenges
     */
    select?: mfa_challengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_challenges
     */
    omit?: mfa_challengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_challengesInclude<ExtArgs> | null
    where?: mfa_challengesWhereInput
    orderBy?: mfa_challengesOrderByWithRelationInput | mfa_challengesOrderByWithRelationInput[]
    cursor?: mfa_challengesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mfa_challengesScalarFieldEnum | Mfa_challengesScalarFieldEnum[]
  }

  /**
   * mfa_factors without action
   */
  export type mfa_factorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
  }


  /**
   * Model one_time_tokens
   */

  export type AggregateOne_time_tokens = {
    _count: One_time_tokensCountAggregateOutputType | null
    _min: One_time_tokensMinAggregateOutputType | null
    _max: One_time_tokensMaxAggregateOutputType | null
  }

  export type One_time_tokensMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    token_type: $Enums.one_time_token_type | null
    token_hash: string | null
    relates_to: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type One_time_tokensMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    token_type: $Enums.one_time_token_type | null
    token_hash: string | null
    relates_to: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type One_time_tokensCountAggregateOutputType = {
    id: number
    user_id: number
    token_type: number
    token_hash: number
    relates_to: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type One_time_tokensMinAggregateInputType = {
    id?: true
    user_id?: true
    token_type?: true
    token_hash?: true
    relates_to?: true
    created_at?: true
    updated_at?: true
  }

  export type One_time_tokensMaxAggregateInputType = {
    id?: true
    user_id?: true
    token_type?: true
    token_hash?: true
    relates_to?: true
    created_at?: true
    updated_at?: true
  }

  export type One_time_tokensCountAggregateInputType = {
    id?: true
    user_id?: true
    token_type?: true
    token_hash?: true
    relates_to?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type One_time_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which one_time_tokens to aggregate.
     */
    where?: one_time_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of one_time_tokens to fetch.
     */
    orderBy?: one_time_tokensOrderByWithRelationInput | one_time_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: one_time_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` one_time_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` one_time_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned one_time_tokens
    **/
    _count?: true | One_time_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: One_time_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: One_time_tokensMaxAggregateInputType
  }

  export type GetOne_time_tokensAggregateType<T extends One_time_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateOne_time_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOne_time_tokens[P]>
      : GetScalarType<T[P], AggregateOne_time_tokens[P]>
  }




  export type one_time_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: one_time_tokensWhereInput
    orderBy?: one_time_tokensOrderByWithAggregationInput | one_time_tokensOrderByWithAggregationInput[]
    by: One_time_tokensScalarFieldEnum[] | One_time_tokensScalarFieldEnum
    having?: one_time_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: One_time_tokensCountAggregateInputType | true
    _min?: One_time_tokensMinAggregateInputType
    _max?: One_time_tokensMaxAggregateInputType
  }

  export type One_time_tokensGroupByOutputType = {
    id: string
    user_id: string
    token_type: $Enums.one_time_token_type
    token_hash: string
    relates_to: string
    created_at: Date
    updated_at: Date
    _count: One_time_tokensCountAggregateOutputType | null
    _min: One_time_tokensMinAggregateOutputType | null
    _max: One_time_tokensMaxAggregateOutputType | null
  }

  type GetOne_time_tokensGroupByPayload<T extends one_time_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<One_time_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof One_time_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], One_time_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], One_time_tokensGroupByOutputType[P]>
        }
      >
    >


  export type one_time_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_type?: boolean
    token_hash?: boolean
    relates_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["one_time_tokens"]>

  export type one_time_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_type?: boolean
    token_hash?: boolean
    relates_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["one_time_tokens"]>

  export type one_time_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_type?: boolean
    token_hash?: boolean
    relates_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["one_time_tokens"]>

  export type one_time_tokensSelectScalar = {
    id?: boolean
    user_id?: boolean
    token_type?: boolean
    token_hash?: boolean
    relates_to?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type one_time_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token_type" | "token_hash" | "relates_to" | "created_at" | "updated_at", ExtArgs["result"]["one_time_tokens"]>
  export type one_time_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type one_time_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type one_time_tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $one_time_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "one_time_tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      token_type: $Enums.one_time_token_type
      token_hash: string
      relates_to: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["one_time_tokens"]>
    composites: {}
  }

  type one_time_tokensGetPayload<S extends boolean | null | undefined | one_time_tokensDefaultArgs> = $Result.GetResult<Prisma.$one_time_tokensPayload, S>

  type one_time_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<one_time_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: One_time_tokensCountAggregateInputType | true
    }

  export interface one_time_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['one_time_tokens'], meta: { name: 'one_time_tokens' } }
    /**
     * Find zero or one One_time_tokens that matches the filter.
     * @param {one_time_tokensFindUniqueArgs} args - Arguments to find a One_time_tokens
     * @example
     * // Get one One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends one_time_tokensFindUniqueArgs>(args: SelectSubset<T, one_time_tokensFindUniqueArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one One_time_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {one_time_tokensFindUniqueOrThrowArgs} args - Arguments to find a One_time_tokens
     * @example
     * // Get one One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends one_time_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, one_time_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first One_time_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {one_time_tokensFindFirstArgs} args - Arguments to find a One_time_tokens
     * @example
     * // Get one One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends one_time_tokensFindFirstArgs>(args?: SelectSubset<T, one_time_tokensFindFirstArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first One_time_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {one_time_tokensFindFirstOrThrowArgs} args - Arguments to find a One_time_tokens
     * @example
     * // Get one One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends one_time_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, one_time_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more One_time_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {one_time_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.findMany()
     * 
     * // Get first 10 One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const one_time_tokensWithIdOnly = await prisma.one_time_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends one_time_tokensFindManyArgs>(args?: SelectSubset<T, one_time_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a One_time_tokens.
     * @param {one_time_tokensCreateArgs} args - Arguments to create a One_time_tokens.
     * @example
     * // Create one One_time_tokens
     * const One_time_tokens = await prisma.one_time_tokens.create({
     *   data: {
     *     // ... data to create a One_time_tokens
     *   }
     * })
     * 
     */
    create<T extends one_time_tokensCreateArgs>(args: SelectSubset<T, one_time_tokensCreateArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many One_time_tokens.
     * @param {one_time_tokensCreateManyArgs} args - Arguments to create many One_time_tokens.
     * @example
     * // Create many One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends one_time_tokensCreateManyArgs>(args?: SelectSubset<T, one_time_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many One_time_tokens and returns the data saved in the database.
     * @param {one_time_tokensCreateManyAndReturnArgs} args - Arguments to create many One_time_tokens.
     * @example
     * // Create many One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many One_time_tokens and only return the `id`
     * const one_time_tokensWithIdOnly = await prisma.one_time_tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends one_time_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, one_time_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a One_time_tokens.
     * @param {one_time_tokensDeleteArgs} args - Arguments to delete one One_time_tokens.
     * @example
     * // Delete one One_time_tokens
     * const One_time_tokens = await prisma.one_time_tokens.delete({
     *   where: {
     *     // ... filter to delete one One_time_tokens
     *   }
     * })
     * 
     */
    delete<T extends one_time_tokensDeleteArgs>(args: SelectSubset<T, one_time_tokensDeleteArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one One_time_tokens.
     * @param {one_time_tokensUpdateArgs} args - Arguments to update one One_time_tokens.
     * @example
     * // Update one One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends one_time_tokensUpdateArgs>(args: SelectSubset<T, one_time_tokensUpdateArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more One_time_tokens.
     * @param {one_time_tokensDeleteManyArgs} args - Arguments to filter One_time_tokens to delete.
     * @example
     * // Delete a few One_time_tokens
     * const { count } = await prisma.one_time_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends one_time_tokensDeleteManyArgs>(args?: SelectSubset<T, one_time_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more One_time_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {one_time_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends one_time_tokensUpdateManyArgs>(args: SelectSubset<T, one_time_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more One_time_tokens and returns the data updated in the database.
     * @param {one_time_tokensUpdateManyAndReturnArgs} args - Arguments to update many One_time_tokens.
     * @example
     * // Update many One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more One_time_tokens and only return the `id`
     * const one_time_tokensWithIdOnly = await prisma.one_time_tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends one_time_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, one_time_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one One_time_tokens.
     * @param {one_time_tokensUpsertArgs} args - Arguments to update or create a One_time_tokens.
     * @example
     * // Update or create a One_time_tokens
     * const one_time_tokens = await prisma.one_time_tokens.upsert({
     *   create: {
     *     // ... data to create a One_time_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the One_time_tokens we want to update
     *   }
     * })
     */
    upsert<T extends one_time_tokensUpsertArgs>(args: SelectSubset<T, one_time_tokensUpsertArgs<ExtArgs>>): Prisma__one_time_tokensClient<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of One_time_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {one_time_tokensCountArgs} args - Arguments to filter One_time_tokens to count.
     * @example
     * // Count the number of One_time_tokens
     * const count = await prisma.one_time_tokens.count({
     *   where: {
     *     // ... the filter for the One_time_tokens we want to count
     *   }
     * })
    **/
    count<T extends one_time_tokensCountArgs>(
      args?: Subset<T, one_time_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], One_time_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a One_time_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {One_time_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends One_time_tokensAggregateArgs>(args: Subset<T, One_time_tokensAggregateArgs>): Prisma.PrismaPromise<GetOne_time_tokensAggregateType<T>>

    /**
     * Group by One_time_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {one_time_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends one_time_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: one_time_tokensGroupByArgs['orderBy'] }
        : { orderBy?: one_time_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, one_time_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOne_time_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the one_time_tokens model
   */
  readonly fields: one_time_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for one_time_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__one_time_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the one_time_tokens model
   */
  interface one_time_tokensFieldRefs {
    readonly id: FieldRef<"one_time_tokens", 'String'>
    readonly user_id: FieldRef<"one_time_tokens", 'String'>
    readonly token_type: FieldRef<"one_time_tokens", 'one_time_token_type'>
    readonly token_hash: FieldRef<"one_time_tokens", 'String'>
    readonly relates_to: FieldRef<"one_time_tokens", 'String'>
    readonly created_at: FieldRef<"one_time_tokens", 'DateTime'>
    readonly updated_at: FieldRef<"one_time_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * one_time_tokens findUnique
   */
  export type one_time_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * Filter, which one_time_tokens to fetch.
     */
    where: one_time_tokensWhereUniqueInput
  }

  /**
   * one_time_tokens findUniqueOrThrow
   */
  export type one_time_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * Filter, which one_time_tokens to fetch.
     */
    where: one_time_tokensWhereUniqueInput
  }

  /**
   * one_time_tokens findFirst
   */
  export type one_time_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * Filter, which one_time_tokens to fetch.
     */
    where?: one_time_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of one_time_tokens to fetch.
     */
    orderBy?: one_time_tokensOrderByWithRelationInput | one_time_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for one_time_tokens.
     */
    cursor?: one_time_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` one_time_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` one_time_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of one_time_tokens.
     */
    distinct?: One_time_tokensScalarFieldEnum | One_time_tokensScalarFieldEnum[]
  }

  /**
   * one_time_tokens findFirstOrThrow
   */
  export type one_time_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * Filter, which one_time_tokens to fetch.
     */
    where?: one_time_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of one_time_tokens to fetch.
     */
    orderBy?: one_time_tokensOrderByWithRelationInput | one_time_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for one_time_tokens.
     */
    cursor?: one_time_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` one_time_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` one_time_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of one_time_tokens.
     */
    distinct?: One_time_tokensScalarFieldEnum | One_time_tokensScalarFieldEnum[]
  }

  /**
   * one_time_tokens findMany
   */
  export type one_time_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * Filter, which one_time_tokens to fetch.
     */
    where?: one_time_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of one_time_tokens to fetch.
     */
    orderBy?: one_time_tokensOrderByWithRelationInput | one_time_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing one_time_tokens.
     */
    cursor?: one_time_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` one_time_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` one_time_tokens.
     */
    skip?: number
    distinct?: One_time_tokensScalarFieldEnum | One_time_tokensScalarFieldEnum[]
  }

  /**
   * one_time_tokens create
   */
  export type one_time_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a one_time_tokens.
     */
    data: XOR<one_time_tokensCreateInput, one_time_tokensUncheckedCreateInput>
  }

  /**
   * one_time_tokens createMany
   */
  export type one_time_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many one_time_tokens.
     */
    data: one_time_tokensCreateManyInput | one_time_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * one_time_tokens createManyAndReturn
   */
  export type one_time_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many one_time_tokens.
     */
    data: one_time_tokensCreateManyInput | one_time_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * one_time_tokens update
   */
  export type one_time_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a one_time_tokens.
     */
    data: XOR<one_time_tokensUpdateInput, one_time_tokensUncheckedUpdateInput>
    /**
     * Choose, which one_time_tokens to update.
     */
    where: one_time_tokensWhereUniqueInput
  }

  /**
   * one_time_tokens updateMany
   */
  export type one_time_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update one_time_tokens.
     */
    data: XOR<one_time_tokensUpdateManyMutationInput, one_time_tokensUncheckedUpdateManyInput>
    /**
     * Filter which one_time_tokens to update
     */
    where?: one_time_tokensWhereInput
    /**
     * Limit how many one_time_tokens to update.
     */
    limit?: number
  }

  /**
   * one_time_tokens updateManyAndReturn
   */
  export type one_time_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * The data used to update one_time_tokens.
     */
    data: XOR<one_time_tokensUpdateManyMutationInput, one_time_tokensUncheckedUpdateManyInput>
    /**
     * Filter which one_time_tokens to update
     */
    where?: one_time_tokensWhereInput
    /**
     * Limit how many one_time_tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * one_time_tokens upsert
   */
  export type one_time_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the one_time_tokens to update in case it exists.
     */
    where: one_time_tokensWhereUniqueInput
    /**
     * In case the one_time_tokens found by the `where` argument doesn't exist, create a new one_time_tokens with this data.
     */
    create: XOR<one_time_tokensCreateInput, one_time_tokensUncheckedCreateInput>
    /**
     * In case the one_time_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<one_time_tokensUpdateInput, one_time_tokensUncheckedUpdateInput>
  }

  /**
   * one_time_tokens delete
   */
  export type one_time_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    /**
     * Filter which one_time_tokens to delete.
     */
    where: one_time_tokensWhereUniqueInput
  }

  /**
   * one_time_tokens deleteMany
   */
  export type one_time_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which one_time_tokens to delete
     */
    where?: one_time_tokensWhereInput
    /**
     * Limit how many one_time_tokens to delete.
     */
    limit?: number
  }

  /**
   * one_time_tokens without action
   */
  export type one_time_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
  }


  /**
   * Model refresh_tokens
   */

  export type AggregateRefresh_tokens = {
    _count: Refresh_tokensCountAggregateOutputType | null
    _avg: Refresh_tokensAvgAggregateOutputType | null
    _sum: Refresh_tokensSumAggregateOutputType | null
    _min: Refresh_tokensMinAggregateOutputType | null
    _max: Refresh_tokensMaxAggregateOutputType | null
  }

  export type Refresh_tokensAvgAggregateOutputType = {
    id: number | null
  }

  export type Refresh_tokensSumAggregateOutputType = {
    id: bigint | null
  }

  export type Refresh_tokensMinAggregateOutputType = {
    instance_id: string | null
    id: bigint | null
    token: string | null
    user_id: string | null
    revoked: boolean | null
    created_at: Date | null
    updated_at: Date | null
    parent: string | null
    session_id: string | null
  }

  export type Refresh_tokensMaxAggregateOutputType = {
    instance_id: string | null
    id: bigint | null
    token: string | null
    user_id: string | null
    revoked: boolean | null
    created_at: Date | null
    updated_at: Date | null
    parent: string | null
    session_id: string | null
  }

  export type Refresh_tokensCountAggregateOutputType = {
    instance_id: number
    id: number
    token: number
    user_id: number
    revoked: number
    created_at: number
    updated_at: number
    parent: number
    session_id: number
    _all: number
  }


  export type Refresh_tokensAvgAggregateInputType = {
    id?: true
  }

  export type Refresh_tokensSumAggregateInputType = {
    id?: true
  }

  export type Refresh_tokensMinAggregateInputType = {
    instance_id?: true
    id?: true
    token?: true
    user_id?: true
    revoked?: true
    created_at?: true
    updated_at?: true
    parent?: true
    session_id?: true
  }

  export type Refresh_tokensMaxAggregateInputType = {
    instance_id?: true
    id?: true
    token?: true
    user_id?: true
    revoked?: true
    created_at?: true
    updated_at?: true
    parent?: true
    session_id?: true
  }

  export type Refresh_tokensCountAggregateInputType = {
    instance_id?: true
    id?: true
    token?: true
    user_id?: true
    revoked?: true
    created_at?: true
    updated_at?: true
    parent?: true
    session_id?: true
    _all?: true
  }

  export type Refresh_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_tokens to aggregate.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refresh_tokens
    **/
    _count?: true | Refresh_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Refresh_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Refresh_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Refresh_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Refresh_tokensMaxAggregateInputType
  }

  export type GetRefresh_tokensAggregateType<T extends Refresh_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateRefresh_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefresh_tokens[P]>
      : GetScalarType<T[P], AggregateRefresh_tokens[P]>
  }




  export type refresh_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refresh_tokensWhereInput
    orderBy?: refresh_tokensOrderByWithAggregationInput | refresh_tokensOrderByWithAggregationInput[]
    by: Refresh_tokensScalarFieldEnum[] | Refresh_tokensScalarFieldEnum
    having?: refresh_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Refresh_tokensCountAggregateInputType | true
    _avg?: Refresh_tokensAvgAggregateInputType
    _sum?: Refresh_tokensSumAggregateInputType
    _min?: Refresh_tokensMinAggregateInputType
    _max?: Refresh_tokensMaxAggregateInputType
  }

  export type Refresh_tokensGroupByOutputType = {
    instance_id: string | null
    id: bigint
    token: string | null
    user_id: string | null
    revoked: boolean | null
    created_at: Date | null
    updated_at: Date | null
    parent: string | null
    session_id: string | null
    _count: Refresh_tokensCountAggregateOutputType | null
    _avg: Refresh_tokensAvgAggregateOutputType | null
    _sum: Refresh_tokensSumAggregateOutputType | null
    _min: Refresh_tokensMinAggregateOutputType | null
    _max: Refresh_tokensMaxAggregateOutputType | null
  }

  type GetRefresh_tokensGroupByPayload<T extends refresh_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Refresh_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Refresh_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Refresh_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Refresh_tokensGroupByOutputType[P]>
        }
      >
    >


  export type refresh_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    token?: boolean
    user_id?: boolean
    revoked?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent?: boolean
    session_id?: boolean
    sessions?: boolean | refresh_tokens$sessionsArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    token?: boolean
    user_id?: boolean
    revoked?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent?: boolean
    session_id?: boolean
    sessions?: boolean | refresh_tokens$sessionsArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    token?: boolean
    user_id?: boolean
    revoked?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent?: boolean
    session_id?: boolean
    sessions?: boolean | refresh_tokens$sessionsArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectScalar = {
    instance_id?: boolean
    id?: boolean
    token?: boolean
    user_id?: boolean
    revoked?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent?: boolean
    session_id?: boolean
  }

  export type refresh_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"instance_id" | "id" | "token" | "user_id" | "revoked" | "created_at" | "updated_at" | "parent" | "session_id", ExtArgs["result"]["refresh_tokens"]>
  export type refresh_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | refresh_tokens$sessionsArgs<ExtArgs>
  }
  export type refresh_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | refresh_tokens$sessionsArgs<ExtArgs>
  }
  export type refresh_tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | refresh_tokens$sessionsArgs<ExtArgs>
  }

  export type $refresh_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refresh_tokens"
    objects: {
      sessions: Prisma.$sessionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      instance_id: string | null
      id: bigint
      token: string | null
      user_id: string | null
      revoked: boolean | null
      created_at: Date | null
      updated_at: Date | null
      parent: string | null
      session_id: string | null
    }, ExtArgs["result"]["refresh_tokens"]>
    composites: {}
  }

  type refresh_tokensGetPayload<S extends boolean | null | undefined | refresh_tokensDefaultArgs> = $Result.GetResult<Prisma.$refresh_tokensPayload, S>

  type refresh_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<refresh_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Refresh_tokensCountAggregateInputType | true
    }

  export interface refresh_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refresh_tokens'], meta: { name: 'refresh_tokens' } }
    /**
     * Find zero or one Refresh_tokens that matches the filter.
     * @param {refresh_tokensFindUniqueArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refresh_tokensFindUniqueArgs>(args: SelectSubset<T, refresh_tokensFindUniqueArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refresh_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {refresh_tokensFindUniqueOrThrowArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refresh_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, refresh_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refresh_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindFirstArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refresh_tokensFindFirstArgs>(args?: SelectSubset<T, refresh_tokensFindFirstArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refresh_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindFirstOrThrowArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refresh_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, refresh_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refresh_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findMany()
     * 
     * // Get first 10 Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findMany({ take: 10 })
     * 
     * // Only select the `instance_id`
     * const refresh_tokensWithInstance_idOnly = await prisma.refresh_tokens.findMany({ select: { instance_id: true } })
     * 
     */
    findMany<T extends refresh_tokensFindManyArgs>(args?: SelectSubset<T, refresh_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refresh_tokens.
     * @param {refresh_tokensCreateArgs} args - Arguments to create a Refresh_tokens.
     * @example
     * // Create one Refresh_tokens
     * const Refresh_tokens = await prisma.refresh_tokens.create({
     *   data: {
     *     // ... data to create a Refresh_tokens
     *   }
     * })
     * 
     */
    create<T extends refresh_tokensCreateArgs>(args: SelectSubset<T, refresh_tokensCreateArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refresh_tokens.
     * @param {refresh_tokensCreateManyArgs} args - Arguments to create many Refresh_tokens.
     * @example
     * // Create many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refresh_tokensCreateManyArgs>(args?: SelectSubset<T, refresh_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refresh_tokens and returns the data saved in the database.
     * @param {refresh_tokensCreateManyAndReturnArgs} args - Arguments to create many Refresh_tokens.
     * @example
     * // Create many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refresh_tokens and only return the `instance_id`
     * const refresh_tokensWithInstance_idOnly = await prisma.refresh_tokens.createManyAndReturn({
     *   select: { instance_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends refresh_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, refresh_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Refresh_tokens.
     * @param {refresh_tokensDeleteArgs} args - Arguments to delete one Refresh_tokens.
     * @example
     * // Delete one Refresh_tokens
     * const Refresh_tokens = await prisma.refresh_tokens.delete({
     *   where: {
     *     // ... filter to delete one Refresh_tokens
     *   }
     * })
     * 
     */
    delete<T extends refresh_tokensDeleteArgs>(args: SelectSubset<T, refresh_tokensDeleteArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refresh_tokens.
     * @param {refresh_tokensUpdateArgs} args - Arguments to update one Refresh_tokens.
     * @example
     * // Update one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refresh_tokensUpdateArgs>(args: SelectSubset<T, refresh_tokensUpdateArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refresh_tokens.
     * @param {refresh_tokensDeleteManyArgs} args - Arguments to filter Refresh_tokens to delete.
     * @example
     * // Delete a few Refresh_tokens
     * const { count } = await prisma.refresh_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refresh_tokensDeleteManyArgs>(args?: SelectSubset<T, refresh_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refresh_tokensUpdateManyArgs>(args: SelectSubset<T, refresh_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refresh_tokens and returns the data updated in the database.
     * @param {refresh_tokensUpdateManyAndReturnArgs} args - Arguments to update many Refresh_tokens.
     * @example
     * // Update many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Refresh_tokens and only return the `instance_id`
     * const refresh_tokensWithInstance_idOnly = await prisma.refresh_tokens.updateManyAndReturn({
     *   select: { instance_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends refresh_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, refresh_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Refresh_tokens.
     * @param {refresh_tokensUpsertArgs} args - Arguments to update or create a Refresh_tokens.
     * @example
     * // Update or create a Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.upsert({
     *   create: {
     *     // ... data to create a Refresh_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refresh_tokens we want to update
     *   }
     * })
     */
    upsert<T extends refresh_tokensUpsertArgs>(args: SelectSubset<T, refresh_tokensUpsertArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensCountArgs} args - Arguments to filter Refresh_tokens to count.
     * @example
     * // Count the number of Refresh_tokens
     * const count = await prisma.refresh_tokens.count({
     *   where: {
     *     // ... the filter for the Refresh_tokens we want to count
     *   }
     * })
    **/
    count<T extends refresh_tokensCountArgs>(
      args?: Subset<T, refresh_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Refresh_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Refresh_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Refresh_tokensAggregateArgs>(args: Subset<T, Refresh_tokensAggregateArgs>): Prisma.PrismaPromise<GetRefresh_tokensAggregateType<T>>

    /**
     * Group by Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refresh_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refresh_tokensGroupByArgs['orderBy'] }
        : { orderBy?: refresh_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refresh_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefresh_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refresh_tokens model
   */
  readonly fields: refresh_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refresh_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refresh_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends refresh_tokens$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, refresh_tokens$sessionsArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refresh_tokens model
   */
  interface refresh_tokensFieldRefs {
    readonly instance_id: FieldRef<"refresh_tokens", 'String'>
    readonly id: FieldRef<"refresh_tokens", 'BigInt'>
    readonly token: FieldRef<"refresh_tokens", 'String'>
    readonly user_id: FieldRef<"refresh_tokens", 'String'>
    readonly revoked: FieldRef<"refresh_tokens", 'Boolean'>
    readonly created_at: FieldRef<"refresh_tokens", 'DateTime'>
    readonly updated_at: FieldRef<"refresh_tokens", 'DateTime'>
    readonly parent: FieldRef<"refresh_tokens", 'String'>
    readonly session_id: FieldRef<"refresh_tokens", 'String'>
  }
    

  // Custom InputTypes
  /**
   * refresh_tokens findUnique
   */
  export type refresh_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens findUniqueOrThrow
   */
  export type refresh_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens findFirst
   */
  export type refresh_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens findFirstOrThrow
   */
  export type refresh_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens findMany
   */
  export type refresh_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens create
   */
  export type refresh_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a refresh_tokens.
     */
    data?: XOR<refresh_tokensCreateInput, refresh_tokensUncheckedCreateInput>
  }

  /**
   * refresh_tokens createMany
   */
  export type refresh_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refresh_tokens.
     */
    data: refresh_tokensCreateManyInput | refresh_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refresh_tokens createManyAndReturn
   */
  export type refresh_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many refresh_tokens.
     */
    data: refresh_tokensCreateManyInput | refresh_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * refresh_tokens update
   */
  export type refresh_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateInput, refresh_tokensUncheckedUpdateInput>
    /**
     * Choose, which refresh_tokens to update.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens updateMany
   */
  export type refresh_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateManyMutationInput, refresh_tokensUncheckedUpdateManyInput>
    /**
     * Filter which refresh_tokens to update
     */
    where?: refresh_tokensWhereInput
    /**
     * Limit how many refresh_tokens to update.
     */
    limit?: number
  }

  /**
   * refresh_tokens updateManyAndReturn
   */
  export type refresh_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * The data used to update refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateManyMutationInput, refresh_tokensUncheckedUpdateManyInput>
    /**
     * Filter which refresh_tokens to update
     */
    where?: refresh_tokensWhereInput
    /**
     * Limit how many refresh_tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * refresh_tokens upsert
   */
  export type refresh_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the refresh_tokens to update in case it exists.
     */
    where: refresh_tokensWhereUniqueInput
    /**
     * In case the refresh_tokens found by the `where` argument doesn't exist, create a new refresh_tokens with this data.
     */
    create: XOR<refresh_tokensCreateInput, refresh_tokensUncheckedCreateInput>
    /**
     * In case the refresh_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refresh_tokensUpdateInput, refresh_tokensUncheckedUpdateInput>
  }

  /**
   * refresh_tokens delete
   */
  export type refresh_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter which refresh_tokens to delete.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens deleteMany
   */
  export type refresh_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_tokens to delete
     */
    where?: refresh_tokensWhereInput
    /**
     * Limit how many refresh_tokens to delete.
     */
    limit?: number
  }

  /**
   * refresh_tokens.sessions
   */
  export type refresh_tokens$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
  }

  /**
   * refresh_tokens without action
   */
  export type refresh_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
  }


  /**
   * Model saml_providers
   */

  export type AggregateSaml_providers = {
    _count: Saml_providersCountAggregateOutputType | null
    _min: Saml_providersMinAggregateOutputType | null
    _max: Saml_providersMaxAggregateOutputType | null
  }

  export type Saml_providersMinAggregateOutputType = {
    id: string | null
    sso_provider_id: string | null
    entity_id: string | null
    metadata_xml: string | null
    metadata_url: string | null
    created_at: Date | null
    updated_at: Date | null
    name_id_format: string | null
  }

  export type Saml_providersMaxAggregateOutputType = {
    id: string | null
    sso_provider_id: string | null
    entity_id: string | null
    metadata_xml: string | null
    metadata_url: string | null
    created_at: Date | null
    updated_at: Date | null
    name_id_format: string | null
  }

  export type Saml_providersCountAggregateOutputType = {
    id: number
    sso_provider_id: number
    entity_id: number
    metadata_xml: number
    metadata_url: number
    attribute_mapping: number
    created_at: number
    updated_at: number
    name_id_format: number
    _all: number
  }


  export type Saml_providersMinAggregateInputType = {
    id?: true
    sso_provider_id?: true
    entity_id?: true
    metadata_xml?: true
    metadata_url?: true
    created_at?: true
    updated_at?: true
    name_id_format?: true
  }

  export type Saml_providersMaxAggregateInputType = {
    id?: true
    sso_provider_id?: true
    entity_id?: true
    metadata_xml?: true
    metadata_url?: true
    created_at?: true
    updated_at?: true
    name_id_format?: true
  }

  export type Saml_providersCountAggregateInputType = {
    id?: true
    sso_provider_id?: true
    entity_id?: true
    metadata_xml?: true
    metadata_url?: true
    attribute_mapping?: true
    created_at?: true
    updated_at?: true
    name_id_format?: true
    _all?: true
  }

  export type Saml_providersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saml_providers to aggregate.
     */
    where?: saml_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_providers to fetch.
     */
    orderBy?: saml_providersOrderByWithRelationInput | saml_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saml_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saml_providers
    **/
    _count?: true | Saml_providersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Saml_providersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Saml_providersMaxAggregateInputType
  }

  export type GetSaml_providersAggregateType<T extends Saml_providersAggregateArgs> = {
        [P in keyof T & keyof AggregateSaml_providers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaml_providers[P]>
      : GetScalarType<T[P], AggregateSaml_providers[P]>
  }




  export type saml_providersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saml_providersWhereInput
    orderBy?: saml_providersOrderByWithAggregationInput | saml_providersOrderByWithAggregationInput[]
    by: Saml_providersScalarFieldEnum[] | Saml_providersScalarFieldEnum
    having?: saml_providersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Saml_providersCountAggregateInputType | true
    _min?: Saml_providersMinAggregateInputType
    _max?: Saml_providersMaxAggregateInputType
  }

  export type Saml_providersGroupByOutputType = {
    id: string
    sso_provider_id: string
    entity_id: string
    metadata_xml: string
    metadata_url: string | null
    attribute_mapping: JsonValue | null
    created_at: Date | null
    updated_at: Date | null
    name_id_format: string | null
    _count: Saml_providersCountAggregateOutputType | null
    _min: Saml_providersMinAggregateOutputType | null
    _max: Saml_providersMaxAggregateOutputType | null
  }

  type GetSaml_providersGroupByPayload<T extends saml_providersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Saml_providersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Saml_providersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Saml_providersGroupByOutputType[P]>
            : GetScalarType<T[P], Saml_providersGroupByOutputType[P]>
        }
      >
    >


  export type saml_providersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    entity_id?: boolean
    metadata_xml?: boolean
    metadata_url?: boolean
    attribute_mapping?: boolean
    created_at?: boolean
    updated_at?: boolean
    name_id_format?: boolean
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saml_providers"]>

  export type saml_providersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    entity_id?: boolean
    metadata_xml?: boolean
    metadata_url?: boolean
    attribute_mapping?: boolean
    created_at?: boolean
    updated_at?: boolean
    name_id_format?: boolean
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saml_providers"]>

  export type saml_providersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    entity_id?: boolean
    metadata_xml?: boolean
    metadata_url?: boolean
    attribute_mapping?: boolean
    created_at?: boolean
    updated_at?: boolean
    name_id_format?: boolean
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saml_providers"]>

  export type saml_providersSelectScalar = {
    id?: boolean
    sso_provider_id?: boolean
    entity_id?: boolean
    metadata_xml?: boolean
    metadata_url?: boolean
    attribute_mapping?: boolean
    created_at?: boolean
    updated_at?: boolean
    name_id_format?: boolean
  }

  export type saml_providersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sso_provider_id" | "entity_id" | "metadata_xml" | "metadata_url" | "attribute_mapping" | "created_at" | "updated_at" | "name_id_format", ExtArgs["result"]["saml_providers"]>
  export type saml_providersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }
  export type saml_providersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }
  export type saml_providersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }

  export type $saml_providersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saml_providers"
    objects: {
      sso_providers: Prisma.$sso_providersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sso_provider_id: string
      entity_id: string
      metadata_xml: string
      metadata_url: string | null
      attribute_mapping: Prisma.JsonValue | null
      created_at: Date | null
      updated_at: Date | null
      name_id_format: string | null
    }, ExtArgs["result"]["saml_providers"]>
    composites: {}
  }

  type saml_providersGetPayload<S extends boolean | null | undefined | saml_providersDefaultArgs> = $Result.GetResult<Prisma.$saml_providersPayload, S>

  type saml_providersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saml_providersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Saml_providersCountAggregateInputType | true
    }

  export interface saml_providersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saml_providers'], meta: { name: 'saml_providers' } }
    /**
     * Find zero or one Saml_providers that matches the filter.
     * @param {saml_providersFindUniqueArgs} args - Arguments to find a Saml_providers
     * @example
     * // Get one Saml_providers
     * const saml_providers = await prisma.saml_providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saml_providersFindUniqueArgs>(args: SelectSubset<T, saml_providersFindUniqueArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saml_providers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saml_providersFindUniqueOrThrowArgs} args - Arguments to find a Saml_providers
     * @example
     * // Get one Saml_providers
     * const saml_providers = await prisma.saml_providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saml_providersFindUniqueOrThrowArgs>(args: SelectSubset<T, saml_providersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saml_providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_providersFindFirstArgs} args - Arguments to find a Saml_providers
     * @example
     * // Get one Saml_providers
     * const saml_providers = await prisma.saml_providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saml_providersFindFirstArgs>(args?: SelectSubset<T, saml_providersFindFirstArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saml_providers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_providersFindFirstOrThrowArgs} args - Arguments to find a Saml_providers
     * @example
     * // Get one Saml_providers
     * const saml_providers = await prisma.saml_providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saml_providersFindFirstOrThrowArgs>(args?: SelectSubset<T, saml_providersFindFirstOrThrowArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saml_providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_providersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saml_providers
     * const saml_providers = await prisma.saml_providers.findMany()
     * 
     * // Get first 10 Saml_providers
     * const saml_providers = await prisma.saml_providers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saml_providersWithIdOnly = await prisma.saml_providers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saml_providersFindManyArgs>(args?: SelectSubset<T, saml_providersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saml_providers.
     * @param {saml_providersCreateArgs} args - Arguments to create a Saml_providers.
     * @example
     * // Create one Saml_providers
     * const Saml_providers = await prisma.saml_providers.create({
     *   data: {
     *     // ... data to create a Saml_providers
     *   }
     * })
     * 
     */
    create<T extends saml_providersCreateArgs>(args: SelectSubset<T, saml_providersCreateArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saml_providers.
     * @param {saml_providersCreateManyArgs} args - Arguments to create many Saml_providers.
     * @example
     * // Create many Saml_providers
     * const saml_providers = await prisma.saml_providers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saml_providersCreateManyArgs>(args?: SelectSubset<T, saml_providersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saml_providers and returns the data saved in the database.
     * @param {saml_providersCreateManyAndReturnArgs} args - Arguments to create many Saml_providers.
     * @example
     * // Create many Saml_providers
     * const saml_providers = await prisma.saml_providers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saml_providers and only return the `id`
     * const saml_providersWithIdOnly = await prisma.saml_providers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saml_providersCreateManyAndReturnArgs>(args?: SelectSubset<T, saml_providersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Saml_providers.
     * @param {saml_providersDeleteArgs} args - Arguments to delete one Saml_providers.
     * @example
     * // Delete one Saml_providers
     * const Saml_providers = await prisma.saml_providers.delete({
     *   where: {
     *     // ... filter to delete one Saml_providers
     *   }
     * })
     * 
     */
    delete<T extends saml_providersDeleteArgs>(args: SelectSubset<T, saml_providersDeleteArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saml_providers.
     * @param {saml_providersUpdateArgs} args - Arguments to update one Saml_providers.
     * @example
     * // Update one Saml_providers
     * const saml_providers = await prisma.saml_providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saml_providersUpdateArgs>(args: SelectSubset<T, saml_providersUpdateArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saml_providers.
     * @param {saml_providersDeleteManyArgs} args - Arguments to filter Saml_providers to delete.
     * @example
     * // Delete a few Saml_providers
     * const { count } = await prisma.saml_providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saml_providersDeleteManyArgs>(args?: SelectSubset<T, saml_providersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saml_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_providersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saml_providers
     * const saml_providers = await prisma.saml_providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saml_providersUpdateManyArgs>(args: SelectSubset<T, saml_providersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saml_providers and returns the data updated in the database.
     * @param {saml_providersUpdateManyAndReturnArgs} args - Arguments to update many Saml_providers.
     * @example
     * // Update many Saml_providers
     * const saml_providers = await prisma.saml_providers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Saml_providers and only return the `id`
     * const saml_providersWithIdOnly = await prisma.saml_providers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saml_providersUpdateManyAndReturnArgs>(args: SelectSubset<T, saml_providersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Saml_providers.
     * @param {saml_providersUpsertArgs} args - Arguments to update or create a Saml_providers.
     * @example
     * // Update or create a Saml_providers
     * const saml_providers = await prisma.saml_providers.upsert({
     *   create: {
     *     // ... data to create a Saml_providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saml_providers we want to update
     *   }
     * })
     */
    upsert<T extends saml_providersUpsertArgs>(args: SelectSubset<T, saml_providersUpsertArgs<ExtArgs>>): Prisma__saml_providersClient<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saml_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_providersCountArgs} args - Arguments to filter Saml_providers to count.
     * @example
     * // Count the number of Saml_providers
     * const count = await prisma.saml_providers.count({
     *   where: {
     *     // ... the filter for the Saml_providers we want to count
     *   }
     * })
    **/
    count<T extends saml_providersCountArgs>(
      args?: Subset<T, saml_providersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Saml_providersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saml_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Saml_providersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Saml_providersAggregateArgs>(args: Subset<T, Saml_providersAggregateArgs>): Prisma.PrismaPromise<GetSaml_providersAggregateType<T>>

    /**
     * Group by Saml_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_providersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saml_providersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saml_providersGroupByArgs['orderBy'] }
        : { orderBy?: saml_providersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saml_providersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaml_providersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saml_providers model
   */
  readonly fields: saml_providersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saml_providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saml_providersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sso_providers<T extends sso_providersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sso_providersDefaultArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saml_providers model
   */
  interface saml_providersFieldRefs {
    readonly id: FieldRef<"saml_providers", 'String'>
    readonly sso_provider_id: FieldRef<"saml_providers", 'String'>
    readonly entity_id: FieldRef<"saml_providers", 'String'>
    readonly metadata_xml: FieldRef<"saml_providers", 'String'>
    readonly metadata_url: FieldRef<"saml_providers", 'String'>
    readonly attribute_mapping: FieldRef<"saml_providers", 'Json'>
    readonly created_at: FieldRef<"saml_providers", 'DateTime'>
    readonly updated_at: FieldRef<"saml_providers", 'DateTime'>
    readonly name_id_format: FieldRef<"saml_providers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * saml_providers findUnique
   */
  export type saml_providersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * Filter, which saml_providers to fetch.
     */
    where: saml_providersWhereUniqueInput
  }

  /**
   * saml_providers findUniqueOrThrow
   */
  export type saml_providersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * Filter, which saml_providers to fetch.
     */
    where: saml_providersWhereUniqueInput
  }

  /**
   * saml_providers findFirst
   */
  export type saml_providersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * Filter, which saml_providers to fetch.
     */
    where?: saml_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_providers to fetch.
     */
    orderBy?: saml_providersOrderByWithRelationInput | saml_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saml_providers.
     */
    cursor?: saml_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saml_providers.
     */
    distinct?: Saml_providersScalarFieldEnum | Saml_providersScalarFieldEnum[]
  }

  /**
   * saml_providers findFirstOrThrow
   */
  export type saml_providersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * Filter, which saml_providers to fetch.
     */
    where?: saml_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_providers to fetch.
     */
    orderBy?: saml_providersOrderByWithRelationInput | saml_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saml_providers.
     */
    cursor?: saml_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saml_providers.
     */
    distinct?: Saml_providersScalarFieldEnum | Saml_providersScalarFieldEnum[]
  }

  /**
   * saml_providers findMany
   */
  export type saml_providersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * Filter, which saml_providers to fetch.
     */
    where?: saml_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_providers to fetch.
     */
    orderBy?: saml_providersOrderByWithRelationInput | saml_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saml_providers.
     */
    cursor?: saml_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_providers.
     */
    skip?: number
    distinct?: Saml_providersScalarFieldEnum | Saml_providersScalarFieldEnum[]
  }

  /**
   * saml_providers create
   */
  export type saml_providersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * The data needed to create a saml_providers.
     */
    data: XOR<saml_providersCreateInput, saml_providersUncheckedCreateInput>
  }

  /**
   * saml_providers createMany
   */
  export type saml_providersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saml_providers.
     */
    data: saml_providersCreateManyInput | saml_providersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saml_providers createManyAndReturn
   */
  export type saml_providersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * The data used to create many saml_providers.
     */
    data: saml_providersCreateManyInput | saml_providersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * saml_providers update
   */
  export type saml_providersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * The data needed to update a saml_providers.
     */
    data: XOR<saml_providersUpdateInput, saml_providersUncheckedUpdateInput>
    /**
     * Choose, which saml_providers to update.
     */
    where: saml_providersWhereUniqueInput
  }

  /**
   * saml_providers updateMany
   */
  export type saml_providersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saml_providers.
     */
    data: XOR<saml_providersUpdateManyMutationInput, saml_providersUncheckedUpdateManyInput>
    /**
     * Filter which saml_providers to update
     */
    where?: saml_providersWhereInput
    /**
     * Limit how many saml_providers to update.
     */
    limit?: number
  }

  /**
   * saml_providers updateManyAndReturn
   */
  export type saml_providersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * The data used to update saml_providers.
     */
    data: XOR<saml_providersUpdateManyMutationInput, saml_providersUncheckedUpdateManyInput>
    /**
     * Filter which saml_providers to update
     */
    where?: saml_providersWhereInput
    /**
     * Limit how many saml_providers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * saml_providers upsert
   */
  export type saml_providersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * The filter to search for the saml_providers to update in case it exists.
     */
    where: saml_providersWhereUniqueInput
    /**
     * In case the saml_providers found by the `where` argument doesn't exist, create a new saml_providers with this data.
     */
    create: XOR<saml_providersCreateInput, saml_providersUncheckedCreateInput>
    /**
     * In case the saml_providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saml_providersUpdateInput, saml_providersUncheckedUpdateInput>
  }

  /**
   * saml_providers delete
   */
  export type saml_providersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    /**
     * Filter which saml_providers to delete.
     */
    where: saml_providersWhereUniqueInput
  }

  /**
   * saml_providers deleteMany
   */
  export type saml_providersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saml_providers to delete
     */
    where?: saml_providersWhereInput
    /**
     * Limit how many saml_providers to delete.
     */
    limit?: number
  }

  /**
   * saml_providers without action
   */
  export type saml_providersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
  }


  /**
   * Model saml_relay_states
   */

  export type AggregateSaml_relay_states = {
    _count: Saml_relay_statesCountAggregateOutputType | null
    _min: Saml_relay_statesMinAggregateOutputType | null
    _max: Saml_relay_statesMaxAggregateOutputType | null
  }

  export type Saml_relay_statesMinAggregateOutputType = {
    id: string | null
    sso_provider_id: string | null
    request_id: string | null
    for_email: string | null
    redirect_to: string | null
    created_at: Date | null
    updated_at: Date | null
    flow_state_id: string | null
  }

  export type Saml_relay_statesMaxAggregateOutputType = {
    id: string | null
    sso_provider_id: string | null
    request_id: string | null
    for_email: string | null
    redirect_to: string | null
    created_at: Date | null
    updated_at: Date | null
    flow_state_id: string | null
  }

  export type Saml_relay_statesCountAggregateOutputType = {
    id: number
    sso_provider_id: number
    request_id: number
    for_email: number
    redirect_to: number
    created_at: number
    updated_at: number
    flow_state_id: number
    _all: number
  }


  export type Saml_relay_statesMinAggregateInputType = {
    id?: true
    sso_provider_id?: true
    request_id?: true
    for_email?: true
    redirect_to?: true
    created_at?: true
    updated_at?: true
    flow_state_id?: true
  }

  export type Saml_relay_statesMaxAggregateInputType = {
    id?: true
    sso_provider_id?: true
    request_id?: true
    for_email?: true
    redirect_to?: true
    created_at?: true
    updated_at?: true
    flow_state_id?: true
  }

  export type Saml_relay_statesCountAggregateInputType = {
    id?: true
    sso_provider_id?: true
    request_id?: true
    for_email?: true
    redirect_to?: true
    created_at?: true
    updated_at?: true
    flow_state_id?: true
    _all?: true
  }

  export type Saml_relay_statesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saml_relay_states to aggregate.
     */
    where?: saml_relay_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_relay_states to fetch.
     */
    orderBy?: saml_relay_statesOrderByWithRelationInput | saml_relay_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saml_relay_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_relay_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_relay_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saml_relay_states
    **/
    _count?: true | Saml_relay_statesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Saml_relay_statesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Saml_relay_statesMaxAggregateInputType
  }

  export type GetSaml_relay_statesAggregateType<T extends Saml_relay_statesAggregateArgs> = {
        [P in keyof T & keyof AggregateSaml_relay_states]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaml_relay_states[P]>
      : GetScalarType<T[P], AggregateSaml_relay_states[P]>
  }




  export type saml_relay_statesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saml_relay_statesWhereInput
    orderBy?: saml_relay_statesOrderByWithAggregationInput | saml_relay_statesOrderByWithAggregationInput[]
    by: Saml_relay_statesScalarFieldEnum[] | Saml_relay_statesScalarFieldEnum
    having?: saml_relay_statesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Saml_relay_statesCountAggregateInputType | true
    _min?: Saml_relay_statesMinAggregateInputType
    _max?: Saml_relay_statesMaxAggregateInputType
  }

  export type Saml_relay_statesGroupByOutputType = {
    id: string
    sso_provider_id: string
    request_id: string
    for_email: string | null
    redirect_to: string | null
    created_at: Date | null
    updated_at: Date | null
    flow_state_id: string | null
    _count: Saml_relay_statesCountAggregateOutputType | null
    _min: Saml_relay_statesMinAggregateOutputType | null
    _max: Saml_relay_statesMaxAggregateOutputType | null
  }

  type GetSaml_relay_statesGroupByPayload<T extends saml_relay_statesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Saml_relay_statesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Saml_relay_statesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Saml_relay_statesGroupByOutputType[P]>
            : GetScalarType<T[P], Saml_relay_statesGroupByOutputType[P]>
        }
      >
    >


  export type saml_relay_statesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    request_id?: boolean
    for_email?: boolean
    redirect_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    flow_state_id?: boolean
    flow_state?: boolean | saml_relay_states$flow_stateArgs<ExtArgs>
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saml_relay_states"]>

  export type saml_relay_statesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    request_id?: boolean
    for_email?: boolean
    redirect_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    flow_state_id?: boolean
    flow_state?: boolean | saml_relay_states$flow_stateArgs<ExtArgs>
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saml_relay_states"]>

  export type saml_relay_statesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    request_id?: boolean
    for_email?: boolean
    redirect_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    flow_state_id?: boolean
    flow_state?: boolean | saml_relay_states$flow_stateArgs<ExtArgs>
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saml_relay_states"]>

  export type saml_relay_statesSelectScalar = {
    id?: boolean
    sso_provider_id?: boolean
    request_id?: boolean
    for_email?: boolean
    redirect_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    flow_state_id?: boolean
  }

  export type saml_relay_statesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sso_provider_id" | "request_id" | "for_email" | "redirect_to" | "created_at" | "updated_at" | "flow_state_id", ExtArgs["result"]["saml_relay_states"]>
  export type saml_relay_statesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow_state?: boolean | saml_relay_states$flow_stateArgs<ExtArgs>
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }
  export type saml_relay_statesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow_state?: boolean | saml_relay_states$flow_stateArgs<ExtArgs>
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }
  export type saml_relay_statesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow_state?: boolean | saml_relay_states$flow_stateArgs<ExtArgs>
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }

  export type $saml_relay_statesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saml_relay_states"
    objects: {
      flow_state: Prisma.$flow_statePayload<ExtArgs> | null
      sso_providers: Prisma.$sso_providersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sso_provider_id: string
      request_id: string
      for_email: string | null
      redirect_to: string | null
      created_at: Date | null
      updated_at: Date | null
      flow_state_id: string | null
    }, ExtArgs["result"]["saml_relay_states"]>
    composites: {}
  }

  type saml_relay_statesGetPayload<S extends boolean | null | undefined | saml_relay_statesDefaultArgs> = $Result.GetResult<Prisma.$saml_relay_statesPayload, S>

  type saml_relay_statesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saml_relay_statesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Saml_relay_statesCountAggregateInputType | true
    }

  export interface saml_relay_statesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saml_relay_states'], meta: { name: 'saml_relay_states' } }
    /**
     * Find zero or one Saml_relay_states that matches the filter.
     * @param {saml_relay_statesFindUniqueArgs} args - Arguments to find a Saml_relay_states
     * @example
     * // Get one Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saml_relay_statesFindUniqueArgs>(args: SelectSubset<T, saml_relay_statesFindUniqueArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saml_relay_states that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saml_relay_statesFindUniqueOrThrowArgs} args - Arguments to find a Saml_relay_states
     * @example
     * // Get one Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saml_relay_statesFindUniqueOrThrowArgs>(args: SelectSubset<T, saml_relay_statesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saml_relay_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_relay_statesFindFirstArgs} args - Arguments to find a Saml_relay_states
     * @example
     * // Get one Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saml_relay_statesFindFirstArgs>(args?: SelectSubset<T, saml_relay_statesFindFirstArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saml_relay_states that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_relay_statesFindFirstOrThrowArgs} args - Arguments to find a Saml_relay_states
     * @example
     * // Get one Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saml_relay_statesFindFirstOrThrowArgs>(args?: SelectSubset<T, saml_relay_statesFindFirstOrThrowArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saml_relay_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_relay_statesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.findMany()
     * 
     * // Get first 10 Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saml_relay_statesWithIdOnly = await prisma.saml_relay_states.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saml_relay_statesFindManyArgs>(args?: SelectSubset<T, saml_relay_statesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saml_relay_states.
     * @param {saml_relay_statesCreateArgs} args - Arguments to create a Saml_relay_states.
     * @example
     * // Create one Saml_relay_states
     * const Saml_relay_states = await prisma.saml_relay_states.create({
     *   data: {
     *     // ... data to create a Saml_relay_states
     *   }
     * })
     * 
     */
    create<T extends saml_relay_statesCreateArgs>(args: SelectSubset<T, saml_relay_statesCreateArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saml_relay_states.
     * @param {saml_relay_statesCreateManyArgs} args - Arguments to create many Saml_relay_states.
     * @example
     * // Create many Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saml_relay_statesCreateManyArgs>(args?: SelectSubset<T, saml_relay_statesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saml_relay_states and returns the data saved in the database.
     * @param {saml_relay_statesCreateManyAndReturnArgs} args - Arguments to create many Saml_relay_states.
     * @example
     * // Create many Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saml_relay_states and only return the `id`
     * const saml_relay_statesWithIdOnly = await prisma.saml_relay_states.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saml_relay_statesCreateManyAndReturnArgs>(args?: SelectSubset<T, saml_relay_statesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Saml_relay_states.
     * @param {saml_relay_statesDeleteArgs} args - Arguments to delete one Saml_relay_states.
     * @example
     * // Delete one Saml_relay_states
     * const Saml_relay_states = await prisma.saml_relay_states.delete({
     *   where: {
     *     // ... filter to delete one Saml_relay_states
     *   }
     * })
     * 
     */
    delete<T extends saml_relay_statesDeleteArgs>(args: SelectSubset<T, saml_relay_statesDeleteArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saml_relay_states.
     * @param {saml_relay_statesUpdateArgs} args - Arguments to update one Saml_relay_states.
     * @example
     * // Update one Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saml_relay_statesUpdateArgs>(args: SelectSubset<T, saml_relay_statesUpdateArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saml_relay_states.
     * @param {saml_relay_statesDeleteManyArgs} args - Arguments to filter Saml_relay_states to delete.
     * @example
     * // Delete a few Saml_relay_states
     * const { count } = await prisma.saml_relay_states.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saml_relay_statesDeleteManyArgs>(args?: SelectSubset<T, saml_relay_statesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saml_relay_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_relay_statesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saml_relay_statesUpdateManyArgs>(args: SelectSubset<T, saml_relay_statesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saml_relay_states and returns the data updated in the database.
     * @param {saml_relay_statesUpdateManyAndReturnArgs} args - Arguments to update many Saml_relay_states.
     * @example
     * // Update many Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Saml_relay_states and only return the `id`
     * const saml_relay_statesWithIdOnly = await prisma.saml_relay_states.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saml_relay_statesUpdateManyAndReturnArgs>(args: SelectSubset<T, saml_relay_statesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Saml_relay_states.
     * @param {saml_relay_statesUpsertArgs} args - Arguments to update or create a Saml_relay_states.
     * @example
     * // Update or create a Saml_relay_states
     * const saml_relay_states = await prisma.saml_relay_states.upsert({
     *   create: {
     *     // ... data to create a Saml_relay_states
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saml_relay_states we want to update
     *   }
     * })
     */
    upsert<T extends saml_relay_statesUpsertArgs>(args: SelectSubset<T, saml_relay_statesUpsertArgs<ExtArgs>>): Prisma__saml_relay_statesClient<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saml_relay_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_relay_statesCountArgs} args - Arguments to filter Saml_relay_states to count.
     * @example
     * // Count the number of Saml_relay_states
     * const count = await prisma.saml_relay_states.count({
     *   where: {
     *     // ... the filter for the Saml_relay_states we want to count
     *   }
     * })
    **/
    count<T extends saml_relay_statesCountArgs>(
      args?: Subset<T, saml_relay_statesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Saml_relay_statesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saml_relay_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Saml_relay_statesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Saml_relay_statesAggregateArgs>(args: Subset<T, Saml_relay_statesAggregateArgs>): Prisma.PrismaPromise<GetSaml_relay_statesAggregateType<T>>

    /**
     * Group by Saml_relay_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saml_relay_statesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saml_relay_statesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saml_relay_statesGroupByArgs['orderBy'] }
        : { orderBy?: saml_relay_statesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saml_relay_statesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaml_relay_statesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saml_relay_states model
   */
  readonly fields: saml_relay_statesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saml_relay_states.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saml_relay_statesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow_state<T extends saml_relay_states$flow_stateArgs<ExtArgs> = {}>(args?: Subset<T, saml_relay_states$flow_stateArgs<ExtArgs>>): Prisma__flow_stateClient<$Result.GetResult<Prisma.$flow_statePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sso_providers<T extends sso_providersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sso_providersDefaultArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saml_relay_states model
   */
  interface saml_relay_statesFieldRefs {
    readonly id: FieldRef<"saml_relay_states", 'String'>
    readonly sso_provider_id: FieldRef<"saml_relay_states", 'String'>
    readonly request_id: FieldRef<"saml_relay_states", 'String'>
    readonly for_email: FieldRef<"saml_relay_states", 'String'>
    readonly redirect_to: FieldRef<"saml_relay_states", 'String'>
    readonly created_at: FieldRef<"saml_relay_states", 'DateTime'>
    readonly updated_at: FieldRef<"saml_relay_states", 'DateTime'>
    readonly flow_state_id: FieldRef<"saml_relay_states", 'String'>
  }
    

  // Custom InputTypes
  /**
   * saml_relay_states findUnique
   */
  export type saml_relay_statesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * Filter, which saml_relay_states to fetch.
     */
    where: saml_relay_statesWhereUniqueInput
  }

  /**
   * saml_relay_states findUniqueOrThrow
   */
  export type saml_relay_statesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * Filter, which saml_relay_states to fetch.
     */
    where: saml_relay_statesWhereUniqueInput
  }

  /**
   * saml_relay_states findFirst
   */
  export type saml_relay_statesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * Filter, which saml_relay_states to fetch.
     */
    where?: saml_relay_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_relay_states to fetch.
     */
    orderBy?: saml_relay_statesOrderByWithRelationInput | saml_relay_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saml_relay_states.
     */
    cursor?: saml_relay_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_relay_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_relay_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saml_relay_states.
     */
    distinct?: Saml_relay_statesScalarFieldEnum | Saml_relay_statesScalarFieldEnum[]
  }

  /**
   * saml_relay_states findFirstOrThrow
   */
  export type saml_relay_statesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * Filter, which saml_relay_states to fetch.
     */
    where?: saml_relay_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_relay_states to fetch.
     */
    orderBy?: saml_relay_statesOrderByWithRelationInput | saml_relay_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saml_relay_states.
     */
    cursor?: saml_relay_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_relay_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_relay_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saml_relay_states.
     */
    distinct?: Saml_relay_statesScalarFieldEnum | Saml_relay_statesScalarFieldEnum[]
  }

  /**
   * saml_relay_states findMany
   */
  export type saml_relay_statesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * Filter, which saml_relay_states to fetch.
     */
    where?: saml_relay_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saml_relay_states to fetch.
     */
    orderBy?: saml_relay_statesOrderByWithRelationInput | saml_relay_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saml_relay_states.
     */
    cursor?: saml_relay_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saml_relay_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saml_relay_states.
     */
    skip?: number
    distinct?: Saml_relay_statesScalarFieldEnum | Saml_relay_statesScalarFieldEnum[]
  }

  /**
   * saml_relay_states create
   */
  export type saml_relay_statesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * The data needed to create a saml_relay_states.
     */
    data: XOR<saml_relay_statesCreateInput, saml_relay_statesUncheckedCreateInput>
  }

  /**
   * saml_relay_states createMany
   */
  export type saml_relay_statesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saml_relay_states.
     */
    data: saml_relay_statesCreateManyInput | saml_relay_statesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saml_relay_states createManyAndReturn
   */
  export type saml_relay_statesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * The data used to create many saml_relay_states.
     */
    data: saml_relay_statesCreateManyInput | saml_relay_statesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * saml_relay_states update
   */
  export type saml_relay_statesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * The data needed to update a saml_relay_states.
     */
    data: XOR<saml_relay_statesUpdateInput, saml_relay_statesUncheckedUpdateInput>
    /**
     * Choose, which saml_relay_states to update.
     */
    where: saml_relay_statesWhereUniqueInput
  }

  /**
   * saml_relay_states updateMany
   */
  export type saml_relay_statesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saml_relay_states.
     */
    data: XOR<saml_relay_statesUpdateManyMutationInput, saml_relay_statesUncheckedUpdateManyInput>
    /**
     * Filter which saml_relay_states to update
     */
    where?: saml_relay_statesWhereInput
    /**
     * Limit how many saml_relay_states to update.
     */
    limit?: number
  }

  /**
   * saml_relay_states updateManyAndReturn
   */
  export type saml_relay_statesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * The data used to update saml_relay_states.
     */
    data: XOR<saml_relay_statesUpdateManyMutationInput, saml_relay_statesUncheckedUpdateManyInput>
    /**
     * Filter which saml_relay_states to update
     */
    where?: saml_relay_statesWhereInput
    /**
     * Limit how many saml_relay_states to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * saml_relay_states upsert
   */
  export type saml_relay_statesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * The filter to search for the saml_relay_states to update in case it exists.
     */
    where: saml_relay_statesWhereUniqueInput
    /**
     * In case the saml_relay_states found by the `where` argument doesn't exist, create a new saml_relay_states with this data.
     */
    create: XOR<saml_relay_statesCreateInput, saml_relay_statesUncheckedCreateInput>
    /**
     * In case the saml_relay_states was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saml_relay_statesUpdateInput, saml_relay_statesUncheckedUpdateInput>
  }

  /**
   * saml_relay_states delete
   */
  export type saml_relay_statesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    /**
     * Filter which saml_relay_states to delete.
     */
    where: saml_relay_statesWhereUniqueInput
  }

  /**
   * saml_relay_states deleteMany
   */
  export type saml_relay_statesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saml_relay_states to delete
     */
    where?: saml_relay_statesWhereInput
    /**
     * Limit how many saml_relay_states to delete.
     */
    limit?: number
  }

  /**
   * saml_relay_states.flow_state
   */
  export type saml_relay_states$flow_stateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flow_state
     */
    select?: flow_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flow_state
     */
    omit?: flow_stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flow_stateInclude<ExtArgs> | null
    where?: flow_stateWhereInput
  }

  /**
   * saml_relay_states without action
   */
  export type saml_relay_statesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
  }


  /**
   * Model schema_migrations
   */

  export type AggregateSchema_migrations = {
    _count: Schema_migrationsCountAggregateOutputType | null
    _min: Schema_migrationsMinAggregateOutputType | null
    _max: Schema_migrationsMaxAggregateOutputType | null
  }

  export type Schema_migrationsMinAggregateOutputType = {
    version: string | null
  }

  export type Schema_migrationsMaxAggregateOutputType = {
    version: string | null
  }

  export type Schema_migrationsCountAggregateOutputType = {
    version: number
    _all: number
  }


  export type Schema_migrationsMinAggregateInputType = {
    version?: true
  }

  export type Schema_migrationsMaxAggregateInputType = {
    version?: true
  }

  export type Schema_migrationsCountAggregateInputType = {
    version?: true
    _all?: true
  }

  export type Schema_migrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_migrations to aggregate.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schema_migrations
    **/
    _count?: true | Schema_migrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Schema_migrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Schema_migrationsMaxAggregateInputType
  }

  export type GetSchema_migrationsAggregateType<T extends Schema_migrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateSchema_migrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchema_migrations[P]>
      : GetScalarType<T[P], AggregateSchema_migrations[P]>
  }




  export type schema_migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: schema_migrationsWhereInput
    orderBy?: schema_migrationsOrderByWithAggregationInput | schema_migrationsOrderByWithAggregationInput[]
    by: Schema_migrationsScalarFieldEnum[] | Schema_migrationsScalarFieldEnum
    having?: schema_migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Schema_migrationsCountAggregateInputType | true
    _min?: Schema_migrationsMinAggregateInputType
    _max?: Schema_migrationsMaxAggregateInputType
  }

  export type Schema_migrationsGroupByOutputType = {
    version: string
    _count: Schema_migrationsCountAggregateOutputType | null
    _min: Schema_migrationsMinAggregateOutputType | null
    _max: Schema_migrationsMaxAggregateOutputType | null
  }

  type GetSchema_migrationsGroupByPayload<T extends schema_migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Schema_migrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Schema_migrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Schema_migrationsGroupByOutputType[P]>
            : GetScalarType<T[P], Schema_migrationsGroupByOutputType[P]>
        }
      >
    >


  export type schema_migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectScalar = {
    version?: boolean
  }

  export type schema_migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"version", ExtArgs["result"]["schema_migrations"]>

  export type $schema_migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "schema_migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      version: string
    }, ExtArgs["result"]["schema_migrations"]>
    composites: {}
  }

  type schema_migrationsGetPayload<S extends boolean | null | undefined | schema_migrationsDefaultArgs> = $Result.GetResult<Prisma.$schema_migrationsPayload, S>

  type schema_migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<schema_migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Schema_migrationsCountAggregateInputType | true
    }

  export interface schema_migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['schema_migrations'], meta: { name: 'schema_migrations' } }
    /**
     * Find zero or one Schema_migrations that matches the filter.
     * @param {schema_migrationsFindUniqueArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends schema_migrationsFindUniqueArgs>(args: SelectSubset<T, schema_migrationsFindUniqueArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schema_migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {schema_migrationsFindUniqueOrThrowArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends schema_migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, schema_migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schema_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindFirstArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends schema_migrationsFindFirstArgs>(args?: SelectSubset<T, schema_migrationsFindFirstArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schema_migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindFirstOrThrowArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends schema_migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, schema_migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schema_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findMany()
     * 
     * // Get first 10 Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.findMany({ select: { version: true } })
     * 
     */
    findMany<T extends schema_migrationsFindManyArgs>(args?: SelectSubset<T, schema_migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schema_migrations.
     * @param {schema_migrationsCreateArgs} args - Arguments to create a Schema_migrations.
     * @example
     * // Create one Schema_migrations
     * const Schema_migrations = await prisma.schema_migrations.create({
     *   data: {
     *     // ... data to create a Schema_migrations
     *   }
     * })
     * 
     */
    create<T extends schema_migrationsCreateArgs>(args: SelectSubset<T, schema_migrationsCreateArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schema_migrations.
     * @param {schema_migrationsCreateManyArgs} args - Arguments to create many Schema_migrations.
     * @example
     * // Create many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends schema_migrationsCreateManyArgs>(args?: SelectSubset<T, schema_migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schema_migrations and returns the data saved in the database.
     * @param {schema_migrationsCreateManyAndReturnArgs} args - Arguments to create many Schema_migrations.
     * @example
     * // Create many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schema_migrations and only return the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.createManyAndReturn({
     *   select: { version: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends schema_migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, schema_migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schema_migrations.
     * @param {schema_migrationsDeleteArgs} args - Arguments to delete one Schema_migrations.
     * @example
     * // Delete one Schema_migrations
     * const Schema_migrations = await prisma.schema_migrations.delete({
     *   where: {
     *     // ... filter to delete one Schema_migrations
     *   }
     * })
     * 
     */
    delete<T extends schema_migrationsDeleteArgs>(args: SelectSubset<T, schema_migrationsDeleteArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schema_migrations.
     * @param {schema_migrationsUpdateArgs} args - Arguments to update one Schema_migrations.
     * @example
     * // Update one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends schema_migrationsUpdateArgs>(args: SelectSubset<T, schema_migrationsUpdateArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schema_migrations.
     * @param {schema_migrationsDeleteManyArgs} args - Arguments to filter Schema_migrations to delete.
     * @example
     * // Delete a few Schema_migrations
     * const { count } = await prisma.schema_migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends schema_migrationsDeleteManyArgs>(args?: SelectSubset<T, schema_migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends schema_migrationsUpdateManyArgs>(args: SelectSubset<T, schema_migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_migrations and returns the data updated in the database.
     * @param {schema_migrationsUpdateManyAndReturnArgs} args - Arguments to update many Schema_migrations.
     * @example
     * // Update many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schema_migrations and only return the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.updateManyAndReturn({
     *   select: { version: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends schema_migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, schema_migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schema_migrations.
     * @param {schema_migrationsUpsertArgs} args - Arguments to update or create a Schema_migrations.
     * @example
     * // Update or create a Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.upsert({
     *   create: {
     *     // ... data to create a Schema_migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schema_migrations we want to update
     *   }
     * })
     */
    upsert<T extends schema_migrationsUpsertArgs>(args: SelectSubset<T, schema_migrationsUpsertArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsCountArgs} args - Arguments to filter Schema_migrations to count.
     * @example
     * // Count the number of Schema_migrations
     * const count = await prisma.schema_migrations.count({
     *   where: {
     *     // ... the filter for the Schema_migrations we want to count
     *   }
     * })
    **/
    count<T extends schema_migrationsCountArgs>(
      args?: Subset<T, schema_migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Schema_migrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Schema_migrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Schema_migrationsAggregateArgs>(args: Subset<T, Schema_migrationsAggregateArgs>): Prisma.PrismaPromise<GetSchema_migrationsAggregateType<T>>

    /**
     * Group by Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends schema_migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: schema_migrationsGroupByArgs['orderBy'] }
        : { orderBy?: schema_migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, schema_migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchema_migrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the schema_migrations model
   */
  readonly fields: schema_migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for schema_migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__schema_migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the schema_migrations model
   */
  interface schema_migrationsFieldRefs {
    readonly version: FieldRef<"schema_migrations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * schema_migrations findUnique
   */
  export type schema_migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations findUniqueOrThrow
   */
  export type schema_migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations findFirst
   */
  export type schema_migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_migrations.
     */
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations findFirstOrThrow
   */
  export type schema_migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_migrations.
     */
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations findMany
   */
  export type schema_migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations create
   */
  export type schema_migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a schema_migrations.
     */
    data: XOR<schema_migrationsCreateInput, schema_migrationsUncheckedCreateInput>
  }

  /**
   * schema_migrations createMany
   */
  export type schema_migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schema_migrations.
     */
    data: schema_migrationsCreateManyInput | schema_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_migrations createManyAndReturn
   */
  export type schema_migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many schema_migrations.
     */
    data: schema_migrationsCreateManyInput | schema_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_migrations update
   */
  export type schema_migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a schema_migrations.
     */
    data: XOR<schema_migrationsUpdateInput, schema_migrationsUncheckedUpdateInput>
    /**
     * Choose, which schema_migrations to update.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations updateMany
   */
  export type schema_migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schema_migrations.
     */
    data: XOR<schema_migrationsUpdateManyMutationInput, schema_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which schema_migrations to update
     */
    where?: schema_migrationsWhereInput
    /**
     * Limit how many schema_migrations to update.
     */
    limit?: number
  }

  /**
   * schema_migrations updateManyAndReturn
   */
  export type schema_migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data used to update schema_migrations.
     */
    data: XOR<schema_migrationsUpdateManyMutationInput, schema_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which schema_migrations to update
     */
    where?: schema_migrationsWhereInput
    /**
     * Limit how many schema_migrations to update.
     */
    limit?: number
  }

  /**
   * schema_migrations upsert
   */
  export type schema_migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the schema_migrations to update in case it exists.
     */
    where: schema_migrationsWhereUniqueInput
    /**
     * In case the schema_migrations found by the `where` argument doesn't exist, create a new schema_migrations with this data.
     */
    create: XOR<schema_migrationsCreateInput, schema_migrationsUncheckedCreateInput>
    /**
     * In case the schema_migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schema_migrationsUpdateInput, schema_migrationsUncheckedUpdateInput>
  }

  /**
   * schema_migrations delete
   */
  export type schema_migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter which schema_migrations to delete.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations deleteMany
   */
  export type schema_migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_migrations to delete
     */
    where?: schema_migrationsWhereInput
    /**
     * Limit how many schema_migrations to delete.
     */
    limit?: number
  }

  /**
   * schema_migrations without action
   */
  export type schema_migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
    factor_id: string | null
    aal: $Enums.aal_level | null
    not_after: Date | null
    refreshed_at: Date | null
    user_agent: string | null
    ip: string | null
    tag: string | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
    factor_id: string | null
    aal: $Enums.aal_level | null
    not_after: Date | null
    refreshed_at: Date | null
    user_agent: string | null
    ip: string | null
    tag: string | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    user_id: number
    created_at: number
    updated_at: number
    factor_id: number
    aal: number
    not_after: number
    refreshed_at: number
    user_agent: number
    ip: number
    tag: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    factor_id?: true
    aal?: true
    not_after?: true
    refreshed_at?: true
    user_agent?: true
    ip?: true
    tag?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    factor_id?: true
    aal?: true
    not_after?: true
    refreshed_at?: true
    user_agent?: true
    ip?: true
    tag?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    factor_id?: true
    aal?: true
    not_after?: true
    refreshed_at?: true
    user_agent?: true
    ip?: true
    tag?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    user_id: string
    created_at: Date | null
    updated_at: Date | null
    factor_id: string | null
    aal: $Enums.aal_level | null
    not_after: Date | null
    refreshed_at: Date | null
    user_agent: string | null
    ip: string | null
    tag: string | null
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    factor_id?: boolean
    aal?: boolean
    not_after?: boolean
    refreshed_at?: boolean
    user_agent?: boolean
    ip?: boolean
    tag?: boolean
    mfa_amr_claims?: boolean | sessions$mfa_amr_claimsArgs<ExtArgs>
    refresh_tokens?: boolean | sessions$refresh_tokensArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    factor_id?: boolean
    aal?: boolean
    not_after?: boolean
    refreshed_at?: boolean
    user_agent?: boolean
    ip?: boolean
    tag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    factor_id?: boolean
    aal?: boolean
    not_after?: boolean
    refreshed_at?: boolean
    user_agent?: boolean
    ip?: boolean
    tag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    factor_id?: boolean
    aal?: boolean
    not_after?: boolean
    refreshed_at?: boolean
    user_agent?: boolean
    ip?: boolean
    tag?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "created_at" | "updated_at" | "factor_id" | "aal" | "not_after" | "refreshed_at" | "user_agent" | "ip" | "tag", ExtArgs["result"]["sessions"]>
  export type sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa_amr_claims?: boolean | sessions$mfa_amr_claimsArgs<ExtArgs>
    refresh_tokens?: boolean | sessions$refresh_tokensArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {
      mfa_amr_claims: Prisma.$mfa_amr_claimsPayload<ExtArgs>[]
      refresh_tokens: Prisma.$refresh_tokensPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      created_at: Date | null
      updated_at: Date | null
      factor_id: string | null
      aal: $Enums.aal_level | null
      not_after: Date | null
      refreshed_at: Date | null
      user_agent: string | null
      ip: string | null
      tag: string | null
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionsCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionsUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mfa_amr_claims<T extends sessions$mfa_amr_claimsArgs<ExtArgs> = {}>(args?: Subset<T, sessions$mfa_amr_claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_amr_claimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refresh_tokens<T extends sessions$refresh_tokensArgs<ExtArgs> = {}>(args?: Subset<T, sessions$refresh_tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly user_id: FieldRef<"sessions", 'String'>
    readonly created_at: FieldRef<"sessions", 'DateTime'>
    readonly updated_at: FieldRef<"sessions", 'DateTime'>
    readonly factor_id: FieldRef<"sessions", 'String'>
    readonly aal: FieldRef<"sessions", 'aal_level'>
    readonly not_after: FieldRef<"sessions", 'DateTime'>
    readonly refreshed_at: FieldRef<"sessions", 'DateTime'>
    readonly user_agent: FieldRef<"sessions", 'String'>
    readonly ip: FieldRef<"sessions", 'String'>
    readonly tag: FieldRef<"sessions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions createManyAndReturn
   */
  export type sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions updateManyAndReturn
   */
  export type sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions.mfa_amr_claims
   */
  export type sessions$mfa_amr_claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_amr_claims
     */
    select?: mfa_amr_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_amr_claims
     */
    omit?: mfa_amr_claimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_amr_claimsInclude<ExtArgs> | null
    where?: mfa_amr_claimsWhereInput
    orderBy?: mfa_amr_claimsOrderByWithRelationInput | mfa_amr_claimsOrderByWithRelationInput[]
    cursor?: mfa_amr_claimsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mfa_amr_claimsScalarFieldEnum | Mfa_amr_claimsScalarFieldEnum[]
  }

  /**
   * sessions.refresh_tokens
   */
  export type sessions$refresh_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    where?: refresh_tokensWhereInput
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    cursor?: refresh_tokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
  }


  /**
   * Model sso_domains
   */

  export type AggregateSso_domains = {
    _count: Sso_domainsCountAggregateOutputType | null
    _min: Sso_domainsMinAggregateOutputType | null
    _max: Sso_domainsMaxAggregateOutputType | null
  }

  export type Sso_domainsMinAggregateOutputType = {
    id: string | null
    sso_provider_id: string | null
    domain: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Sso_domainsMaxAggregateOutputType = {
    id: string | null
    sso_provider_id: string | null
    domain: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Sso_domainsCountAggregateOutputType = {
    id: number
    sso_provider_id: number
    domain: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Sso_domainsMinAggregateInputType = {
    id?: true
    sso_provider_id?: true
    domain?: true
    created_at?: true
    updated_at?: true
  }

  export type Sso_domainsMaxAggregateInputType = {
    id?: true
    sso_provider_id?: true
    domain?: true
    created_at?: true
    updated_at?: true
  }

  export type Sso_domainsCountAggregateInputType = {
    id?: true
    sso_provider_id?: true
    domain?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Sso_domainsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sso_domains to aggregate.
     */
    where?: sso_domainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_domains to fetch.
     */
    orderBy?: sso_domainsOrderByWithRelationInput | sso_domainsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sso_domainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sso_domains
    **/
    _count?: true | Sso_domainsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sso_domainsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sso_domainsMaxAggregateInputType
  }

  export type GetSso_domainsAggregateType<T extends Sso_domainsAggregateArgs> = {
        [P in keyof T & keyof AggregateSso_domains]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSso_domains[P]>
      : GetScalarType<T[P], AggregateSso_domains[P]>
  }




  export type sso_domainsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sso_domainsWhereInput
    orderBy?: sso_domainsOrderByWithAggregationInput | sso_domainsOrderByWithAggregationInput[]
    by: Sso_domainsScalarFieldEnum[] | Sso_domainsScalarFieldEnum
    having?: sso_domainsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sso_domainsCountAggregateInputType | true
    _min?: Sso_domainsMinAggregateInputType
    _max?: Sso_domainsMaxAggregateInputType
  }

  export type Sso_domainsGroupByOutputType = {
    id: string
    sso_provider_id: string
    domain: string
    created_at: Date | null
    updated_at: Date | null
    _count: Sso_domainsCountAggregateOutputType | null
    _min: Sso_domainsMinAggregateOutputType | null
    _max: Sso_domainsMaxAggregateOutputType | null
  }

  type GetSso_domainsGroupByPayload<T extends sso_domainsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sso_domainsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sso_domainsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sso_domainsGroupByOutputType[P]>
            : GetScalarType<T[P], Sso_domainsGroupByOutputType[P]>
        }
      >
    >


  export type sso_domainsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    domain?: boolean
    created_at?: boolean
    updated_at?: boolean
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sso_domains"]>

  export type sso_domainsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    domain?: boolean
    created_at?: boolean
    updated_at?: boolean
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sso_domains"]>

  export type sso_domainsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sso_provider_id?: boolean
    domain?: boolean
    created_at?: boolean
    updated_at?: boolean
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sso_domains"]>

  export type sso_domainsSelectScalar = {
    id?: boolean
    sso_provider_id?: boolean
    domain?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type sso_domainsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sso_provider_id" | "domain" | "created_at" | "updated_at", ExtArgs["result"]["sso_domains"]>
  export type sso_domainsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }
  export type sso_domainsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }
  export type sso_domainsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sso_providers?: boolean | sso_providersDefaultArgs<ExtArgs>
  }

  export type $sso_domainsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sso_domains"
    objects: {
      sso_providers: Prisma.$sso_providersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sso_provider_id: string
      domain: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["sso_domains"]>
    composites: {}
  }

  type sso_domainsGetPayload<S extends boolean | null | undefined | sso_domainsDefaultArgs> = $Result.GetResult<Prisma.$sso_domainsPayload, S>

  type sso_domainsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sso_domainsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sso_domainsCountAggregateInputType | true
    }

  export interface sso_domainsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sso_domains'], meta: { name: 'sso_domains' } }
    /**
     * Find zero or one Sso_domains that matches the filter.
     * @param {sso_domainsFindUniqueArgs} args - Arguments to find a Sso_domains
     * @example
     * // Get one Sso_domains
     * const sso_domains = await prisma.sso_domains.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sso_domainsFindUniqueArgs>(args: SelectSubset<T, sso_domainsFindUniqueArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sso_domains that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sso_domainsFindUniqueOrThrowArgs} args - Arguments to find a Sso_domains
     * @example
     * // Get one Sso_domains
     * const sso_domains = await prisma.sso_domains.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sso_domainsFindUniqueOrThrowArgs>(args: SelectSubset<T, sso_domainsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sso_domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_domainsFindFirstArgs} args - Arguments to find a Sso_domains
     * @example
     * // Get one Sso_domains
     * const sso_domains = await prisma.sso_domains.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sso_domainsFindFirstArgs>(args?: SelectSubset<T, sso_domainsFindFirstArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sso_domains that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_domainsFindFirstOrThrowArgs} args - Arguments to find a Sso_domains
     * @example
     * // Get one Sso_domains
     * const sso_domains = await prisma.sso_domains.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sso_domainsFindFirstOrThrowArgs>(args?: SelectSubset<T, sso_domainsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sso_domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_domainsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sso_domains
     * const sso_domains = await prisma.sso_domains.findMany()
     * 
     * // Get first 10 Sso_domains
     * const sso_domains = await prisma.sso_domains.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sso_domainsWithIdOnly = await prisma.sso_domains.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sso_domainsFindManyArgs>(args?: SelectSubset<T, sso_domainsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sso_domains.
     * @param {sso_domainsCreateArgs} args - Arguments to create a Sso_domains.
     * @example
     * // Create one Sso_domains
     * const Sso_domains = await prisma.sso_domains.create({
     *   data: {
     *     // ... data to create a Sso_domains
     *   }
     * })
     * 
     */
    create<T extends sso_domainsCreateArgs>(args: SelectSubset<T, sso_domainsCreateArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sso_domains.
     * @param {sso_domainsCreateManyArgs} args - Arguments to create many Sso_domains.
     * @example
     * // Create many Sso_domains
     * const sso_domains = await prisma.sso_domains.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sso_domainsCreateManyArgs>(args?: SelectSubset<T, sso_domainsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sso_domains and returns the data saved in the database.
     * @param {sso_domainsCreateManyAndReturnArgs} args - Arguments to create many Sso_domains.
     * @example
     * // Create many Sso_domains
     * const sso_domains = await prisma.sso_domains.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sso_domains and only return the `id`
     * const sso_domainsWithIdOnly = await prisma.sso_domains.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sso_domainsCreateManyAndReturnArgs>(args?: SelectSubset<T, sso_domainsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sso_domains.
     * @param {sso_domainsDeleteArgs} args - Arguments to delete one Sso_domains.
     * @example
     * // Delete one Sso_domains
     * const Sso_domains = await prisma.sso_domains.delete({
     *   where: {
     *     // ... filter to delete one Sso_domains
     *   }
     * })
     * 
     */
    delete<T extends sso_domainsDeleteArgs>(args: SelectSubset<T, sso_domainsDeleteArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sso_domains.
     * @param {sso_domainsUpdateArgs} args - Arguments to update one Sso_domains.
     * @example
     * // Update one Sso_domains
     * const sso_domains = await prisma.sso_domains.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sso_domainsUpdateArgs>(args: SelectSubset<T, sso_domainsUpdateArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sso_domains.
     * @param {sso_domainsDeleteManyArgs} args - Arguments to filter Sso_domains to delete.
     * @example
     * // Delete a few Sso_domains
     * const { count } = await prisma.sso_domains.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sso_domainsDeleteManyArgs>(args?: SelectSubset<T, sso_domainsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sso_domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_domainsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sso_domains
     * const sso_domains = await prisma.sso_domains.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sso_domainsUpdateManyArgs>(args: SelectSubset<T, sso_domainsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sso_domains and returns the data updated in the database.
     * @param {sso_domainsUpdateManyAndReturnArgs} args - Arguments to update many Sso_domains.
     * @example
     * // Update many Sso_domains
     * const sso_domains = await prisma.sso_domains.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sso_domains and only return the `id`
     * const sso_domainsWithIdOnly = await prisma.sso_domains.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sso_domainsUpdateManyAndReturnArgs>(args: SelectSubset<T, sso_domainsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sso_domains.
     * @param {sso_domainsUpsertArgs} args - Arguments to update or create a Sso_domains.
     * @example
     * // Update or create a Sso_domains
     * const sso_domains = await prisma.sso_domains.upsert({
     *   create: {
     *     // ... data to create a Sso_domains
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sso_domains we want to update
     *   }
     * })
     */
    upsert<T extends sso_domainsUpsertArgs>(args: SelectSubset<T, sso_domainsUpsertArgs<ExtArgs>>): Prisma__sso_domainsClient<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sso_domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_domainsCountArgs} args - Arguments to filter Sso_domains to count.
     * @example
     * // Count the number of Sso_domains
     * const count = await prisma.sso_domains.count({
     *   where: {
     *     // ... the filter for the Sso_domains we want to count
     *   }
     * })
    **/
    count<T extends sso_domainsCountArgs>(
      args?: Subset<T, sso_domainsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sso_domainsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sso_domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sso_domainsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sso_domainsAggregateArgs>(args: Subset<T, Sso_domainsAggregateArgs>): Prisma.PrismaPromise<GetSso_domainsAggregateType<T>>

    /**
     * Group by Sso_domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_domainsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sso_domainsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sso_domainsGroupByArgs['orderBy'] }
        : { orderBy?: sso_domainsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sso_domainsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSso_domainsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sso_domains model
   */
  readonly fields: sso_domainsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sso_domains.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sso_domainsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sso_providers<T extends sso_providersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sso_providersDefaultArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sso_domains model
   */
  interface sso_domainsFieldRefs {
    readonly id: FieldRef<"sso_domains", 'String'>
    readonly sso_provider_id: FieldRef<"sso_domains", 'String'>
    readonly domain: FieldRef<"sso_domains", 'String'>
    readonly created_at: FieldRef<"sso_domains", 'DateTime'>
    readonly updated_at: FieldRef<"sso_domains", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sso_domains findUnique
   */
  export type sso_domainsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * Filter, which sso_domains to fetch.
     */
    where: sso_domainsWhereUniqueInput
  }

  /**
   * sso_domains findUniqueOrThrow
   */
  export type sso_domainsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * Filter, which sso_domains to fetch.
     */
    where: sso_domainsWhereUniqueInput
  }

  /**
   * sso_domains findFirst
   */
  export type sso_domainsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * Filter, which sso_domains to fetch.
     */
    where?: sso_domainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_domains to fetch.
     */
    orderBy?: sso_domainsOrderByWithRelationInput | sso_domainsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sso_domains.
     */
    cursor?: sso_domainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sso_domains.
     */
    distinct?: Sso_domainsScalarFieldEnum | Sso_domainsScalarFieldEnum[]
  }

  /**
   * sso_domains findFirstOrThrow
   */
  export type sso_domainsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * Filter, which sso_domains to fetch.
     */
    where?: sso_domainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_domains to fetch.
     */
    orderBy?: sso_domainsOrderByWithRelationInput | sso_domainsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sso_domains.
     */
    cursor?: sso_domainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sso_domains.
     */
    distinct?: Sso_domainsScalarFieldEnum | Sso_domainsScalarFieldEnum[]
  }

  /**
   * sso_domains findMany
   */
  export type sso_domainsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * Filter, which sso_domains to fetch.
     */
    where?: sso_domainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_domains to fetch.
     */
    orderBy?: sso_domainsOrderByWithRelationInput | sso_domainsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sso_domains.
     */
    cursor?: sso_domainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_domains.
     */
    skip?: number
    distinct?: Sso_domainsScalarFieldEnum | Sso_domainsScalarFieldEnum[]
  }

  /**
   * sso_domains create
   */
  export type sso_domainsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * The data needed to create a sso_domains.
     */
    data: XOR<sso_domainsCreateInput, sso_domainsUncheckedCreateInput>
  }

  /**
   * sso_domains createMany
   */
  export type sso_domainsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sso_domains.
     */
    data: sso_domainsCreateManyInput | sso_domainsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sso_domains createManyAndReturn
   */
  export type sso_domainsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * The data used to create many sso_domains.
     */
    data: sso_domainsCreateManyInput | sso_domainsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sso_domains update
   */
  export type sso_domainsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * The data needed to update a sso_domains.
     */
    data: XOR<sso_domainsUpdateInput, sso_domainsUncheckedUpdateInput>
    /**
     * Choose, which sso_domains to update.
     */
    where: sso_domainsWhereUniqueInput
  }

  /**
   * sso_domains updateMany
   */
  export type sso_domainsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sso_domains.
     */
    data: XOR<sso_domainsUpdateManyMutationInput, sso_domainsUncheckedUpdateManyInput>
    /**
     * Filter which sso_domains to update
     */
    where?: sso_domainsWhereInput
    /**
     * Limit how many sso_domains to update.
     */
    limit?: number
  }

  /**
   * sso_domains updateManyAndReturn
   */
  export type sso_domainsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * The data used to update sso_domains.
     */
    data: XOR<sso_domainsUpdateManyMutationInput, sso_domainsUncheckedUpdateManyInput>
    /**
     * Filter which sso_domains to update
     */
    where?: sso_domainsWhereInput
    /**
     * Limit how many sso_domains to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sso_domains upsert
   */
  export type sso_domainsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * The filter to search for the sso_domains to update in case it exists.
     */
    where: sso_domainsWhereUniqueInput
    /**
     * In case the sso_domains found by the `where` argument doesn't exist, create a new sso_domains with this data.
     */
    create: XOR<sso_domainsCreateInput, sso_domainsUncheckedCreateInput>
    /**
     * In case the sso_domains was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sso_domainsUpdateInput, sso_domainsUncheckedUpdateInput>
  }

  /**
   * sso_domains delete
   */
  export type sso_domainsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    /**
     * Filter which sso_domains to delete.
     */
    where: sso_domainsWhereUniqueInput
  }

  /**
   * sso_domains deleteMany
   */
  export type sso_domainsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sso_domains to delete
     */
    where?: sso_domainsWhereInput
    /**
     * Limit how many sso_domains to delete.
     */
    limit?: number
  }

  /**
   * sso_domains without action
   */
  export type sso_domainsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
  }


  /**
   * Model sso_providers
   */

  export type AggregateSso_providers = {
    _count: Sso_providersCountAggregateOutputType | null
    _min: Sso_providersMinAggregateOutputType | null
    _max: Sso_providersMaxAggregateOutputType | null
  }

  export type Sso_providersMinAggregateOutputType = {
    id: string | null
    resource_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Sso_providersMaxAggregateOutputType = {
    id: string | null
    resource_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Sso_providersCountAggregateOutputType = {
    id: number
    resource_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Sso_providersMinAggregateInputType = {
    id?: true
    resource_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Sso_providersMaxAggregateInputType = {
    id?: true
    resource_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Sso_providersCountAggregateInputType = {
    id?: true
    resource_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Sso_providersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sso_providers to aggregate.
     */
    where?: sso_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_providers to fetch.
     */
    orderBy?: sso_providersOrderByWithRelationInput | sso_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sso_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sso_providers
    **/
    _count?: true | Sso_providersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sso_providersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sso_providersMaxAggregateInputType
  }

  export type GetSso_providersAggregateType<T extends Sso_providersAggregateArgs> = {
        [P in keyof T & keyof AggregateSso_providers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSso_providers[P]>
      : GetScalarType<T[P], AggregateSso_providers[P]>
  }




  export type sso_providersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sso_providersWhereInput
    orderBy?: sso_providersOrderByWithAggregationInput | sso_providersOrderByWithAggregationInput[]
    by: Sso_providersScalarFieldEnum[] | Sso_providersScalarFieldEnum
    having?: sso_providersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sso_providersCountAggregateInputType | true
    _min?: Sso_providersMinAggregateInputType
    _max?: Sso_providersMaxAggregateInputType
  }

  export type Sso_providersGroupByOutputType = {
    id: string
    resource_id: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Sso_providersCountAggregateOutputType | null
    _min: Sso_providersMinAggregateOutputType | null
    _max: Sso_providersMaxAggregateOutputType | null
  }

  type GetSso_providersGroupByPayload<T extends sso_providersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sso_providersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sso_providersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sso_providersGroupByOutputType[P]>
            : GetScalarType<T[P], Sso_providersGroupByOutputType[P]>
        }
      >
    >


  export type sso_providersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resource_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    saml_providers?: boolean | sso_providers$saml_providersArgs<ExtArgs>
    saml_relay_states?: boolean | sso_providers$saml_relay_statesArgs<ExtArgs>
    sso_domains?: boolean | sso_providers$sso_domainsArgs<ExtArgs>
    _count?: boolean | Sso_providersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sso_providers"]>

  export type sso_providersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resource_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["sso_providers"]>

  export type sso_providersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resource_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["sso_providers"]>

  export type sso_providersSelectScalar = {
    id?: boolean
    resource_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type sso_providersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resource_id" | "created_at" | "updated_at", ExtArgs["result"]["sso_providers"]>
  export type sso_providersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saml_providers?: boolean | sso_providers$saml_providersArgs<ExtArgs>
    saml_relay_states?: boolean | sso_providers$saml_relay_statesArgs<ExtArgs>
    sso_domains?: boolean | sso_providers$sso_domainsArgs<ExtArgs>
    _count?: boolean | Sso_providersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sso_providersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type sso_providersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $sso_providersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sso_providers"
    objects: {
      saml_providers: Prisma.$saml_providersPayload<ExtArgs>[]
      saml_relay_states: Prisma.$saml_relay_statesPayload<ExtArgs>[]
      sso_domains: Prisma.$sso_domainsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resource_id: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["sso_providers"]>
    composites: {}
  }

  type sso_providersGetPayload<S extends boolean | null | undefined | sso_providersDefaultArgs> = $Result.GetResult<Prisma.$sso_providersPayload, S>

  type sso_providersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sso_providersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sso_providersCountAggregateInputType | true
    }

  export interface sso_providersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sso_providers'], meta: { name: 'sso_providers' } }
    /**
     * Find zero or one Sso_providers that matches the filter.
     * @param {sso_providersFindUniqueArgs} args - Arguments to find a Sso_providers
     * @example
     * // Get one Sso_providers
     * const sso_providers = await prisma.sso_providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sso_providersFindUniqueArgs>(args: SelectSubset<T, sso_providersFindUniqueArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sso_providers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sso_providersFindUniqueOrThrowArgs} args - Arguments to find a Sso_providers
     * @example
     * // Get one Sso_providers
     * const sso_providers = await prisma.sso_providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sso_providersFindUniqueOrThrowArgs>(args: SelectSubset<T, sso_providersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sso_providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_providersFindFirstArgs} args - Arguments to find a Sso_providers
     * @example
     * // Get one Sso_providers
     * const sso_providers = await prisma.sso_providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sso_providersFindFirstArgs>(args?: SelectSubset<T, sso_providersFindFirstArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sso_providers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_providersFindFirstOrThrowArgs} args - Arguments to find a Sso_providers
     * @example
     * // Get one Sso_providers
     * const sso_providers = await prisma.sso_providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sso_providersFindFirstOrThrowArgs>(args?: SelectSubset<T, sso_providersFindFirstOrThrowArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sso_providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_providersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sso_providers
     * const sso_providers = await prisma.sso_providers.findMany()
     * 
     * // Get first 10 Sso_providers
     * const sso_providers = await prisma.sso_providers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sso_providersWithIdOnly = await prisma.sso_providers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sso_providersFindManyArgs>(args?: SelectSubset<T, sso_providersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sso_providers.
     * @param {sso_providersCreateArgs} args - Arguments to create a Sso_providers.
     * @example
     * // Create one Sso_providers
     * const Sso_providers = await prisma.sso_providers.create({
     *   data: {
     *     // ... data to create a Sso_providers
     *   }
     * })
     * 
     */
    create<T extends sso_providersCreateArgs>(args: SelectSubset<T, sso_providersCreateArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sso_providers.
     * @param {sso_providersCreateManyArgs} args - Arguments to create many Sso_providers.
     * @example
     * // Create many Sso_providers
     * const sso_providers = await prisma.sso_providers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sso_providersCreateManyArgs>(args?: SelectSubset<T, sso_providersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sso_providers and returns the data saved in the database.
     * @param {sso_providersCreateManyAndReturnArgs} args - Arguments to create many Sso_providers.
     * @example
     * // Create many Sso_providers
     * const sso_providers = await prisma.sso_providers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sso_providers and only return the `id`
     * const sso_providersWithIdOnly = await prisma.sso_providers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sso_providersCreateManyAndReturnArgs>(args?: SelectSubset<T, sso_providersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sso_providers.
     * @param {sso_providersDeleteArgs} args - Arguments to delete one Sso_providers.
     * @example
     * // Delete one Sso_providers
     * const Sso_providers = await prisma.sso_providers.delete({
     *   where: {
     *     // ... filter to delete one Sso_providers
     *   }
     * })
     * 
     */
    delete<T extends sso_providersDeleteArgs>(args: SelectSubset<T, sso_providersDeleteArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sso_providers.
     * @param {sso_providersUpdateArgs} args - Arguments to update one Sso_providers.
     * @example
     * // Update one Sso_providers
     * const sso_providers = await prisma.sso_providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sso_providersUpdateArgs>(args: SelectSubset<T, sso_providersUpdateArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sso_providers.
     * @param {sso_providersDeleteManyArgs} args - Arguments to filter Sso_providers to delete.
     * @example
     * // Delete a few Sso_providers
     * const { count } = await prisma.sso_providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sso_providersDeleteManyArgs>(args?: SelectSubset<T, sso_providersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sso_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_providersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sso_providers
     * const sso_providers = await prisma.sso_providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sso_providersUpdateManyArgs>(args: SelectSubset<T, sso_providersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sso_providers and returns the data updated in the database.
     * @param {sso_providersUpdateManyAndReturnArgs} args - Arguments to update many Sso_providers.
     * @example
     * // Update many Sso_providers
     * const sso_providers = await prisma.sso_providers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sso_providers and only return the `id`
     * const sso_providersWithIdOnly = await prisma.sso_providers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sso_providersUpdateManyAndReturnArgs>(args: SelectSubset<T, sso_providersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sso_providers.
     * @param {sso_providersUpsertArgs} args - Arguments to update or create a Sso_providers.
     * @example
     * // Update or create a Sso_providers
     * const sso_providers = await prisma.sso_providers.upsert({
     *   create: {
     *     // ... data to create a Sso_providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sso_providers we want to update
     *   }
     * })
     */
    upsert<T extends sso_providersUpsertArgs>(args: SelectSubset<T, sso_providersUpsertArgs<ExtArgs>>): Prisma__sso_providersClient<$Result.GetResult<Prisma.$sso_providersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sso_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_providersCountArgs} args - Arguments to filter Sso_providers to count.
     * @example
     * // Count the number of Sso_providers
     * const count = await prisma.sso_providers.count({
     *   where: {
     *     // ... the filter for the Sso_providers we want to count
     *   }
     * })
    **/
    count<T extends sso_providersCountArgs>(
      args?: Subset<T, sso_providersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sso_providersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sso_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sso_providersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sso_providersAggregateArgs>(args: Subset<T, Sso_providersAggregateArgs>): Prisma.PrismaPromise<GetSso_providersAggregateType<T>>

    /**
     * Group by Sso_providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sso_providersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sso_providersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sso_providersGroupByArgs['orderBy'] }
        : { orderBy?: sso_providersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sso_providersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSso_providersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sso_providers model
   */
  readonly fields: sso_providersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sso_providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sso_providersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saml_providers<T extends sso_providers$saml_providersArgs<ExtArgs> = {}>(args?: Subset<T, sso_providers$saml_providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saml_relay_states<T extends sso_providers$saml_relay_statesArgs<ExtArgs> = {}>(args?: Subset<T, sso_providers$saml_relay_statesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saml_relay_statesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sso_domains<T extends sso_providers$sso_domainsArgs<ExtArgs> = {}>(args?: Subset<T, sso_providers$sso_domainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sso_domainsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sso_providers model
   */
  interface sso_providersFieldRefs {
    readonly id: FieldRef<"sso_providers", 'String'>
    readonly resource_id: FieldRef<"sso_providers", 'String'>
    readonly created_at: FieldRef<"sso_providers", 'DateTime'>
    readonly updated_at: FieldRef<"sso_providers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sso_providers findUnique
   */
  export type sso_providersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * Filter, which sso_providers to fetch.
     */
    where: sso_providersWhereUniqueInput
  }

  /**
   * sso_providers findUniqueOrThrow
   */
  export type sso_providersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * Filter, which sso_providers to fetch.
     */
    where: sso_providersWhereUniqueInput
  }

  /**
   * sso_providers findFirst
   */
  export type sso_providersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * Filter, which sso_providers to fetch.
     */
    where?: sso_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_providers to fetch.
     */
    orderBy?: sso_providersOrderByWithRelationInput | sso_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sso_providers.
     */
    cursor?: sso_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sso_providers.
     */
    distinct?: Sso_providersScalarFieldEnum | Sso_providersScalarFieldEnum[]
  }

  /**
   * sso_providers findFirstOrThrow
   */
  export type sso_providersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * Filter, which sso_providers to fetch.
     */
    where?: sso_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_providers to fetch.
     */
    orderBy?: sso_providersOrderByWithRelationInput | sso_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sso_providers.
     */
    cursor?: sso_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sso_providers.
     */
    distinct?: Sso_providersScalarFieldEnum | Sso_providersScalarFieldEnum[]
  }

  /**
   * sso_providers findMany
   */
  export type sso_providersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * Filter, which sso_providers to fetch.
     */
    where?: sso_providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sso_providers to fetch.
     */
    orderBy?: sso_providersOrderByWithRelationInput | sso_providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sso_providers.
     */
    cursor?: sso_providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sso_providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sso_providers.
     */
    skip?: number
    distinct?: Sso_providersScalarFieldEnum | Sso_providersScalarFieldEnum[]
  }

  /**
   * sso_providers create
   */
  export type sso_providersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * The data needed to create a sso_providers.
     */
    data: XOR<sso_providersCreateInput, sso_providersUncheckedCreateInput>
  }

  /**
   * sso_providers createMany
   */
  export type sso_providersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sso_providers.
     */
    data: sso_providersCreateManyInput | sso_providersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sso_providers createManyAndReturn
   */
  export type sso_providersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * The data used to create many sso_providers.
     */
    data: sso_providersCreateManyInput | sso_providersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sso_providers update
   */
  export type sso_providersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * The data needed to update a sso_providers.
     */
    data: XOR<sso_providersUpdateInput, sso_providersUncheckedUpdateInput>
    /**
     * Choose, which sso_providers to update.
     */
    where: sso_providersWhereUniqueInput
  }

  /**
   * sso_providers updateMany
   */
  export type sso_providersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sso_providers.
     */
    data: XOR<sso_providersUpdateManyMutationInput, sso_providersUncheckedUpdateManyInput>
    /**
     * Filter which sso_providers to update
     */
    where?: sso_providersWhereInput
    /**
     * Limit how many sso_providers to update.
     */
    limit?: number
  }

  /**
   * sso_providers updateManyAndReturn
   */
  export type sso_providersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * The data used to update sso_providers.
     */
    data: XOR<sso_providersUpdateManyMutationInput, sso_providersUncheckedUpdateManyInput>
    /**
     * Filter which sso_providers to update
     */
    where?: sso_providersWhereInput
    /**
     * Limit how many sso_providers to update.
     */
    limit?: number
  }

  /**
   * sso_providers upsert
   */
  export type sso_providersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * The filter to search for the sso_providers to update in case it exists.
     */
    where: sso_providersWhereUniqueInput
    /**
     * In case the sso_providers found by the `where` argument doesn't exist, create a new sso_providers with this data.
     */
    create: XOR<sso_providersCreateInput, sso_providersUncheckedCreateInput>
    /**
     * In case the sso_providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sso_providersUpdateInput, sso_providersUncheckedUpdateInput>
  }

  /**
   * sso_providers delete
   */
  export type sso_providersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
    /**
     * Filter which sso_providers to delete.
     */
    where: sso_providersWhereUniqueInput
  }

  /**
   * sso_providers deleteMany
   */
  export type sso_providersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sso_providers to delete
     */
    where?: sso_providersWhereInput
    /**
     * Limit how many sso_providers to delete.
     */
    limit?: number
  }

  /**
   * sso_providers.saml_providers
   */
  export type sso_providers$saml_providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_providers
     */
    select?: saml_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_providers
     */
    omit?: saml_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_providersInclude<ExtArgs> | null
    where?: saml_providersWhereInput
    orderBy?: saml_providersOrderByWithRelationInput | saml_providersOrderByWithRelationInput[]
    cursor?: saml_providersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Saml_providersScalarFieldEnum | Saml_providersScalarFieldEnum[]
  }

  /**
   * sso_providers.saml_relay_states
   */
  export type sso_providers$saml_relay_statesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saml_relay_states
     */
    select?: saml_relay_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saml_relay_states
     */
    omit?: saml_relay_statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saml_relay_statesInclude<ExtArgs> | null
    where?: saml_relay_statesWhereInput
    orderBy?: saml_relay_statesOrderByWithRelationInput | saml_relay_statesOrderByWithRelationInput[]
    cursor?: saml_relay_statesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Saml_relay_statesScalarFieldEnum | Saml_relay_statesScalarFieldEnum[]
  }

  /**
   * sso_providers.sso_domains
   */
  export type sso_providers$sso_domainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_domains
     */
    select?: sso_domainsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_domains
     */
    omit?: sso_domainsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_domainsInclude<ExtArgs> | null
    where?: sso_domainsWhereInput
    orderBy?: sso_domainsOrderByWithRelationInput | sso_domainsOrderByWithRelationInput[]
    cursor?: sso_domainsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sso_domainsScalarFieldEnum | Sso_domainsScalarFieldEnum[]
  }

  /**
   * sso_providers without action
   */
  export type sso_providersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sso_providers
     */
    select?: sso_providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sso_providers
     */
    omit?: sso_providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sso_providersInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    email_change_confirm_status: number | null
  }

  export type UsersSumAggregateOutputType = {
    email_change_confirm_status: number | null
  }

  export type UsersMinAggregateOutputType = {
    instance_id: string | null
    id: string | null
    aud: string | null
    role: string | null
    email: string | null
    encrypted_password: string | null
    email_confirmed_at: Date | null
    invited_at: Date | null
    confirmation_token: string | null
    confirmation_sent_at: Date | null
    recovery_token: string | null
    recovery_sent_at: Date | null
    email_change_token_new: string | null
    email_change: string | null
    email_change_sent_at: Date | null
    last_sign_in_at: Date | null
    is_super_admin: boolean | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
    phone_confirmed_at: Date | null
    phone_change: string | null
    phone_change_token: string | null
    phone_change_sent_at: Date | null
    confirmed_at: Date | null
    email_change_token_current: string | null
    email_change_confirm_status: number | null
    banned_until: Date | null
    reauthentication_token: string | null
    reauthentication_sent_at: Date | null
    is_sso_user: boolean | null
    deleted_at: Date | null
    is_anonymous: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    instance_id: string | null
    id: string | null
    aud: string | null
    role: string | null
    email: string | null
    encrypted_password: string | null
    email_confirmed_at: Date | null
    invited_at: Date | null
    confirmation_token: string | null
    confirmation_sent_at: Date | null
    recovery_token: string | null
    recovery_sent_at: Date | null
    email_change_token_new: string | null
    email_change: string | null
    email_change_sent_at: Date | null
    last_sign_in_at: Date | null
    is_super_admin: boolean | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
    phone_confirmed_at: Date | null
    phone_change: string | null
    phone_change_token: string | null
    phone_change_sent_at: Date | null
    confirmed_at: Date | null
    email_change_token_current: string | null
    email_change_confirm_status: number | null
    banned_until: Date | null
    reauthentication_token: string | null
    reauthentication_sent_at: Date | null
    is_sso_user: boolean | null
    deleted_at: Date | null
    is_anonymous: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    instance_id: number
    id: number
    aud: number
    role: number
    email: number
    encrypted_password: number
    email_confirmed_at: number
    invited_at: number
    confirmation_token: number
    confirmation_sent_at: number
    recovery_token: number
    recovery_sent_at: number
    email_change_token_new: number
    email_change: number
    email_change_sent_at: number
    last_sign_in_at: number
    raw_app_meta_data: number
    raw_user_meta_data: number
    is_super_admin: number
    created_at: number
    updated_at: number
    phone: number
    phone_confirmed_at: number
    phone_change: number
    phone_change_token: number
    phone_change_sent_at: number
    confirmed_at: number
    email_change_token_current: number
    email_change_confirm_status: number
    banned_until: number
    reauthentication_token: number
    reauthentication_sent_at: number
    is_sso_user: number
    deleted_at: number
    is_anonymous: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    email_change_confirm_status?: true
  }

  export type UsersSumAggregateInputType = {
    email_change_confirm_status?: true
  }

  export type UsersMinAggregateInputType = {
    instance_id?: true
    id?: true
    aud?: true
    role?: true
    email?: true
    encrypted_password?: true
    email_confirmed_at?: true
    invited_at?: true
    confirmation_token?: true
    confirmation_sent_at?: true
    recovery_token?: true
    recovery_sent_at?: true
    email_change_token_new?: true
    email_change?: true
    email_change_sent_at?: true
    last_sign_in_at?: true
    is_super_admin?: true
    created_at?: true
    updated_at?: true
    phone?: true
    phone_confirmed_at?: true
    phone_change?: true
    phone_change_token?: true
    phone_change_sent_at?: true
    confirmed_at?: true
    email_change_token_current?: true
    email_change_confirm_status?: true
    banned_until?: true
    reauthentication_token?: true
    reauthentication_sent_at?: true
    is_sso_user?: true
    deleted_at?: true
    is_anonymous?: true
  }

  export type UsersMaxAggregateInputType = {
    instance_id?: true
    id?: true
    aud?: true
    role?: true
    email?: true
    encrypted_password?: true
    email_confirmed_at?: true
    invited_at?: true
    confirmation_token?: true
    confirmation_sent_at?: true
    recovery_token?: true
    recovery_sent_at?: true
    email_change_token_new?: true
    email_change?: true
    email_change_sent_at?: true
    last_sign_in_at?: true
    is_super_admin?: true
    created_at?: true
    updated_at?: true
    phone?: true
    phone_confirmed_at?: true
    phone_change?: true
    phone_change_token?: true
    phone_change_sent_at?: true
    confirmed_at?: true
    email_change_token_current?: true
    email_change_confirm_status?: true
    banned_until?: true
    reauthentication_token?: true
    reauthentication_sent_at?: true
    is_sso_user?: true
    deleted_at?: true
    is_anonymous?: true
  }

  export type UsersCountAggregateInputType = {
    instance_id?: true
    id?: true
    aud?: true
    role?: true
    email?: true
    encrypted_password?: true
    email_confirmed_at?: true
    invited_at?: true
    confirmation_token?: true
    confirmation_sent_at?: true
    recovery_token?: true
    recovery_sent_at?: true
    email_change_token_new?: true
    email_change?: true
    email_change_sent_at?: true
    last_sign_in_at?: true
    raw_app_meta_data?: true
    raw_user_meta_data?: true
    is_super_admin?: true
    created_at?: true
    updated_at?: true
    phone?: true
    phone_confirmed_at?: true
    phone_change?: true
    phone_change_token?: true
    phone_change_sent_at?: true
    confirmed_at?: true
    email_change_token_current?: true
    email_change_confirm_status?: true
    banned_until?: true
    reauthentication_token?: true
    reauthentication_sent_at?: true
    is_sso_user?: true
    deleted_at?: true
    is_anonymous?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    instance_id: string | null
    id: string
    aud: string | null
    role: string | null
    email: string | null
    encrypted_password: string | null
    email_confirmed_at: Date | null
    invited_at: Date | null
    confirmation_token: string | null
    confirmation_sent_at: Date | null
    recovery_token: string | null
    recovery_sent_at: Date | null
    email_change_token_new: string | null
    email_change: string | null
    email_change_sent_at: Date | null
    last_sign_in_at: Date | null
    raw_app_meta_data: JsonValue | null
    raw_user_meta_data: JsonValue | null
    is_super_admin: boolean | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
    phone_confirmed_at: Date | null
    phone_change: string | null
    phone_change_token: string | null
    phone_change_sent_at: Date | null
    confirmed_at: Date | null
    email_change_token_current: string | null
    email_change_confirm_status: number | null
    banned_until: Date | null
    reauthentication_token: string | null
    reauthentication_sent_at: Date | null
    is_sso_user: boolean
    deleted_at: Date | null
    is_anonymous: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    aud?: boolean
    role?: boolean
    email?: boolean
    encrypted_password?: boolean
    email_confirmed_at?: boolean
    invited_at?: boolean
    confirmation_token?: boolean
    confirmation_sent_at?: boolean
    recovery_token?: boolean
    recovery_sent_at?: boolean
    email_change_token_new?: boolean
    email_change?: boolean
    email_change_sent_at?: boolean
    last_sign_in_at?: boolean
    raw_app_meta_data?: boolean
    raw_user_meta_data?: boolean
    is_super_admin?: boolean
    created_at?: boolean
    updated_at?: boolean
    phone?: boolean
    phone_confirmed_at?: boolean
    phone_change?: boolean
    phone_change_token?: boolean
    phone_change_sent_at?: boolean
    confirmed_at?: boolean
    email_change_token_current?: boolean
    email_change_confirm_status?: boolean
    banned_until?: boolean
    reauthentication_token?: boolean
    reauthentication_sent_at?: boolean
    is_sso_user?: boolean
    deleted_at?: boolean
    is_anonymous?: boolean
    identities?: boolean | users$identitiesArgs<ExtArgs>
    mfa_factors?: boolean | users$mfa_factorsArgs<ExtArgs>
    one_time_tokens?: boolean | users$one_time_tokensArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    profilesTable?: boolean | users$profilesTableArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    aud?: boolean
    role?: boolean
    email?: boolean
    encrypted_password?: boolean
    email_confirmed_at?: boolean
    invited_at?: boolean
    confirmation_token?: boolean
    confirmation_sent_at?: boolean
    recovery_token?: boolean
    recovery_sent_at?: boolean
    email_change_token_new?: boolean
    email_change?: boolean
    email_change_sent_at?: boolean
    last_sign_in_at?: boolean
    raw_app_meta_data?: boolean
    raw_user_meta_data?: boolean
    is_super_admin?: boolean
    created_at?: boolean
    updated_at?: boolean
    phone?: boolean
    phone_confirmed_at?: boolean
    phone_change?: boolean
    phone_change_token?: boolean
    phone_change_sent_at?: boolean
    confirmed_at?: boolean
    email_change_token_current?: boolean
    email_change_confirm_status?: boolean
    banned_until?: boolean
    reauthentication_token?: boolean
    reauthentication_sent_at?: boolean
    is_sso_user?: boolean
    deleted_at?: boolean
    is_anonymous?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    id?: boolean
    aud?: boolean
    role?: boolean
    email?: boolean
    encrypted_password?: boolean
    email_confirmed_at?: boolean
    invited_at?: boolean
    confirmation_token?: boolean
    confirmation_sent_at?: boolean
    recovery_token?: boolean
    recovery_sent_at?: boolean
    email_change_token_new?: boolean
    email_change?: boolean
    email_change_sent_at?: boolean
    last_sign_in_at?: boolean
    raw_app_meta_data?: boolean
    raw_user_meta_data?: boolean
    is_super_admin?: boolean
    created_at?: boolean
    updated_at?: boolean
    phone?: boolean
    phone_confirmed_at?: boolean
    phone_change?: boolean
    phone_change_token?: boolean
    phone_change_sent_at?: boolean
    confirmed_at?: boolean
    email_change_token_current?: boolean
    email_change_confirm_status?: boolean
    banned_until?: boolean
    reauthentication_token?: boolean
    reauthentication_sent_at?: boolean
    is_sso_user?: boolean
    deleted_at?: boolean
    is_anonymous?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    instance_id?: boolean
    id?: boolean
    aud?: boolean
    role?: boolean
    email?: boolean
    encrypted_password?: boolean
    email_confirmed_at?: boolean
    invited_at?: boolean
    confirmation_token?: boolean
    confirmation_sent_at?: boolean
    recovery_token?: boolean
    recovery_sent_at?: boolean
    email_change_token_new?: boolean
    email_change?: boolean
    email_change_sent_at?: boolean
    last_sign_in_at?: boolean
    raw_app_meta_data?: boolean
    raw_user_meta_data?: boolean
    is_super_admin?: boolean
    created_at?: boolean
    updated_at?: boolean
    phone?: boolean
    phone_confirmed_at?: boolean
    phone_change?: boolean
    phone_change_token?: boolean
    phone_change_sent_at?: boolean
    confirmed_at?: boolean
    email_change_token_current?: boolean
    email_change_confirm_status?: boolean
    banned_until?: boolean
    reauthentication_token?: boolean
    reauthentication_sent_at?: boolean
    is_sso_user?: boolean
    deleted_at?: boolean
    is_anonymous?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"instance_id" | "id" | "aud" | "role" | "email" | "encrypted_password" | "email_confirmed_at" | "invited_at" | "confirmation_token" | "confirmation_sent_at" | "recovery_token" | "recovery_sent_at" | "email_change_token_new" | "email_change" | "email_change_sent_at" | "last_sign_in_at" | "raw_app_meta_data" | "raw_user_meta_data" | "is_super_admin" | "created_at" | "updated_at" | "phone" | "phone_confirmed_at" | "phone_change" | "phone_change_token" | "phone_change_sent_at" | "confirmed_at" | "email_change_token_current" | "email_change_confirm_status" | "banned_until" | "reauthentication_token" | "reauthentication_sent_at" | "is_sso_user" | "deleted_at" | "is_anonymous", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identities?: boolean | users$identitiesArgs<ExtArgs>
    mfa_factors?: boolean | users$mfa_factorsArgs<ExtArgs>
    one_time_tokens?: boolean | users$one_time_tokensArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    profilesTable?: boolean | users$profilesTableArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      identities: Prisma.$identitiesPayload<ExtArgs>[]
      mfa_factors: Prisma.$mfa_factorsPayload<ExtArgs>[]
      one_time_tokens: Prisma.$one_time_tokensPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
      profilesTable: Prisma.$profilesTablePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      instance_id: string | null
      id: string
      aud: string | null
      role: string | null
      email: string | null
      encrypted_password: string | null
      email_confirmed_at: Date | null
      invited_at: Date | null
      confirmation_token: string | null
      confirmation_sent_at: Date | null
      recovery_token: string | null
      recovery_sent_at: Date | null
      email_change_token_new: string | null
      email_change: string | null
      email_change_sent_at: Date | null
      last_sign_in_at: Date | null
      raw_app_meta_data: Prisma.JsonValue | null
      raw_user_meta_data: Prisma.JsonValue | null
      is_super_admin: boolean | null
      created_at: Date | null
      updated_at: Date | null
      phone: string | null
      phone_confirmed_at: Date | null
      phone_change: string | null
      phone_change_token: string | null
      phone_change_sent_at: Date | null
      confirmed_at: Date | null
      email_change_token_current: string | null
      email_change_confirm_status: number | null
      banned_until: Date | null
      reauthentication_token: string | null
      reauthentication_sent_at: Date | null
      is_sso_user: boolean
      deleted_at: Date | null
      is_anonymous: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `instance_id`
     * const usersWithInstance_idOnly = await prisma.users.findMany({ select: { instance_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `instance_id`
     * const usersWithInstance_idOnly = await prisma.users.createManyAndReturn({
     *   select: { instance_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `instance_id`
     * const usersWithInstance_idOnly = await prisma.users.updateManyAndReturn({
     *   select: { instance_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    identities<T extends users$identitiesArgs<ExtArgs> = {}>(args?: Subset<T, users$identitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$identitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mfa_factors<T extends users$mfa_factorsArgs<ExtArgs> = {}>(args?: Subset<T, users$mfa_factorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mfa_factorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    one_time_tokens<T extends users$one_time_tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$one_time_tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$one_time_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends users$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profilesTable<T extends users$profilesTableArgs<ExtArgs> = {}>(args?: Subset<T, users$profilesTableArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly instance_id: FieldRef<"users", 'String'>
    readonly id: FieldRef<"users", 'String'>
    readonly aud: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly encrypted_password: FieldRef<"users", 'String'>
    readonly email_confirmed_at: FieldRef<"users", 'DateTime'>
    readonly invited_at: FieldRef<"users", 'DateTime'>
    readonly confirmation_token: FieldRef<"users", 'String'>
    readonly confirmation_sent_at: FieldRef<"users", 'DateTime'>
    readonly recovery_token: FieldRef<"users", 'String'>
    readonly recovery_sent_at: FieldRef<"users", 'DateTime'>
    readonly email_change_token_new: FieldRef<"users", 'String'>
    readonly email_change: FieldRef<"users", 'String'>
    readonly email_change_sent_at: FieldRef<"users", 'DateTime'>
    readonly last_sign_in_at: FieldRef<"users", 'DateTime'>
    readonly raw_app_meta_data: FieldRef<"users", 'Json'>
    readonly raw_user_meta_data: FieldRef<"users", 'Json'>
    readonly is_super_admin: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly phone: FieldRef<"users", 'String'>
    readonly phone_confirmed_at: FieldRef<"users", 'DateTime'>
    readonly phone_change: FieldRef<"users", 'String'>
    readonly phone_change_token: FieldRef<"users", 'String'>
    readonly phone_change_sent_at: FieldRef<"users", 'DateTime'>
    readonly confirmed_at: FieldRef<"users", 'DateTime'>
    readonly email_change_token_current: FieldRef<"users", 'String'>
    readonly email_change_confirm_status: FieldRef<"users", 'Int'>
    readonly banned_until: FieldRef<"users", 'DateTime'>
    readonly reauthentication_token: FieldRef<"users", 'String'>
    readonly reauthentication_sent_at: FieldRef<"users", 'DateTime'>
    readonly is_sso_user: FieldRef<"users", 'Boolean'>
    readonly deleted_at: FieldRef<"users", 'DateTime'>
    readonly is_anonymous: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.identities
   */
  export type users$identitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the identities
     */
    select?: identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the identities
     */
    omit?: identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: identitiesInclude<ExtArgs> | null
    where?: identitiesWhereInput
    orderBy?: identitiesOrderByWithRelationInput | identitiesOrderByWithRelationInput[]
    cursor?: identitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdentitiesScalarFieldEnum | IdentitiesScalarFieldEnum[]
  }

  /**
   * users.mfa_factors
   */
  export type users$mfa_factorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mfa_factors
     */
    select?: mfa_factorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mfa_factors
     */
    omit?: mfa_factorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mfa_factorsInclude<ExtArgs> | null
    where?: mfa_factorsWhereInput
    orderBy?: mfa_factorsOrderByWithRelationInput | mfa_factorsOrderByWithRelationInput[]
    cursor?: mfa_factorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mfa_factorsScalarFieldEnum | Mfa_factorsScalarFieldEnum[]
  }

  /**
   * users.one_time_tokens
   */
  export type users$one_time_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the one_time_tokens
     */
    select?: one_time_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the one_time_tokens
     */
    omit?: one_time_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: one_time_tokensInclude<ExtArgs> | null
    where?: one_time_tokensWhereInput
    orderBy?: one_time_tokensOrderByWithRelationInput | one_time_tokensOrderByWithRelationInput[]
    cursor?: one_time_tokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: One_time_tokensScalarFieldEnum | One_time_tokensScalarFieldEnum[]
  }

  /**
   * users.sessions
   */
  export type users$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * users.profilesTable
   */
  export type users$profilesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    where?: profilesTableWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model cropStakeholdersTable
   */

  export type AggregateCropStakeholdersTable = {
    _count: CropStakeholdersTableCountAggregateOutputType | null
    _min: CropStakeholdersTableMinAggregateOutputType | null
    _max: CropStakeholdersTableMaxAggregateOutputType | null
  }

  export type CropStakeholdersTableMinAggregateOutputType = {
    cropStakeholderId: string | null
    cropId: string | null
    organizationId: string | null
    stakeholderTypeId: string | null
  }

  export type CropStakeholdersTableMaxAggregateOutputType = {
    cropStakeholderId: string | null
    cropId: string | null
    organizationId: string | null
    stakeholderTypeId: string | null
  }

  export type CropStakeholdersTableCountAggregateOutputType = {
    cropStakeholderId: number
    cropId: number
    organizationId: number
    stakeholderTypeId: number
    _all: number
  }


  export type CropStakeholdersTableMinAggregateInputType = {
    cropStakeholderId?: true
    cropId?: true
    organizationId?: true
    stakeholderTypeId?: true
  }

  export type CropStakeholdersTableMaxAggregateInputType = {
    cropStakeholderId?: true
    cropId?: true
    organizationId?: true
    stakeholderTypeId?: true
  }

  export type CropStakeholdersTableCountAggregateInputType = {
    cropStakeholderId?: true
    cropId?: true
    organizationId?: true
    stakeholderTypeId?: true
    _all?: true
  }

  export type CropStakeholdersTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cropStakeholdersTable to aggregate.
     */
    where?: cropStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropStakeholdersTables to fetch.
     */
    orderBy?: cropStakeholdersTableOrderByWithRelationInput | cropStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cropStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cropStakeholdersTables
    **/
    _count?: true | CropStakeholdersTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropStakeholdersTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropStakeholdersTableMaxAggregateInputType
  }

  export type GetCropStakeholdersTableAggregateType<T extends CropStakeholdersTableAggregateArgs> = {
        [P in keyof T & keyof AggregateCropStakeholdersTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCropStakeholdersTable[P]>
      : GetScalarType<T[P], AggregateCropStakeholdersTable[P]>
  }




  export type cropStakeholdersTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropStakeholdersTableWhereInput
    orderBy?: cropStakeholdersTableOrderByWithAggregationInput | cropStakeholdersTableOrderByWithAggregationInput[]
    by: CropStakeholdersTableScalarFieldEnum[] | CropStakeholdersTableScalarFieldEnum
    having?: cropStakeholdersTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropStakeholdersTableCountAggregateInputType | true
    _min?: CropStakeholdersTableMinAggregateInputType
    _max?: CropStakeholdersTableMaxAggregateInputType
  }

  export type CropStakeholdersTableGroupByOutputType = {
    cropStakeholderId: string
    cropId: string
    organizationId: string
    stakeholderTypeId: string
    _count: CropStakeholdersTableCountAggregateOutputType | null
    _min: CropStakeholdersTableMinAggregateOutputType | null
    _max: CropStakeholdersTableMaxAggregateOutputType | null
  }

  type GetCropStakeholdersTableGroupByPayload<T extends cropStakeholdersTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropStakeholdersTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropStakeholdersTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropStakeholdersTableGroupByOutputType[P]>
            : GetScalarType<T[P], CropStakeholdersTableGroupByOutputType[P]>
        }
      >
    >


  export type cropStakeholdersTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cropStakeholderId?: boolean
    cropId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    cropTable?: boolean | cropTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropStakeholdersTable"]>

  export type cropStakeholdersTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cropStakeholderId?: boolean
    cropId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    cropTable?: boolean | cropTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropStakeholdersTable"]>

  export type cropStakeholdersTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cropStakeholderId?: boolean
    cropId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    cropTable?: boolean | cropTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropStakeholdersTable"]>

  export type cropStakeholdersTableSelectScalar = {
    cropStakeholderId?: boolean
    cropId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
  }

  export type cropStakeholdersTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cropStakeholderId" | "cropId" | "organizationId" | "stakeholderTypeId", ExtArgs["result"]["cropStakeholdersTable"]>
  export type cropStakeholdersTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | cropTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }
  export type cropStakeholdersTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | cropTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }
  export type cropStakeholdersTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | cropTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }

  export type $cropStakeholdersTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cropStakeholdersTable"
    objects: {
      cropTable: Prisma.$cropTablePayload<ExtArgs>
      organizationsTable: Prisma.$organizationsTablePayload<ExtArgs>
      stakeholderTypesTable: Prisma.$stakeholderTypesTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cropStakeholderId: string
      cropId: string
      organizationId: string
      stakeholderTypeId: string
    }, ExtArgs["result"]["cropStakeholdersTable"]>
    composites: {}
  }

  type cropStakeholdersTableGetPayload<S extends boolean | null | undefined | cropStakeholdersTableDefaultArgs> = $Result.GetResult<Prisma.$cropStakeholdersTablePayload, S>

  type cropStakeholdersTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cropStakeholdersTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropStakeholdersTableCountAggregateInputType | true
    }

  export interface cropStakeholdersTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cropStakeholdersTable'], meta: { name: 'cropStakeholdersTable' } }
    /**
     * Find zero or one CropStakeholdersTable that matches the filter.
     * @param {cropStakeholdersTableFindUniqueArgs} args - Arguments to find a CropStakeholdersTable
     * @example
     * // Get one CropStakeholdersTable
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cropStakeholdersTableFindUniqueArgs>(args: SelectSubset<T, cropStakeholdersTableFindUniqueArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CropStakeholdersTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cropStakeholdersTableFindUniqueOrThrowArgs} args - Arguments to find a CropStakeholdersTable
     * @example
     * // Get one CropStakeholdersTable
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cropStakeholdersTableFindUniqueOrThrowArgs>(args: SelectSubset<T, cropStakeholdersTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropStakeholdersTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropStakeholdersTableFindFirstArgs} args - Arguments to find a CropStakeholdersTable
     * @example
     * // Get one CropStakeholdersTable
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cropStakeholdersTableFindFirstArgs>(args?: SelectSubset<T, cropStakeholdersTableFindFirstArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropStakeholdersTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropStakeholdersTableFindFirstOrThrowArgs} args - Arguments to find a CropStakeholdersTable
     * @example
     * // Get one CropStakeholdersTable
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cropStakeholdersTableFindFirstOrThrowArgs>(args?: SelectSubset<T, cropStakeholdersTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CropStakeholdersTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropStakeholdersTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CropStakeholdersTables
     * const cropStakeholdersTables = await prisma.cropStakeholdersTable.findMany()
     * 
     * // Get first 10 CropStakeholdersTables
     * const cropStakeholdersTables = await prisma.cropStakeholdersTable.findMany({ take: 10 })
     * 
     * // Only select the `cropStakeholderId`
     * const cropStakeholdersTableWithCropStakeholderIdOnly = await prisma.cropStakeholdersTable.findMany({ select: { cropStakeholderId: true } })
     * 
     */
    findMany<T extends cropStakeholdersTableFindManyArgs>(args?: SelectSubset<T, cropStakeholdersTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CropStakeholdersTable.
     * @param {cropStakeholdersTableCreateArgs} args - Arguments to create a CropStakeholdersTable.
     * @example
     * // Create one CropStakeholdersTable
     * const CropStakeholdersTable = await prisma.cropStakeholdersTable.create({
     *   data: {
     *     // ... data to create a CropStakeholdersTable
     *   }
     * })
     * 
     */
    create<T extends cropStakeholdersTableCreateArgs>(args: SelectSubset<T, cropStakeholdersTableCreateArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CropStakeholdersTables.
     * @param {cropStakeholdersTableCreateManyArgs} args - Arguments to create many CropStakeholdersTables.
     * @example
     * // Create many CropStakeholdersTables
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cropStakeholdersTableCreateManyArgs>(args?: SelectSubset<T, cropStakeholdersTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CropStakeholdersTables and returns the data saved in the database.
     * @param {cropStakeholdersTableCreateManyAndReturnArgs} args - Arguments to create many CropStakeholdersTables.
     * @example
     * // Create many CropStakeholdersTables
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CropStakeholdersTables and only return the `cropStakeholderId`
     * const cropStakeholdersTableWithCropStakeholderIdOnly = await prisma.cropStakeholdersTable.createManyAndReturn({
     *   select: { cropStakeholderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cropStakeholdersTableCreateManyAndReturnArgs>(args?: SelectSubset<T, cropStakeholdersTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CropStakeholdersTable.
     * @param {cropStakeholdersTableDeleteArgs} args - Arguments to delete one CropStakeholdersTable.
     * @example
     * // Delete one CropStakeholdersTable
     * const CropStakeholdersTable = await prisma.cropStakeholdersTable.delete({
     *   where: {
     *     // ... filter to delete one CropStakeholdersTable
     *   }
     * })
     * 
     */
    delete<T extends cropStakeholdersTableDeleteArgs>(args: SelectSubset<T, cropStakeholdersTableDeleteArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CropStakeholdersTable.
     * @param {cropStakeholdersTableUpdateArgs} args - Arguments to update one CropStakeholdersTable.
     * @example
     * // Update one CropStakeholdersTable
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cropStakeholdersTableUpdateArgs>(args: SelectSubset<T, cropStakeholdersTableUpdateArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CropStakeholdersTables.
     * @param {cropStakeholdersTableDeleteManyArgs} args - Arguments to filter CropStakeholdersTables to delete.
     * @example
     * // Delete a few CropStakeholdersTables
     * const { count } = await prisma.cropStakeholdersTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cropStakeholdersTableDeleteManyArgs>(args?: SelectSubset<T, cropStakeholdersTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropStakeholdersTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropStakeholdersTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CropStakeholdersTables
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cropStakeholdersTableUpdateManyArgs>(args: SelectSubset<T, cropStakeholdersTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropStakeholdersTables and returns the data updated in the database.
     * @param {cropStakeholdersTableUpdateManyAndReturnArgs} args - Arguments to update many CropStakeholdersTables.
     * @example
     * // Update many CropStakeholdersTables
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CropStakeholdersTables and only return the `cropStakeholderId`
     * const cropStakeholdersTableWithCropStakeholderIdOnly = await prisma.cropStakeholdersTable.updateManyAndReturn({
     *   select: { cropStakeholderId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cropStakeholdersTableUpdateManyAndReturnArgs>(args: SelectSubset<T, cropStakeholdersTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CropStakeholdersTable.
     * @param {cropStakeholdersTableUpsertArgs} args - Arguments to update or create a CropStakeholdersTable.
     * @example
     * // Update or create a CropStakeholdersTable
     * const cropStakeholdersTable = await prisma.cropStakeholdersTable.upsert({
     *   create: {
     *     // ... data to create a CropStakeholdersTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CropStakeholdersTable we want to update
     *   }
     * })
     */
    upsert<T extends cropStakeholdersTableUpsertArgs>(args: SelectSubset<T, cropStakeholdersTableUpsertArgs<ExtArgs>>): Prisma__cropStakeholdersTableClient<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CropStakeholdersTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropStakeholdersTableCountArgs} args - Arguments to filter CropStakeholdersTables to count.
     * @example
     * // Count the number of CropStakeholdersTables
     * const count = await prisma.cropStakeholdersTable.count({
     *   where: {
     *     // ... the filter for the CropStakeholdersTables we want to count
     *   }
     * })
    **/
    count<T extends cropStakeholdersTableCountArgs>(
      args?: Subset<T, cropStakeholdersTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropStakeholdersTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CropStakeholdersTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropStakeholdersTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropStakeholdersTableAggregateArgs>(args: Subset<T, CropStakeholdersTableAggregateArgs>): Prisma.PrismaPromise<GetCropStakeholdersTableAggregateType<T>>

    /**
     * Group by CropStakeholdersTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropStakeholdersTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cropStakeholdersTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cropStakeholdersTableGroupByArgs['orderBy'] }
        : { orderBy?: cropStakeholdersTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cropStakeholdersTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropStakeholdersTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cropStakeholdersTable model
   */
  readonly fields: cropStakeholdersTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cropStakeholdersTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cropStakeholdersTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropTable<T extends cropTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cropTableDefaultArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organizationsTable<T extends organizationsTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTableDefaultArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stakeholderTypesTable<T extends stakeholderTypesTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderTypesTableDefaultArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cropStakeholdersTable model
   */
  interface cropStakeholdersTableFieldRefs {
    readonly cropStakeholderId: FieldRef<"cropStakeholdersTable", 'String'>
    readonly cropId: FieldRef<"cropStakeholdersTable", 'String'>
    readonly organizationId: FieldRef<"cropStakeholdersTable", 'String'>
    readonly stakeholderTypeId: FieldRef<"cropStakeholdersTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cropStakeholdersTable findUnique
   */
  export type cropStakeholdersTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which cropStakeholdersTable to fetch.
     */
    where: cropStakeholdersTableWhereUniqueInput
  }

  /**
   * cropStakeholdersTable findUniqueOrThrow
   */
  export type cropStakeholdersTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which cropStakeholdersTable to fetch.
     */
    where: cropStakeholdersTableWhereUniqueInput
  }

  /**
   * cropStakeholdersTable findFirst
   */
  export type cropStakeholdersTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which cropStakeholdersTable to fetch.
     */
    where?: cropStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropStakeholdersTables to fetch.
     */
    orderBy?: cropStakeholdersTableOrderByWithRelationInput | cropStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cropStakeholdersTables.
     */
    cursor?: cropStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cropStakeholdersTables.
     */
    distinct?: CropStakeholdersTableScalarFieldEnum | CropStakeholdersTableScalarFieldEnum[]
  }

  /**
   * cropStakeholdersTable findFirstOrThrow
   */
  export type cropStakeholdersTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which cropStakeholdersTable to fetch.
     */
    where?: cropStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropStakeholdersTables to fetch.
     */
    orderBy?: cropStakeholdersTableOrderByWithRelationInput | cropStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cropStakeholdersTables.
     */
    cursor?: cropStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cropStakeholdersTables.
     */
    distinct?: CropStakeholdersTableScalarFieldEnum | CropStakeholdersTableScalarFieldEnum[]
  }

  /**
   * cropStakeholdersTable findMany
   */
  export type cropStakeholdersTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which cropStakeholdersTables to fetch.
     */
    where?: cropStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropStakeholdersTables to fetch.
     */
    orderBy?: cropStakeholdersTableOrderByWithRelationInput | cropStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cropStakeholdersTables.
     */
    cursor?: cropStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropStakeholdersTables.
     */
    skip?: number
    distinct?: CropStakeholdersTableScalarFieldEnum | CropStakeholdersTableScalarFieldEnum[]
  }

  /**
   * cropStakeholdersTable create
   */
  export type cropStakeholdersTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * The data needed to create a cropStakeholdersTable.
     */
    data: XOR<cropStakeholdersTableCreateInput, cropStakeholdersTableUncheckedCreateInput>
  }

  /**
   * cropStakeholdersTable createMany
   */
  export type cropStakeholdersTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cropStakeholdersTables.
     */
    data: cropStakeholdersTableCreateManyInput | cropStakeholdersTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cropStakeholdersTable createManyAndReturn
   */
  export type cropStakeholdersTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * The data used to create many cropStakeholdersTables.
     */
    data: cropStakeholdersTableCreateManyInput | cropStakeholdersTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cropStakeholdersTable update
   */
  export type cropStakeholdersTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * The data needed to update a cropStakeholdersTable.
     */
    data: XOR<cropStakeholdersTableUpdateInput, cropStakeholdersTableUncheckedUpdateInput>
    /**
     * Choose, which cropStakeholdersTable to update.
     */
    where: cropStakeholdersTableWhereUniqueInput
  }

  /**
   * cropStakeholdersTable updateMany
   */
  export type cropStakeholdersTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cropStakeholdersTables.
     */
    data: XOR<cropStakeholdersTableUpdateManyMutationInput, cropStakeholdersTableUncheckedUpdateManyInput>
    /**
     * Filter which cropStakeholdersTables to update
     */
    where?: cropStakeholdersTableWhereInput
    /**
     * Limit how many cropStakeholdersTables to update.
     */
    limit?: number
  }

  /**
   * cropStakeholdersTable updateManyAndReturn
   */
  export type cropStakeholdersTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * The data used to update cropStakeholdersTables.
     */
    data: XOR<cropStakeholdersTableUpdateManyMutationInput, cropStakeholdersTableUncheckedUpdateManyInput>
    /**
     * Filter which cropStakeholdersTables to update
     */
    where?: cropStakeholdersTableWhereInput
    /**
     * Limit how many cropStakeholdersTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * cropStakeholdersTable upsert
   */
  export type cropStakeholdersTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * The filter to search for the cropStakeholdersTable to update in case it exists.
     */
    where: cropStakeholdersTableWhereUniqueInput
    /**
     * In case the cropStakeholdersTable found by the `where` argument doesn't exist, create a new cropStakeholdersTable with this data.
     */
    create: XOR<cropStakeholdersTableCreateInput, cropStakeholdersTableUncheckedCreateInput>
    /**
     * In case the cropStakeholdersTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cropStakeholdersTableUpdateInput, cropStakeholdersTableUncheckedUpdateInput>
  }

  /**
   * cropStakeholdersTable delete
   */
  export type cropStakeholdersTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter which cropStakeholdersTable to delete.
     */
    where: cropStakeholdersTableWhereUniqueInput
  }

  /**
   * cropStakeholdersTable deleteMany
   */
  export type cropStakeholdersTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cropStakeholdersTables to delete
     */
    where?: cropStakeholdersTableWhereInput
    /**
     * Limit how many cropStakeholdersTables to delete.
     */
    limit?: number
  }

  /**
   * cropStakeholdersTable without action
   */
  export type cropStakeholdersTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
  }


  /**
   * Model cropTable
   */

  export type AggregateCropTable = {
    _count: CropTableCountAggregateOutputType | null
    _min: CropTableMinAggregateOutputType | null
    _max: CropTableMaxAggregateOutputType | null
  }

  export type CropTableMinAggregateOutputType = {
    cropId: string | null
    cropName: string | null
    speciesId: string | null
    seedInfo: string | null
    cropStock: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    projectId: string | null
    organizationId: string | null
    cropNotes: string | null
    csvobjId: string | null
    speciesTemp: string | null
  }

  export type CropTableMaxAggregateOutputType = {
    cropId: string | null
    cropName: string | null
    speciesId: string | null
    seedInfo: string | null
    cropStock: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    projectId: string | null
    organizationId: string | null
    cropNotes: string | null
    csvobjId: string | null
    speciesTemp: string | null
  }

  export type CropTableCountAggregateOutputType = {
    cropId: number
    cropName: number
    speciesId: number
    seedInfo: number
    cropStock: number
    createdAt: number
    lastEditedAt: number
    editedBy: number
    deleted: number
    projectId: number
    organizationId: number
    cropNotes: number
    csvobjId: number
    speciesTemp: number
    _all: number
  }


  export type CropTableMinAggregateInputType = {
    cropId?: true
    cropName?: true
    speciesId?: true
    seedInfo?: true
    cropStock?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    projectId?: true
    organizationId?: true
    cropNotes?: true
    csvobjId?: true
    speciesTemp?: true
  }

  export type CropTableMaxAggregateInputType = {
    cropId?: true
    cropName?: true
    speciesId?: true
    seedInfo?: true
    cropStock?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    projectId?: true
    organizationId?: true
    cropNotes?: true
    csvobjId?: true
    speciesTemp?: true
  }

  export type CropTableCountAggregateInputType = {
    cropId?: true
    cropName?: true
    speciesId?: true
    seedInfo?: true
    cropStock?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    projectId?: true
    organizationId?: true
    cropNotes?: true
    csvobjId?: true
    speciesTemp?: true
    _all?: true
  }

  export type CropTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cropTable to aggregate.
     */
    where?: cropTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropTables to fetch.
     */
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cropTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cropTables
    **/
    _count?: true | CropTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropTableMaxAggregateInputType
  }

  export type GetCropTableAggregateType<T extends CropTableAggregateArgs> = {
        [P in keyof T & keyof AggregateCropTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCropTable[P]>
      : GetScalarType<T[P], AggregateCropTable[P]>
  }




  export type cropTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cropTableWhereInput
    orderBy?: cropTableOrderByWithAggregationInput | cropTableOrderByWithAggregationInput[]
    by: CropTableScalarFieldEnum[] | CropTableScalarFieldEnum
    having?: cropTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropTableCountAggregateInputType | true
    _min?: CropTableMinAggregateInputType
    _max?: CropTableMaxAggregateInputType
  }

  export type CropTableGroupByOutputType = {
    cropId: string
    cropName: string
    speciesId: string | null
    seedInfo: string | null
    cropStock: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    projectId: string | null
    organizationId: string | null
    cropNotes: string | null
    csvobjId: string | null
    speciesTemp: string | null
    _count: CropTableCountAggregateOutputType | null
    _min: CropTableMinAggregateOutputType | null
    _max: CropTableMaxAggregateOutputType | null
  }

  type GetCropTableGroupByPayload<T extends cropTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropTableGroupByOutputType[P]>
            : GetScalarType<T[P], CropTableGroupByOutputType[P]>
        }
      >
    >


  export type cropTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cropId?: boolean
    cropName?: boolean
    speciesId?: boolean
    seedInfo?: boolean
    cropStock?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    projectId?: boolean
    organizationId?: boolean
    cropNotes?: boolean
    csvobjId?: boolean
    speciesTemp?: boolean
    cropStakeholdersTable?: boolean | cropTable$cropStakeholdersTableArgs<ExtArgs>
    csvObjTable?: boolean | cropTable$csvObjTableArgs<ExtArgs>
    organizationsTable?: boolean | cropTable$organizationsTableArgs<ExtArgs>
    projectsTable?: boolean | cropTable$projectsTableArgs<ExtArgs>
    speciesTable?: boolean | cropTable$speciesTableArgs<ExtArgs>
    plantingTable?: boolean | cropTable$plantingTableArgs<ExtArgs>
    _count?: boolean | CropTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropTable"]>

  export type cropTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cropId?: boolean
    cropName?: boolean
    speciesId?: boolean
    seedInfo?: boolean
    cropStock?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    projectId?: boolean
    organizationId?: boolean
    cropNotes?: boolean
    csvobjId?: boolean
    speciesTemp?: boolean
    csvObjTable?: boolean | cropTable$csvObjTableArgs<ExtArgs>
    organizationsTable?: boolean | cropTable$organizationsTableArgs<ExtArgs>
    projectsTable?: boolean | cropTable$projectsTableArgs<ExtArgs>
    speciesTable?: boolean | cropTable$speciesTableArgs<ExtArgs>
  }, ExtArgs["result"]["cropTable"]>

  export type cropTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cropId?: boolean
    cropName?: boolean
    speciesId?: boolean
    seedInfo?: boolean
    cropStock?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    projectId?: boolean
    organizationId?: boolean
    cropNotes?: boolean
    csvobjId?: boolean
    speciesTemp?: boolean
    csvObjTable?: boolean | cropTable$csvObjTableArgs<ExtArgs>
    organizationsTable?: boolean | cropTable$organizationsTableArgs<ExtArgs>
    projectsTable?: boolean | cropTable$projectsTableArgs<ExtArgs>
    speciesTable?: boolean | cropTable$speciesTableArgs<ExtArgs>
  }, ExtArgs["result"]["cropTable"]>

  export type cropTableSelectScalar = {
    cropId?: boolean
    cropName?: boolean
    speciesId?: boolean
    seedInfo?: boolean
    cropStock?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    projectId?: boolean
    organizationId?: boolean
    cropNotes?: boolean
    csvobjId?: boolean
    speciesTemp?: boolean
  }

  export type cropTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cropId" | "cropName" | "speciesId" | "seedInfo" | "cropStock" | "createdAt" | "lastEditedAt" | "editedBy" | "deleted" | "projectId" | "organizationId" | "cropNotes" | "csvobjId" | "speciesTemp", ExtArgs["result"]["cropTable"]>
  export type cropTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropStakeholdersTable?: boolean | cropTable$cropStakeholdersTableArgs<ExtArgs>
    csvObjTable?: boolean | cropTable$csvObjTableArgs<ExtArgs>
    organizationsTable?: boolean | cropTable$organizationsTableArgs<ExtArgs>
    projectsTable?: boolean | cropTable$projectsTableArgs<ExtArgs>
    speciesTable?: boolean | cropTable$speciesTableArgs<ExtArgs>
    plantingTable?: boolean | cropTable$plantingTableArgs<ExtArgs>
    _count?: boolean | CropTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cropTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | cropTable$csvObjTableArgs<ExtArgs>
    organizationsTable?: boolean | cropTable$organizationsTableArgs<ExtArgs>
    projectsTable?: boolean | cropTable$projectsTableArgs<ExtArgs>
    speciesTable?: boolean | cropTable$speciesTableArgs<ExtArgs>
  }
  export type cropTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | cropTable$csvObjTableArgs<ExtArgs>
    organizationsTable?: boolean | cropTable$organizationsTableArgs<ExtArgs>
    projectsTable?: boolean | cropTable$projectsTableArgs<ExtArgs>
    speciesTable?: boolean | cropTable$speciesTableArgs<ExtArgs>
  }

  export type $cropTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cropTable"
    objects: {
      cropStakeholdersTable: Prisma.$cropStakeholdersTablePayload<ExtArgs>[]
      csvObjTable: Prisma.$csvObjTablePayload<ExtArgs> | null
      organizationsTable: Prisma.$organizationsTablePayload<ExtArgs> | null
      projectsTable: Prisma.$projectsTablePayload<ExtArgs> | null
      speciesTable: Prisma.$speciesTablePayload<ExtArgs> | null
      plantingTable: Prisma.$plantingTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cropId: string
      cropName: string
      speciesId: string | null
      seedInfo: string | null
      cropStock: string | null
      createdAt: Date | null
      lastEditedAt: Date | null
      editedBy: string | null
      deleted: boolean | null
      projectId: string | null
      organizationId: string | null
      cropNotes: string | null
      csvobjId: string | null
      speciesTemp: string | null
    }, ExtArgs["result"]["cropTable"]>
    composites: {}
  }

  type cropTableGetPayload<S extends boolean | null | undefined | cropTableDefaultArgs> = $Result.GetResult<Prisma.$cropTablePayload, S>

  type cropTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cropTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropTableCountAggregateInputType | true
    }

  export interface cropTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cropTable'], meta: { name: 'cropTable' } }
    /**
     * Find zero or one CropTable that matches the filter.
     * @param {cropTableFindUniqueArgs} args - Arguments to find a CropTable
     * @example
     * // Get one CropTable
     * const cropTable = await prisma.cropTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cropTableFindUniqueArgs>(args: SelectSubset<T, cropTableFindUniqueArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CropTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cropTableFindUniqueOrThrowArgs} args - Arguments to find a CropTable
     * @example
     * // Get one CropTable
     * const cropTable = await prisma.cropTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cropTableFindUniqueOrThrowArgs>(args: SelectSubset<T, cropTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropTableFindFirstArgs} args - Arguments to find a CropTable
     * @example
     * // Get one CropTable
     * const cropTable = await prisma.cropTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cropTableFindFirstArgs>(args?: SelectSubset<T, cropTableFindFirstArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropTableFindFirstOrThrowArgs} args - Arguments to find a CropTable
     * @example
     * // Get one CropTable
     * const cropTable = await prisma.cropTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cropTableFindFirstOrThrowArgs>(args?: SelectSubset<T, cropTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CropTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CropTables
     * const cropTables = await prisma.cropTable.findMany()
     * 
     * // Get first 10 CropTables
     * const cropTables = await prisma.cropTable.findMany({ take: 10 })
     * 
     * // Only select the `cropId`
     * const cropTableWithCropIdOnly = await prisma.cropTable.findMany({ select: { cropId: true } })
     * 
     */
    findMany<T extends cropTableFindManyArgs>(args?: SelectSubset<T, cropTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CropTable.
     * @param {cropTableCreateArgs} args - Arguments to create a CropTable.
     * @example
     * // Create one CropTable
     * const CropTable = await prisma.cropTable.create({
     *   data: {
     *     // ... data to create a CropTable
     *   }
     * })
     * 
     */
    create<T extends cropTableCreateArgs>(args: SelectSubset<T, cropTableCreateArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CropTables.
     * @param {cropTableCreateManyArgs} args - Arguments to create many CropTables.
     * @example
     * // Create many CropTables
     * const cropTable = await prisma.cropTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cropTableCreateManyArgs>(args?: SelectSubset<T, cropTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CropTables and returns the data saved in the database.
     * @param {cropTableCreateManyAndReturnArgs} args - Arguments to create many CropTables.
     * @example
     * // Create many CropTables
     * const cropTable = await prisma.cropTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CropTables and only return the `cropId`
     * const cropTableWithCropIdOnly = await prisma.cropTable.createManyAndReturn({
     *   select: { cropId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cropTableCreateManyAndReturnArgs>(args?: SelectSubset<T, cropTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CropTable.
     * @param {cropTableDeleteArgs} args - Arguments to delete one CropTable.
     * @example
     * // Delete one CropTable
     * const CropTable = await prisma.cropTable.delete({
     *   where: {
     *     // ... filter to delete one CropTable
     *   }
     * })
     * 
     */
    delete<T extends cropTableDeleteArgs>(args: SelectSubset<T, cropTableDeleteArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CropTable.
     * @param {cropTableUpdateArgs} args - Arguments to update one CropTable.
     * @example
     * // Update one CropTable
     * const cropTable = await prisma.cropTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cropTableUpdateArgs>(args: SelectSubset<T, cropTableUpdateArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CropTables.
     * @param {cropTableDeleteManyArgs} args - Arguments to filter CropTables to delete.
     * @example
     * // Delete a few CropTables
     * const { count } = await prisma.cropTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cropTableDeleteManyArgs>(args?: SelectSubset<T, cropTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CropTables
     * const cropTable = await prisma.cropTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cropTableUpdateManyArgs>(args: SelectSubset<T, cropTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropTables and returns the data updated in the database.
     * @param {cropTableUpdateManyAndReturnArgs} args - Arguments to update many CropTables.
     * @example
     * // Update many CropTables
     * const cropTable = await prisma.cropTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CropTables and only return the `cropId`
     * const cropTableWithCropIdOnly = await prisma.cropTable.updateManyAndReturn({
     *   select: { cropId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cropTableUpdateManyAndReturnArgs>(args: SelectSubset<T, cropTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CropTable.
     * @param {cropTableUpsertArgs} args - Arguments to update or create a CropTable.
     * @example
     * // Update or create a CropTable
     * const cropTable = await prisma.cropTable.upsert({
     *   create: {
     *     // ... data to create a CropTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CropTable we want to update
     *   }
     * })
     */
    upsert<T extends cropTableUpsertArgs>(args: SelectSubset<T, cropTableUpsertArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CropTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropTableCountArgs} args - Arguments to filter CropTables to count.
     * @example
     * // Count the number of CropTables
     * const count = await prisma.cropTable.count({
     *   where: {
     *     // ... the filter for the CropTables we want to count
     *   }
     * })
    **/
    count<T extends cropTableCountArgs>(
      args?: Subset<T, cropTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CropTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropTableAggregateArgs>(args: Subset<T, CropTableAggregateArgs>): Prisma.PrismaPromise<GetCropTableAggregateType<T>>

    /**
     * Group by CropTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cropTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cropTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cropTableGroupByArgs['orderBy'] }
        : { orderBy?: cropTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cropTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cropTable model
   */
  readonly fields: cropTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cropTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cropTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropStakeholdersTable<T extends cropTable$cropStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, cropTable$cropStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    csvObjTable<T extends cropTable$csvObjTableArgs<ExtArgs> = {}>(args?: Subset<T, cropTable$csvObjTableArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organizationsTable<T extends cropTable$organizationsTableArgs<ExtArgs> = {}>(args?: Subset<T, cropTable$organizationsTableArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    projectsTable<T extends cropTable$projectsTableArgs<ExtArgs> = {}>(args?: Subset<T, cropTable$projectsTableArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    speciesTable<T extends cropTable$speciesTableArgs<ExtArgs> = {}>(args?: Subset<T, cropTable$speciesTableArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plantingTable<T extends cropTable$plantingTableArgs<ExtArgs> = {}>(args?: Subset<T, cropTable$plantingTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cropTable model
   */
  interface cropTableFieldRefs {
    readonly cropId: FieldRef<"cropTable", 'String'>
    readonly cropName: FieldRef<"cropTable", 'String'>
    readonly speciesId: FieldRef<"cropTable", 'String'>
    readonly seedInfo: FieldRef<"cropTable", 'String'>
    readonly cropStock: FieldRef<"cropTable", 'String'>
    readonly createdAt: FieldRef<"cropTable", 'DateTime'>
    readonly lastEditedAt: FieldRef<"cropTable", 'DateTime'>
    readonly editedBy: FieldRef<"cropTable", 'String'>
    readonly deleted: FieldRef<"cropTable", 'Boolean'>
    readonly projectId: FieldRef<"cropTable", 'String'>
    readonly organizationId: FieldRef<"cropTable", 'String'>
    readonly cropNotes: FieldRef<"cropTable", 'String'>
    readonly csvobjId: FieldRef<"cropTable", 'String'>
    readonly speciesTemp: FieldRef<"cropTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cropTable findUnique
   */
  export type cropTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * Filter, which cropTable to fetch.
     */
    where: cropTableWhereUniqueInput
  }

  /**
   * cropTable findUniqueOrThrow
   */
  export type cropTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * Filter, which cropTable to fetch.
     */
    where: cropTableWhereUniqueInput
  }

  /**
   * cropTable findFirst
   */
  export type cropTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * Filter, which cropTable to fetch.
     */
    where?: cropTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropTables to fetch.
     */
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cropTables.
     */
    cursor?: cropTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cropTables.
     */
    distinct?: CropTableScalarFieldEnum | CropTableScalarFieldEnum[]
  }

  /**
   * cropTable findFirstOrThrow
   */
  export type cropTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * Filter, which cropTable to fetch.
     */
    where?: cropTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropTables to fetch.
     */
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cropTables.
     */
    cursor?: cropTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cropTables.
     */
    distinct?: CropTableScalarFieldEnum | CropTableScalarFieldEnum[]
  }

  /**
   * cropTable findMany
   */
  export type cropTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * Filter, which cropTables to fetch.
     */
    where?: cropTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cropTables to fetch.
     */
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cropTables.
     */
    cursor?: cropTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cropTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cropTables.
     */
    skip?: number
    distinct?: CropTableScalarFieldEnum | CropTableScalarFieldEnum[]
  }

  /**
   * cropTable create
   */
  export type cropTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * The data needed to create a cropTable.
     */
    data: XOR<cropTableCreateInput, cropTableUncheckedCreateInput>
  }

  /**
   * cropTable createMany
   */
  export type cropTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cropTables.
     */
    data: cropTableCreateManyInput | cropTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cropTable createManyAndReturn
   */
  export type cropTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * The data used to create many cropTables.
     */
    data: cropTableCreateManyInput | cropTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cropTable update
   */
  export type cropTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * The data needed to update a cropTable.
     */
    data: XOR<cropTableUpdateInput, cropTableUncheckedUpdateInput>
    /**
     * Choose, which cropTable to update.
     */
    where: cropTableWhereUniqueInput
  }

  /**
   * cropTable updateMany
   */
  export type cropTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cropTables.
     */
    data: XOR<cropTableUpdateManyMutationInput, cropTableUncheckedUpdateManyInput>
    /**
     * Filter which cropTables to update
     */
    where?: cropTableWhereInput
    /**
     * Limit how many cropTables to update.
     */
    limit?: number
  }

  /**
   * cropTable updateManyAndReturn
   */
  export type cropTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * The data used to update cropTables.
     */
    data: XOR<cropTableUpdateManyMutationInput, cropTableUncheckedUpdateManyInput>
    /**
     * Filter which cropTables to update
     */
    where?: cropTableWhereInput
    /**
     * Limit how many cropTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * cropTable upsert
   */
  export type cropTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * The filter to search for the cropTable to update in case it exists.
     */
    where: cropTableWhereUniqueInput
    /**
     * In case the cropTable found by the `where` argument doesn't exist, create a new cropTable with this data.
     */
    create: XOR<cropTableCreateInput, cropTableUncheckedCreateInput>
    /**
     * In case the cropTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cropTableUpdateInput, cropTableUncheckedUpdateInput>
  }

  /**
   * cropTable delete
   */
  export type cropTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    /**
     * Filter which cropTable to delete.
     */
    where: cropTableWhereUniqueInput
  }

  /**
   * cropTable deleteMany
   */
  export type cropTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cropTables to delete
     */
    where?: cropTableWhereInput
    /**
     * Limit how many cropTables to delete.
     */
    limit?: number
  }

  /**
   * cropTable.cropStakeholdersTable
   */
  export type cropTable$cropStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    where?: cropStakeholdersTableWhereInput
    orderBy?: cropStakeholdersTableOrderByWithRelationInput | cropStakeholdersTableOrderByWithRelationInput[]
    cursor?: cropStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropStakeholdersTableScalarFieldEnum | CropStakeholdersTableScalarFieldEnum[]
  }

  /**
   * cropTable.csvObjTable
   */
  export type cropTable$csvObjTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    where?: csvObjTableWhereInput
  }

  /**
   * cropTable.organizationsTable
   */
  export type cropTable$organizationsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    where?: organizationsTableWhereInput
  }

  /**
   * cropTable.projectsTable
   */
  export type cropTable$projectsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    where?: projectsTableWhereInput
  }

  /**
   * cropTable.speciesTable
   */
  export type cropTable$speciesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    where?: speciesTableWhereInput
  }

  /**
   * cropTable.plantingTable
   */
  export type cropTable$plantingTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    where?: plantingTableWhereInput
    orderBy?: plantingTableOrderByWithRelationInput | plantingTableOrderByWithRelationInput[]
    cursor?: plantingTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantingTableScalarFieldEnum | PlantingTableScalarFieldEnum[]
  }

  /**
   * cropTable without action
   */
  export type cropTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
  }


  /**
   * Model csvObjTable
   */

  export type AggregateCsvObjTable = {
    _count: CsvObjTableCountAggregateOutputType | null
    _min: CsvObjTableMinAggregateOutputType | null
    _max: CsvObjTableMaxAggregateOutputType | null
  }

  export type CsvObjTableMinAggregateOutputType = {
    csvobjId: string | null
    createdAt: Date | null
  }

  export type CsvObjTableMaxAggregateOutputType = {
    csvobjId: string | null
    createdAt: Date | null
  }

  export type CsvObjTableCountAggregateOutputType = {
    csvobjId: number
    jsonData: number
    createdAt: number
    _all: number
  }


  export type CsvObjTableMinAggregateInputType = {
    csvobjId?: true
    createdAt?: true
  }

  export type CsvObjTableMaxAggregateInputType = {
    csvobjId?: true
    createdAt?: true
  }

  export type CsvObjTableCountAggregateInputType = {
    csvobjId?: true
    jsonData?: true
    createdAt?: true
    _all?: true
  }

  export type CsvObjTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which csvObjTable to aggregate.
     */
    where?: csvObjTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of csvObjTables to fetch.
     */
    orderBy?: csvObjTableOrderByWithRelationInput | csvObjTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: csvObjTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` csvObjTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` csvObjTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned csvObjTables
    **/
    _count?: true | CsvObjTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CsvObjTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CsvObjTableMaxAggregateInputType
  }

  export type GetCsvObjTableAggregateType<T extends CsvObjTableAggregateArgs> = {
        [P in keyof T & keyof AggregateCsvObjTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCsvObjTable[P]>
      : GetScalarType<T[P], AggregateCsvObjTable[P]>
  }




  export type csvObjTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: csvObjTableWhereInput
    orderBy?: csvObjTableOrderByWithAggregationInput | csvObjTableOrderByWithAggregationInput[]
    by: CsvObjTableScalarFieldEnum[] | CsvObjTableScalarFieldEnum
    having?: csvObjTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CsvObjTableCountAggregateInputType | true
    _min?: CsvObjTableMinAggregateInputType
    _max?: CsvObjTableMaxAggregateInputType
  }

  export type CsvObjTableGroupByOutputType = {
    csvobjId: string
    jsonData: JsonValue
    createdAt: Date | null
    _count: CsvObjTableCountAggregateOutputType | null
    _min: CsvObjTableMinAggregateOutputType | null
    _max: CsvObjTableMaxAggregateOutputType | null
  }

  type GetCsvObjTableGroupByPayload<T extends csvObjTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CsvObjTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CsvObjTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CsvObjTableGroupByOutputType[P]>
            : GetScalarType<T[P], CsvObjTableGroupByOutputType[P]>
        }
      >
    >


  export type csvObjTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    csvobjId?: boolean
    jsonData?: boolean
    createdAt?: boolean
    cropTable?: boolean | csvObjTable$cropTableArgs<ExtArgs>
    landTable?: boolean | csvObjTable$landTableArgs<ExtArgs>
    metadataTable?: boolean | csvObjTable$metadataTableArgs<ExtArgs>
    projectsTable?: boolean | csvObjTable$projectsTableArgs<ExtArgs>
    _count?: boolean | CsvObjTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["csvObjTable"]>

  export type csvObjTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    csvobjId?: boolean
    jsonData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["csvObjTable"]>

  export type csvObjTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    csvobjId?: boolean
    jsonData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["csvObjTable"]>

  export type csvObjTableSelectScalar = {
    csvobjId?: boolean
    jsonData?: boolean
    createdAt?: boolean
  }

  export type csvObjTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"csvobjId" | "jsonData" | "createdAt", ExtArgs["result"]["csvObjTable"]>
  export type csvObjTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | csvObjTable$cropTableArgs<ExtArgs>
    landTable?: boolean | csvObjTable$landTableArgs<ExtArgs>
    metadataTable?: boolean | csvObjTable$metadataTableArgs<ExtArgs>
    projectsTable?: boolean | csvObjTable$projectsTableArgs<ExtArgs>
    _count?: boolean | CsvObjTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type csvObjTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type csvObjTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $csvObjTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "csvObjTable"
    objects: {
      cropTable: Prisma.$cropTablePayload<ExtArgs>[]
      landTable: Prisma.$landTablePayload<ExtArgs>[]
      metadataTable: Prisma.$metadataTablePayload<ExtArgs>[]
      projectsTable: Prisma.$projectsTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      csvobjId: string
      jsonData: Prisma.JsonValue
      createdAt: Date | null
    }, ExtArgs["result"]["csvObjTable"]>
    composites: {}
  }

  type csvObjTableGetPayload<S extends boolean | null | undefined | csvObjTableDefaultArgs> = $Result.GetResult<Prisma.$csvObjTablePayload, S>

  type csvObjTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<csvObjTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CsvObjTableCountAggregateInputType | true
    }

  export interface csvObjTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['csvObjTable'], meta: { name: 'csvObjTable' } }
    /**
     * Find zero or one CsvObjTable that matches the filter.
     * @param {csvObjTableFindUniqueArgs} args - Arguments to find a CsvObjTable
     * @example
     * // Get one CsvObjTable
     * const csvObjTable = await prisma.csvObjTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends csvObjTableFindUniqueArgs>(args: SelectSubset<T, csvObjTableFindUniqueArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CsvObjTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {csvObjTableFindUniqueOrThrowArgs} args - Arguments to find a CsvObjTable
     * @example
     * // Get one CsvObjTable
     * const csvObjTable = await prisma.csvObjTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends csvObjTableFindUniqueOrThrowArgs>(args: SelectSubset<T, csvObjTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CsvObjTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {csvObjTableFindFirstArgs} args - Arguments to find a CsvObjTable
     * @example
     * // Get one CsvObjTable
     * const csvObjTable = await prisma.csvObjTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends csvObjTableFindFirstArgs>(args?: SelectSubset<T, csvObjTableFindFirstArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CsvObjTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {csvObjTableFindFirstOrThrowArgs} args - Arguments to find a CsvObjTable
     * @example
     * // Get one CsvObjTable
     * const csvObjTable = await prisma.csvObjTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends csvObjTableFindFirstOrThrowArgs>(args?: SelectSubset<T, csvObjTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CsvObjTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {csvObjTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CsvObjTables
     * const csvObjTables = await prisma.csvObjTable.findMany()
     * 
     * // Get first 10 CsvObjTables
     * const csvObjTables = await prisma.csvObjTable.findMany({ take: 10 })
     * 
     * // Only select the `csvobjId`
     * const csvObjTableWithCsvobjIdOnly = await prisma.csvObjTable.findMany({ select: { csvobjId: true } })
     * 
     */
    findMany<T extends csvObjTableFindManyArgs>(args?: SelectSubset<T, csvObjTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CsvObjTable.
     * @param {csvObjTableCreateArgs} args - Arguments to create a CsvObjTable.
     * @example
     * // Create one CsvObjTable
     * const CsvObjTable = await prisma.csvObjTable.create({
     *   data: {
     *     // ... data to create a CsvObjTable
     *   }
     * })
     * 
     */
    create<T extends csvObjTableCreateArgs>(args: SelectSubset<T, csvObjTableCreateArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CsvObjTables.
     * @param {csvObjTableCreateManyArgs} args - Arguments to create many CsvObjTables.
     * @example
     * // Create many CsvObjTables
     * const csvObjTable = await prisma.csvObjTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends csvObjTableCreateManyArgs>(args?: SelectSubset<T, csvObjTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CsvObjTables and returns the data saved in the database.
     * @param {csvObjTableCreateManyAndReturnArgs} args - Arguments to create many CsvObjTables.
     * @example
     * // Create many CsvObjTables
     * const csvObjTable = await prisma.csvObjTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CsvObjTables and only return the `csvobjId`
     * const csvObjTableWithCsvobjIdOnly = await prisma.csvObjTable.createManyAndReturn({
     *   select: { csvobjId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends csvObjTableCreateManyAndReturnArgs>(args?: SelectSubset<T, csvObjTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CsvObjTable.
     * @param {csvObjTableDeleteArgs} args - Arguments to delete one CsvObjTable.
     * @example
     * // Delete one CsvObjTable
     * const CsvObjTable = await prisma.csvObjTable.delete({
     *   where: {
     *     // ... filter to delete one CsvObjTable
     *   }
     * })
     * 
     */
    delete<T extends csvObjTableDeleteArgs>(args: SelectSubset<T, csvObjTableDeleteArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CsvObjTable.
     * @param {csvObjTableUpdateArgs} args - Arguments to update one CsvObjTable.
     * @example
     * // Update one CsvObjTable
     * const csvObjTable = await prisma.csvObjTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends csvObjTableUpdateArgs>(args: SelectSubset<T, csvObjTableUpdateArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CsvObjTables.
     * @param {csvObjTableDeleteManyArgs} args - Arguments to filter CsvObjTables to delete.
     * @example
     * // Delete a few CsvObjTables
     * const { count } = await prisma.csvObjTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends csvObjTableDeleteManyArgs>(args?: SelectSubset<T, csvObjTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CsvObjTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {csvObjTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CsvObjTables
     * const csvObjTable = await prisma.csvObjTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends csvObjTableUpdateManyArgs>(args: SelectSubset<T, csvObjTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CsvObjTables and returns the data updated in the database.
     * @param {csvObjTableUpdateManyAndReturnArgs} args - Arguments to update many CsvObjTables.
     * @example
     * // Update many CsvObjTables
     * const csvObjTable = await prisma.csvObjTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CsvObjTables and only return the `csvobjId`
     * const csvObjTableWithCsvobjIdOnly = await prisma.csvObjTable.updateManyAndReturn({
     *   select: { csvobjId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends csvObjTableUpdateManyAndReturnArgs>(args: SelectSubset<T, csvObjTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CsvObjTable.
     * @param {csvObjTableUpsertArgs} args - Arguments to update or create a CsvObjTable.
     * @example
     * // Update or create a CsvObjTable
     * const csvObjTable = await prisma.csvObjTable.upsert({
     *   create: {
     *     // ... data to create a CsvObjTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CsvObjTable we want to update
     *   }
     * })
     */
    upsert<T extends csvObjTableUpsertArgs>(args: SelectSubset<T, csvObjTableUpsertArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CsvObjTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {csvObjTableCountArgs} args - Arguments to filter CsvObjTables to count.
     * @example
     * // Count the number of CsvObjTables
     * const count = await prisma.csvObjTable.count({
     *   where: {
     *     // ... the filter for the CsvObjTables we want to count
     *   }
     * })
    **/
    count<T extends csvObjTableCountArgs>(
      args?: Subset<T, csvObjTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CsvObjTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CsvObjTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CsvObjTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CsvObjTableAggregateArgs>(args: Subset<T, CsvObjTableAggregateArgs>): Prisma.PrismaPromise<GetCsvObjTableAggregateType<T>>

    /**
     * Group by CsvObjTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {csvObjTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends csvObjTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: csvObjTableGroupByArgs['orderBy'] }
        : { orderBy?: csvObjTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, csvObjTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCsvObjTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the csvObjTable model
   */
  readonly fields: csvObjTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for csvObjTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__csvObjTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropTable<T extends csvObjTable$cropTableArgs<ExtArgs> = {}>(args?: Subset<T, csvObjTable$cropTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    landTable<T extends csvObjTable$landTableArgs<ExtArgs> = {}>(args?: Subset<T, csvObjTable$landTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metadataTable<T extends csvObjTable$metadataTableArgs<ExtArgs> = {}>(args?: Subset<T, csvObjTable$metadataTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectsTable<T extends csvObjTable$projectsTableArgs<ExtArgs> = {}>(args?: Subset<T, csvObjTable$projectsTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the csvObjTable model
   */
  interface csvObjTableFieldRefs {
    readonly csvobjId: FieldRef<"csvObjTable", 'String'>
    readonly jsonData: FieldRef<"csvObjTable", 'Json'>
    readonly createdAt: FieldRef<"csvObjTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * csvObjTable findUnique
   */
  export type csvObjTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * Filter, which csvObjTable to fetch.
     */
    where: csvObjTableWhereUniqueInput
  }

  /**
   * csvObjTable findUniqueOrThrow
   */
  export type csvObjTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * Filter, which csvObjTable to fetch.
     */
    where: csvObjTableWhereUniqueInput
  }

  /**
   * csvObjTable findFirst
   */
  export type csvObjTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * Filter, which csvObjTable to fetch.
     */
    where?: csvObjTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of csvObjTables to fetch.
     */
    orderBy?: csvObjTableOrderByWithRelationInput | csvObjTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for csvObjTables.
     */
    cursor?: csvObjTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` csvObjTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` csvObjTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of csvObjTables.
     */
    distinct?: CsvObjTableScalarFieldEnum | CsvObjTableScalarFieldEnum[]
  }

  /**
   * csvObjTable findFirstOrThrow
   */
  export type csvObjTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * Filter, which csvObjTable to fetch.
     */
    where?: csvObjTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of csvObjTables to fetch.
     */
    orderBy?: csvObjTableOrderByWithRelationInput | csvObjTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for csvObjTables.
     */
    cursor?: csvObjTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` csvObjTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` csvObjTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of csvObjTables.
     */
    distinct?: CsvObjTableScalarFieldEnum | CsvObjTableScalarFieldEnum[]
  }

  /**
   * csvObjTable findMany
   */
  export type csvObjTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * Filter, which csvObjTables to fetch.
     */
    where?: csvObjTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of csvObjTables to fetch.
     */
    orderBy?: csvObjTableOrderByWithRelationInput | csvObjTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing csvObjTables.
     */
    cursor?: csvObjTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` csvObjTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` csvObjTables.
     */
    skip?: number
    distinct?: CsvObjTableScalarFieldEnum | CsvObjTableScalarFieldEnum[]
  }

  /**
   * csvObjTable create
   */
  export type csvObjTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * The data needed to create a csvObjTable.
     */
    data: XOR<csvObjTableCreateInput, csvObjTableUncheckedCreateInput>
  }

  /**
   * csvObjTable createMany
   */
  export type csvObjTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many csvObjTables.
     */
    data: csvObjTableCreateManyInput | csvObjTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * csvObjTable createManyAndReturn
   */
  export type csvObjTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * The data used to create many csvObjTables.
     */
    data: csvObjTableCreateManyInput | csvObjTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * csvObjTable update
   */
  export type csvObjTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * The data needed to update a csvObjTable.
     */
    data: XOR<csvObjTableUpdateInput, csvObjTableUncheckedUpdateInput>
    /**
     * Choose, which csvObjTable to update.
     */
    where: csvObjTableWhereUniqueInput
  }

  /**
   * csvObjTable updateMany
   */
  export type csvObjTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update csvObjTables.
     */
    data: XOR<csvObjTableUpdateManyMutationInput, csvObjTableUncheckedUpdateManyInput>
    /**
     * Filter which csvObjTables to update
     */
    where?: csvObjTableWhereInput
    /**
     * Limit how many csvObjTables to update.
     */
    limit?: number
  }

  /**
   * csvObjTable updateManyAndReturn
   */
  export type csvObjTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * The data used to update csvObjTables.
     */
    data: XOR<csvObjTableUpdateManyMutationInput, csvObjTableUncheckedUpdateManyInput>
    /**
     * Filter which csvObjTables to update
     */
    where?: csvObjTableWhereInput
    /**
     * Limit how many csvObjTables to update.
     */
    limit?: number
  }

  /**
   * csvObjTable upsert
   */
  export type csvObjTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * The filter to search for the csvObjTable to update in case it exists.
     */
    where: csvObjTableWhereUniqueInput
    /**
     * In case the csvObjTable found by the `where` argument doesn't exist, create a new csvObjTable with this data.
     */
    create: XOR<csvObjTableCreateInput, csvObjTableUncheckedCreateInput>
    /**
     * In case the csvObjTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<csvObjTableUpdateInput, csvObjTableUncheckedUpdateInput>
  }

  /**
   * csvObjTable delete
   */
  export type csvObjTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    /**
     * Filter which csvObjTable to delete.
     */
    where: csvObjTableWhereUniqueInput
  }

  /**
   * csvObjTable deleteMany
   */
  export type csvObjTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which csvObjTables to delete
     */
    where?: csvObjTableWhereInput
    /**
     * Limit how many csvObjTables to delete.
     */
    limit?: number
  }

  /**
   * csvObjTable.cropTable
   */
  export type csvObjTable$cropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    where?: cropTableWhereInput
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    cursor?: cropTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropTableScalarFieldEnum | CropTableScalarFieldEnum[]
  }

  /**
   * csvObjTable.landTable
   */
  export type csvObjTable$landTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    where?: landTableWhereInput
    orderBy?: landTableOrderByWithRelationInput | landTableOrderByWithRelationInput[]
    cursor?: landTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandTableScalarFieldEnum | LandTableScalarFieldEnum[]
  }

  /**
   * csvObjTable.metadataTable
   */
  export type csvObjTable$metadataTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    where?: metadataTableWhereInput
    orderBy?: metadataTableOrderByWithRelationInput | metadataTableOrderByWithRelationInput[]
    cursor?: metadataTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetadataTableScalarFieldEnum | MetadataTableScalarFieldEnum[]
  }

  /**
   * csvObjTable.projectsTable
   */
  export type csvObjTable$projectsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    where?: projectsTableWhereInput
    orderBy?: projectsTableOrderByWithRelationInput | projectsTableOrderByWithRelationInput[]
    cursor?: projectsTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectsTableScalarFieldEnum | ProjectsTableScalarFieldEnum[]
  }

  /**
   * csvObjTable without action
   */
  export type csvObjTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
  }


  /**
   * Model landStakeholdersTable
   */

  export type AggregateLandStakeholdersTable = {
    _count: LandStakeholdersTableCountAggregateOutputType | null
    _min: LandStakeholdersTableMinAggregateOutputType | null
    _max: LandStakeholdersTableMaxAggregateOutputType | null
  }

  export type LandStakeholdersTableMinAggregateOutputType = {
    landStakeholderId: string | null
    landId: string | null
    organizationId: string | null
    stakeholderTypeId: string | null
  }

  export type LandStakeholdersTableMaxAggregateOutputType = {
    landStakeholderId: string | null
    landId: string | null
    organizationId: string | null
    stakeholderTypeId: string | null
  }

  export type LandStakeholdersTableCountAggregateOutputType = {
    landStakeholderId: number
    landId: number
    organizationId: number
    stakeholderTypeId: number
    _all: number
  }


  export type LandStakeholdersTableMinAggregateInputType = {
    landStakeholderId?: true
    landId?: true
    organizationId?: true
    stakeholderTypeId?: true
  }

  export type LandStakeholdersTableMaxAggregateInputType = {
    landStakeholderId?: true
    landId?: true
    organizationId?: true
    stakeholderTypeId?: true
  }

  export type LandStakeholdersTableCountAggregateInputType = {
    landStakeholderId?: true
    landId?: true
    organizationId?: true
    stakeholderTypeId?: true
    _all?: true
  }

  export type LandStakeholdersTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landStakeholdersTable to aggregate.
     */
    where?: landStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landStakeholdersTables to fetch.
     */
    orderBy?: landStakeholdersTableOrderByWithRelationInput | landStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: landStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned landStakeholdersTables
    **/
    _count?: true | LandStakeholdersTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandStakeholdersTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandStakeholdersTableMaxAggregateInputType
  }

  export type GetLandStakeholdersTableAggregateType<T extends LandStakeholdersTableAggregateArgs> = {
        [P in keyof T & keyof AggregateLandStakeholdersTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandStakeholdersTable[P]>
      : GetScalarType<T[P], AggregateLandStakeholdersTable[P]>
  }




  export type landStakeholdersTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landStakeholdersTableWhereInput
    orderBy?: landStakeholdersTableOrderByWithAggregationInput | landStakeholdersTableOrderByWithAggregationInput[]
    by: LandStakeholdersTableScalarFieldEnum[] | LandStakeholdersTableScalarFieldEnum
    having?: landStakeholdersTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandStakeholdersTableCountAggregateInputType | true
    _min?: LandStakeholdersTableMinAggregateInputType
    _max?: LandStakeholdersTableMaxAggregateInputType
  }

  export type LandStakeholdersTableGroupByOutputType = {
    landStakeholderId: string
    landId: string
    organizationId: string
    stakeholderTypeId: string
    _count: LandStakeholdersTableCountAggregateOutputType | null
    _min: LandStakeholdersTableMinAggregateOutputType | null
    _max: LandStakeholdersTableMaxAggregateOutputType | null
  }

  type GetLandStakeholdersTableGroupByPayload<T extends landStakeholdersTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandStakeholdersTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandStakeholdersTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandStakeholdersTableGroupByOutputType[P]>
            : GetScalarType<T[P], LandStakeholdersTableGroupByOutputType[P]>
        }
      >
    >


  export type landStakeholdersTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    landStakeholderId?: boolean
    landId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    landTable?: boolean | landTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landStakeholdersTable"]>

  export type landStakeholdersTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    landStakeholderId?: boolean
    landId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    landTable?: boolean | landTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landStakeholdersTable"]>

  export type landStakeholdersTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    landStakeholderId?: boolean
    landId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    landTable?: boolean | landTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landStakeholdersTable"]>

  export type landStakeholdersTableSelectScalar = {
    landStakeholderId?: boolean
    landId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
  }

  export type landStakeholdersTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"landStakeholderId" | "landId" | "organizationId" | "stakeholderTypeId", ExtArgs["result"]["landStakeholdersTable"]>
  export type landStakeholdersTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landTable?: boolean | landTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }
  export type landStakeholdersTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landTable?: boolean | landTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }
  export type landStakeholdersTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landTable?: boolean | landTableDefaultArgs<ExtArgs>
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }

  export type $landStakeholdersTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "landStakeholdersTable"
    objects: {
      landTable: Prisma.$landTablePayload<ExtArgs>
      organizationsTable: Prisma.$organizationsTablePayload<ExtArgs>
      stakeholderTypesTable: Prisma.$stakeholderTypesTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      landStakeholderId: string
      landId: string
      organizationId: string
      stakeholderTypeId: string
    }, ExtArgs["result"]["landStakeholdersTable"]>
    composites: {}
  }

  type landStakeholdersTableGetPayload<S extends boolean | null | undefined | landStakeholdersTableDefaultArgs> = $Result.GetResult<Prisma.$landStakeholdersTablePayload, S>

  type landStakeholdersTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<landStakeholdersTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandStakeholdersTableCountAggregateInputType | true
    }

  export interface landStakeholdersTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['landStakeholdersTable'], meta: { name: 'landStakeholdersTable' } }
    /**
     * Find zero or one LandStakeholdersTable that matches the filter.
     * @param {landStakeholdersTableFindUniqueArgs} args - Arguments to find a LandStakeholdersTable
     * @example
     * // Get one LandStakeholdersTable
     * const landStakeholdersTable = await prisma.landStakeholdersTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends landStakeholdersTableFindUniqueArgs>(args: SelectSubset<T, landStakeholdersTableFindUniqueArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LandStakeholdersTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {landStakeholdersTableFindUniqueOrThrowArgs} args - Arguments to find a LandStakeholdersTable
     * @example
     * // Get one LandStakeholdersTable
     * const landStakeholdersTable = await prisma.landStakeholdersTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends landStakeholdersTableFindUniqueOrThrowArgs>(args: SelectSubset<T, landStakeholdersTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandStakeholdersTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landStakeholdersTableFindFirstArgs} args - Arguments to find a LandStakeholdersTable
     * @example
     * // Get one LandStakeholdersTable
     * const landStakeholdersTable = await prisma.landStakeholdersTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends landStakeholdersTableFindFirstArgs>(args?: SelectSubset<T, landStakeholdersTableFindFirstArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandStakeholdersTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landStakeholdersTableFindFirstOrThrowArgs} args - Arguments to find a LandStakeholdersTable
     * @example
     * // Get one LandStakeholdersTable
     * const landStakeholdersTable = await prisma.landStakeholdersTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends landStakeholdersTableFindFirstOrThrowArgs>(args?: SelectSubset<T, landStakeholdersTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LandStakeholdersTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landStakeholdersTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LandStakeholdersTables
     * const landStakeholdersTables = await prisma.landStakeholdersTable.findMany()
     * 
     * // Get first 10 LandStakeholdersTables
     * const landStakeholdersTables = await prisma.landStakeholdersTable.findMany({ take: 10 })
     * 
     * // Only select the `landStakeholderId`
     * const landStakeholdersTableWithLandStakeholderIdOnly = await prisma.landStakeholdersTable.findMany({ select: { landStakeholderId: true } })
     * 
     */
    findMany<T extends landStakeholdersTableFindManyArgs>(args?: SelectSubset<T, landStakeholdersTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LandStakeholdersTable.
     * @param {landStakeholdersTableCreateArgs} args - Arguments to create a LandStakeholdersTable.
     * @example
     * // Create one LandStakeholdersTable
     * const LandStakeholdersTable = await prisma.landStakeholdersTable.create({
     *   data: {
     *     // ... data to create a LandStakeholdersTable
     *   }
     * })
     * 
     */
    create<T extends landStakeholdersTableCreateArgs>(args: SelectSubset<T, landStakeholdersTableCreateArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LandStakeholdersTables.
     * @param {landStakeholdersTableCreateManyArgs} args - Arguments to create many LandStakeholdersTables.
     * @example
     * // Create many LandStakeholdersTables
     * const landStakeholdersTable = await prisma.landStakeholdersTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends landStakeholdersTableCreateManyArgs>(args?: SelectSubset<T, landStakeholdersTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LandStakeholdersTables and returns the data saved in the database.
     * @param {landStakeholdersTableCreateManyAndReturnArgs} args - Arguments to create many LandStakeholdersTables.
     * @example
     * // Create many LandStakeholdersTables
     * const landStakeholdersTable = await prisma.landStakeholdersTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LandStakeholdersTables and only return the `landStakeholderId`
     * const landStakeholdersTableWithLandStakeholderIdOnly = await prisma.landStakeholdersTable.createManyAndReturn({
     *   select: { landStakeholderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends landStakeholdersTableCreateManyAndReturnArgs>(args?: SelectSubset<T, landStakeholdersTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LandStakeholdersTable.
     * @param {landStakeholdersTableDeleteArgs} args - Arguments to delete one LandStakeholdersTable.
     * @example
     * // Delete one LandStakeholdersTable
     * const LandStakeholdersTable = await prisma.landStakeholdersTable.delete({
     *   where: {
     *     // ... filter to delete one LandStakeholdersTable
     *   }
     * })
     * 
     */
    delete<T extends landStakeholdersTableDeleteArgs>(args: SelectSubset<T, landStakeholdersTableDeleteArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LandStakeholdersTable.
     * @param {landStakeholdersTableUpdateArgs} args - Arguments to update one LandStakeholdersTable.
     * @example
     * // Update one LandStakeholdersTable
     * const landStakeholdersTable = await prisma.landStakeholdersTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends landStakeholdersTableUpdateArgs>(args: SelectSubset<T, landStakeholdersTableUpdateArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LandStakeholdersTables.
     * @param {landStakeholdersTableDeleteManyArgs} args - Arguments to filter LandStakeholdersTables to delete.
     * @example
     * // Delete a few LandStakeholdersTables
     * const { count } = await prisma.landStakeholdersTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends landStakeholdersTableDeleteManyArgs>(args?: SelectSubset<T, landStakeholdersTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandStakeholdersTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landStakeholdersTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LandStakeholdersTables
     * const landStakeholdersTable = await prisma.landStakeholdersTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends landStakeholdersTableUpdateManyArgs>(args: SelectSubset<T, landStakeholdersTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandStakeholdersTables and returns the data updated in the database.
     * @param {landStakeholdersTableUpdateManyAndReturnArgs} args - Arguments to update many LandStakeholdersTables.
     * @example
     * // Update many LandStakeholdersTables
     * const landStakeholdersTable = await prisma.landStakeholdersTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LandStakeholdersTables and only return the `landStakeholderId`
     * const landStakeholdersTableWithLandStakeholderIdOnly = await prisma.landStakeholdersTable.updateManyAndReturn({
     *   select: { landStakeholderId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends landStakeholdersTableUpdateManyAndReturnArgs>(args: SelectSubset<T, landStakeholdersTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LandStakeholdersTable.
     * @param {landStakeholdersTableUpsertArgs} args - Arguments to update or create a LandStakeholdersTable.
     * @example
     * // Update or create a LandStakeholdersTable
     * const landStakeholdersTable = await prisma.landStakeholdersTable.upsert({
     *   create: {
     *     // ... data to create a LandStakeholdersTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LandStakeholdersTable we want to update
     *   }
     * })
     */
    upsert<T extends landStakeholdersTableUpsertArgs>(args: SelectSubset<T, landStakeholdersTableUpsertArgs<ExtArgs>>): Prisma__landStakeholdersTableClient<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LandStakeholdersTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landStakeholdersTableCountArgs} args - Arguments to filter LandStakeholdersTables to count.
     * @example
     * // Count the number of LandStakeholdersTables
     * const count = await prisma.landStakeholdersTable.count({
     *   where: {
     *     // ... the filter for the LandStakeholdersTables we want to count
     *   }
     * })
    **/
    count<T extends landStakeholdersTableCountArgs>(
      args?: Subset<T, landStakeholdersTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandStakeholdersTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LandStakeholdersTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandStakeholdersTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandStakeholdersTableAggregateArgs>(args: Subset<T, LandStakeholdersTableAggregateArgs>): Prisma.PrismaPromise<GetLandStakeholdersTableAggregateType<T>>

    /**
     * Group by LandStakeholdersTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landStakeholdersTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends landStakeholdersTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: landStakeholdersTableGroupByArgs['orderBy'] }
        : { orderBy?: landStakeholdersTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, landStakeholdersTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandStakeholdersTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the landStakeholdersTable model
   */
  readonly fields: landStakeholdersTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for landStakeholdersTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__landStakeholdersTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landTable<T extends landTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, landTableDefaultArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organizationsTable<T extends organizationsTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTableDefaultArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stakeholderTypesTable<T extends stakeholderTypesTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderTypesTableDefaultArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the landStakeholdersTable model
   */
  interface landStakeholdersTableFieldRefs {
    readonly landStakeholderId: FieldRef<"landStakeholdersTable", 'String'>
    readonly landId: FieldRef<"landStakeholdersTable", 'String'>
    readonly organizationId: FieldRef<"landStakeholdersTable", 'String'>
    readonly stakeholderTypeId: FieldRef<"landStakeholdersTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * landStakeholdersTable findUnique
   */
  export type landStakeholdersTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which landStakeholdersTable to fetch.
     */
    where: landStakeholdersTableWhereUniqueInput
  }

  /**
   * landStakeholdersTable findUniqueOrThrow
   */
  export type landStakeholdersTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which landStakeholdersTable to fetch.
     */
    where: landStakeholdersTableWhereUniqueInput
  }

  /**
   * landStakeholdersTable findFirst
   */
  export type landStakeholdersTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which landStakeholdersTable to fetch.
     */
    where?: landStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landStakeholdersTables to fetch.
     */
    orderBy?: landStakeholdersTableOrderByWithRelationInput | landStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landStakeholdersTables.
     */
    cursor?: landStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landStakeholdersTables.
     */
    distinct?: LandStakeholdersTableScalarFieldEnum | LandStakeholdersTableScalarFieldEnum[]
  }

  /**
   * landStakeholdersTable findFirstOrThrow
   */
  export type landStakeholdersTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which landStakeholdersTable to fetch.
     */
    where?: landStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landStakeholdersTables to fetch.
     */
    orderBy?: landStakeholdersTableOrderByWithRelationInput | landStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landStakeholdersTables.
     */
    cursor?: landStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landStakeholdersTables.
     */
    distinct?: LandStakeholdersTableScalarFieldEnum | LandStakeholdersTableScalarFieldEnum[]
  }

  /**
   * landStakeholdersTable findMany
   */
  export type landStakeholdersTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which landStakeholdersTables to fetch.
     */
    where?: landStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landStakeholdersTables to fetch.
     */
    orderBy?: landStakeholdersTableOrderByWithRelationInput | landStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing landStakeholdersTables.
     */
    cursor?: landStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landStakeholdersTables.
     */
    skip?: number
    distinct?: LandStakeholdersTableScalarFieldEnum | LandStakeholdersTableScalarFieldEnum[]
  }

  /**
   * landStakeholdersTable create
   */
  export type landStakeholdersTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * The data needed to create a landStakeholdersTable.
     */
    data: XOR<landStakeholdersTableCreateInput, landStakeholdersTableUncheckedCreateInput>
  }

  /**
   * landStakeholdersTable createMany
   */
  export type landStakeholdersTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many landStakeholdersTables.
     */
    data: landStakeholdersTableCreateManyInput | landStakeholdersTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * landStakeholdersTable createManyAndReturn
   */
  export type landStakeholdersTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * The data used to create many landStakeholdersTables.
     */
    data: landStakeholdersTableCreateManyInput | landStakeholdersTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * landStakeholdersTable update
   */
  export type landStakeholdersTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * The data needed to update a landStakeholdersTable.
     */
    data: XOR<landStakeholdersTableUpdateInput, landStakeholdersTableUncheckedUpdateInput>
    /**
     * Choose, which landStakeholdersTable to update.
     */
    where: landStakeholdersTableWhereUniqueInput
  }

  /**
   * landStakeholdersTable updateMany
   */
  export type landStakeholdersTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update landStakeholdersTables.
     */
    data: XOR<landStakeholdersTableUpdateManyMutationInput, landStakeholdersTableUncheckedUpdateManyInput>
    /**
     * Filter which landStakeholdersTables to update
     */
    where?: landStakeholdersTableWhereInput
    /**
     * Limit how many landStakeholdersTables to update.
     */
    limit?: number
  }

  /**
   * landStakeholdersTable updateManyAndReturn
   */
  export type landStakeholdersTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * The data used to update landStakeholdersTables.
     */
    data: XOR<landStakeholdersTableUpdateManyMutationInput, landStakeholdersTableUncheckedUpdateManyInput>
    /**
     * Filter which landStakeholdersTables to update
     */
    where?: landStakeholdersTableWhereInput
    /**
     * Limit how many landStakeholdersTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * landStakeholdersTable upsert
   */
  export type landStakeholdersTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * The filter to search for the landStakeholdersTable to update in case it exists.
     */
    where: landStakeholdersTableWhereUniqueInput
    /**
     * In case the landStakeholdersTable found by the `where` argument doesn't exist, create a new landStakeholdersTable with this data.
     */
    create: XOR<landStakeholdersTableCreateInput, landStakeholdersTableUncheckedCreateInput>
    /**
     * In case the landStakeholdersTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<landStakeholdersTableUpdateInput, landStakeholdersTableUncheckedUpdateInput>
  }

  /**
   * landStakeholdersTable delete
   */
  export type landStakeholdersTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter which landStakeholdersTable to delete.
     */
    where: landStakeholdersTableWhereUniqueInput
  }

  /**
   * landStakeholdersTable deleteMany
   */
  export type landStakeholdersTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landStakeholdersTables to delete
     */
    where?: landStakeholdersTableWhereInput
    /**
     * Limit how many landStakeholdersTables to delete.
     */
    limit?: number
  }

  /**
   * landStakeholdersTable without action
   */
  export type landStakeholdersTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
  }


  /**
   * Model landTable
   */

  export type AggregateLandTable = {
    _count: LandTableCountAggregateOutputType | null
    _avg: LandTableAvgAggregateOutputType | null
    _sum: LandTableSumAggregateOutputType | null
    _min: LandTableMinAggregateOutputType | null
    _max: LandTableMaxAggregateOutputType | null
  }

  export type LandTableAvgAggregateOutputType = {
    hectares: Decimal | null
    gpsLat: Decimal | null
    gpsLon: Decimal | null
  }

  export type LandTableSumAggregateOutputType = {
    hectares: Decimal | null
    gpsLat: Decimal | null
    gpsLon: Decimal | null
  }

  export type LandTableMinAggregateOutputType = {
    landId: string | null
    landName: string | null
    projectId: string | null
    hectares: Decimal | null
    gpsLat: Decimal | null
    gpsLon: Decimal | null
    landNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    preparation: $Enums.Preparation | null
    csvobjId: string | null
  }

  export type LandTableMaxAggregateOutputType = {
    landId: string | null
    landName: string | null
    projectId: string | null
    hectares: Decimal | null
    gpsLat: Decimal | null
    gpsLon: Decimal | null
    landNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    preparation: $Enums.Preparation | null
    csvobjId: string | null
  }

  export type LandTableCountAggregateOutputType = {
    landId: number
    landName: number
    projectId: number
    hectares: number
    gpsLat: number
    gpsLon: number
    landNotes: number
    createdAt: number
    lastEditedAt: number
    editedBy: number
    deleted: number
    preparation: number
    csvobjId: number
    polygon: number
    _all: number
  }


  export type LandTableAvgAggregateInputType = {
    hectares?: true
    gpsLat?: true
    gpsLon?: true
  }

  export type LandTableSumAggregateInputType = {
    hectares?: true
    gpsLat?: true
    gpsLon?: true
  }

  export type LandTableMinAggregateInputType = {
    landId?: true
    landName?: true
    projectId?: true
    hectares?: true
    gpsLat?: true
    gpsLon?: true
    landNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    preparation?: true
    csvobjId?: true
  }

  export type LandTableMaxAggregateInputType = {
    landId?: true
    landName?: true
    projectId?: true
    hectares?: true
    gpsLat?: true
    gpsLon?: true
    landNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    preparation?: true
    csvobjId?: true
  }

  export type LandTableCountAggregateInputType = {
    landId?: true
    landName?: true
    projectId?: true
    hectares?: true
    gpsLat?: true
    gpsLon?: true
    landNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    preparation?: true
    csvobjId?: true
    polygon?: true
    _all?: true
  }

  export type LandTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landTable to aggregate.
     */
    where?: landTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landTables to fetch.
     */
    orderBy?: landTableOrderByWithRelationInput | landTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: landTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned landTables
    **/
    _count?: true | LandTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandTableMaxAggregateInputType
  }

  export type GetLandTableAggregateType<T extends LandTableAggregateArgs> = {
        [P in keyof T & keyof AggregateLandTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandTable[P]>
      : GetScalarType<T[P], AggregateLandTable[P]>
  }




  export type landTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landTableWhereInput
    orderBy?: landTableOrderByWithAggregationInput | landTableOrderByWithAggregationInput[]
    by: LandTableScalarFieldEnum[] | LandTableScalarFieldEnum
    having?: landTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandTableCountAggregateInputType | true
    _avg?: LandTableAvgAggregateInputType
    _sum?: LandTableSumAggregateInputType
    _min?: LandTableMinAggregateInputType
    _max?: LandTableMaxAggregateInputType
  }

  export type LandTableGroupByOutputType = {
    landId: string
    landName: string
    projectId: string | null
    hectares: Decimal | null
    gpsLat: Decimal | null
    gpsLon: Decimal | null
    landNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    preparation: $Enums.Preparation | null
    csvobjId: string | null
    polygon: JsonValue | null
    _count: LandTableCountAggregateOutputType | null
    _avg: LandTableAvgAggregateOutputType | null
    _sum: LandTableSumAggregateOutputType | null
    _min: LandTableMinAggregateOutputType | null
    _max: LandTableMaxAggregateOutputType | null
  }

  type GetLandTableGroupByPayload<T extends landTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandTableGroupByOutputType[P]>
            : GetScalarType<T[P], LandTableGroupByOutputType[P]>
        }
      >
    >


  export type landTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    landId?: boolean
    landName?: boolean
    projectId?: boolean
    hectares?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    landNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    preparation?: boolean
    csvobjId?: boolean
    polygon?: boolean
    landStakeholdersTable?: boolean | landTable$landStakeholdersTableArgs<ExtArgs>
    csvObjTable?: boolean | landTable$csvObjTableArgs<ExtArgs>
    projectsTable?: boolean | landTable$projectsTableArgs<ExtArgs>
    plantingTable?: boolean | landTable$plantingTableArgs<ExtArgs>
    _count?: boolean | LandTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landTable"]>

  export type landTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    landId?: boolean
    landName?: boolean
    projectId?: boolean
    hectares?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    landNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    preparation?: boolean
    csvobjId?: boolean
    polygon?: boolean
    csvObjTable?: boolean | landTable$csvObjTableArgs<ExtArgs>
    projectsTable?: boolean | landTable$projectsTableArgs<ExtArgs>
  }, ExtArgs["result"]["landTable"]>

  export type landTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    landId?: boolean
    landName?: boolean
    projectId?: boolean
    hectares?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    landNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    preparation?: boolean
    csvobjId?: boolean
    polygon?: boolean
    csvObjTable?: boolean | landTable$csvObjTableArgs<ExtArgs>
    projectsTable?: boolean | landTable$projectsTableArgs<ExtArgs>
  }, ExtArgs["result"]["landTable"]>

  export type landTableSelectScalar = {
    landId?: boolean
    landName?: boolean
    projectId?: boolean
    hectares?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    landNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    preparation?: boolean
    csvobjId?: boolean
    polygon?: boolean
  }

  export type landTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"landId" | "landName" | "projectId" | "hectares" | "gpsLat" | "gpsLon" | "landNotes" | "createdAt" | "lastEditedAt" | "editedBy" | "deleted" | "preparation" | "csvobjId" | "polygon", ExtArgs["result"]["landTable"]>
  export type landTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landStakeholdersTable?: boolean | landTable$landStakeholdersTableArgs<ExtArgs>
    csvObjTable?: boolean | landTable$csvObjTableArgs<ExtArgs>
    projectsTable?: boolean | landTable$projectsTableArgs<ExtArgs>
    plantingTable?: boolean | landTable$plantingTableArgs<ExtArgs>
    _count?: boolean | LandTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type landTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | landTable$csvObjTableArgs<ExtArgs>
    projectsTable?: boolean | landTable$projectsTableArgs<ExtArgs>
  }
  export type landTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | landTable$csvObjTableArgs<ExtArgs>
    projectsTable?: boolean | landTable$projectsTableArgs<ExtArgs>
  }

  export type $landTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "landTable"
    objects: {
      landStakeholdersTable: Prisma.$landStakeholdersTablePayload<ExtArgs>[]
      csvObjTable: Prisma.$csvObjTablePayload<ExtArgs> | null
      projectsTable: Prisma.$projectsTablePayload<ExtArgs> | null
      plantingTable: Prisma.$plantingTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      landId: string
      landName: string
      projectId: string | null
      hectares: Prisma.Decimal | null
      gpsLat: Prisma.Decimal | null
      gpsLon: Prisma.Decimal | null
      landNotes: string | null
      createdAt: Date | null
      lastEditedAt: Date | null
      editedBy: string | null
      deleted: boolean | null
      preparation: $Enums.Preparation | null
      csvobjId: string | null
      polygon: Prisma.JsonValue | null
    }, ExtArgs["result"]["landTable"]>
    composites: {}
  }

  type landTableGetPayload<S extends boolean | null | undefined | landTableDefaultArgs> = $Result.GetResult<Prisma.$landTablePayload, S>

  type landTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<landTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandTableCountAggregateInputType | true
    }

  export interface landTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['landTable'], meta: { name: 'landTable' } }
    /**
     * Find zero or one LandTable that matches the filter.
     * @param {landTableFindUniqueArgs} args - Arguments to find a LandTable
     * @example
     * // Get one LandTable
     * const landTable = await prisma.landTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends landTableFindUniqueArgs>(args: SelectSubset<T, landTableFindUniqueArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LandTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {landTableFindUniqueOrThrowArgs} args - Arguments to find a LandTable
     * @example
     * // Get one LandTable
     * const landTable = await prisma.landTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends landTableFindUniqueOrThrowArgs>(args: SelectSubset<T, landTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landTableFindFirstArgs} args - Arguments to find a LandTable
     * @example
     * // Get one LandTable
     * const landTable = await prisma.landTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends landTableFindFirstArgs>(args?: SelectSubset<T, landTableFindFirstArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landTableFindFirstOrThrowArgs} args - Arguments to find a LandTable
     * @example
     * // Get one LandTable
     * const landTable = await prisma.landTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends landTableFindFirstOrThrowArgs>(args?: SelectSubset<T, landTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LandTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LandTables
     * const landTables = await prisma.landTable.findMany()
     * 
     * // Get first 10 LandTables
     * const landTables = await prisma.landTable.findMany({ take: 10 })
     * 
     * // Only select the `landId`
     * const landTableWithLandIdOnly = await prisma.landTable.findMany({ select: { landId: true } })
     * 
     */
    findMany<T extends landTableFindManyArgs>(args?: SelectSubset<T, landTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LandTable.
     * @param {landTableCreateArgs} args - Arguments to create a LandTable.
     * @example
     * // Create one LandTable
     * const LandTable = await prisma.landTable.create({
     *   data: {
     *     // ... data to create a LandTable
     *   }
     * })
     * 
     */
    create<T extends landTableCreateArgs>(args: SelectSubset<T, landTableCreateArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LandTables.
     * @param {landTableCreateManyArgs} args - Arguments to create many LandTables.
     * @example
     * // Create many LandTables
     * const landTable = await prisma.landTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends landTableCreateManyArgs>(args?: SelectSubset<T, landTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LandTables and returns the data saved in the database.
     * @param {landTableCreateManyAndReturnArgs} args - Arguments to create many LandTables.
     * @example
     * // Create many LandTables
     * const landTable = await prisma.landTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LandTables and only return the `landId`
     * const landTableWithLandIdOnly = await prisma.landTable.createManyAndReturn({
     *   select: { landId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends landTableCreateManyAndReturnArgs>(args?: SelectSubset<T, landTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LandTable.
     * @param {landTableDeleteArgs} args - Arguments to delete one LandTable.
     * @example
     * // Delete one LandTable
     * const LandTable = await prisma.landTable.delete({
     *   where: {
     *     // ... filter to delete one LandTable
     *   }
     * })
     * 
     */
    delete<T extends landTableDeleteArgs>(args: SelectSubset<T, landTableDeleteArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LandTable.
     * @param {landTableUpdateArgs} args - Arguments to update one LandTable.
     * @example
     * // Update one LandTable
     * const landTable = await prisma.landTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends landTableUpdateArgs>(args: SelectSubset<T, landTableUpdateArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LandTables.
     * @param {landTableDeleteManyArgs} args - Arguments to filter LandTables to delete.
     * @example
     * // Delete a few LandTables
     * const { count } = await prisma.landTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends landTableDeleteManyArgs>(args?: SelectSubset<T, landTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LandTables
     * const landTable = await prisma.landTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends landTableUpdateManyArgs>(args: SelectSubset<T, landTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandTables and returns the data updated in the database.
     * @param {landTableUpdateManyAndReturnArgs} args - Arguments to update many LandTables.
     * @example
     * // Update many LandTables
     * const landTable = await prisma.landTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LandTables and only return the `landId`
     * const landTableWithLandIdOnly = await prisma.landTable.updateManyAndReturn({
     *   select: { landId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends landTableUpdateManyAndReturnArgs>(args: SelectSubset<T, landTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LandTable.
     * @param {landTableUpsertArgs} args - Arguments to update or create a LandTable.
     * @example
     * // Update or create a LandTable
     * const landTable = await prisma.landTable.upsert({
     *   create: {
     *     // ... data to create a LandTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LandTable we want to update
     *   }
     * })
     */
    upsert<T extends landTableUpsertArgs>(args: SelectSubset<T, landTableUpsertArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LandTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landTableCountArgs} args - Arguments to filter LandTables to count.
     * @example
     * // Count the number of LandTables
     * const count = await prisma.landTable.count({
     *   where: {
     *     // ... the filter for the LandTables we want to count
     *   }
     * })
    **/
    count<T extends landTableCountArgs>(
      args?: Subset<T, landTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LandTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandTableAggregateArgs>(args: Subset<T, LandTableAggregateArgs>): Prisma.PrismaPromise<GetLandTableAggregateType<T>>

    /**
     * Group by LandTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends landTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: landTableGroupByArgs['orderBy'] }
        : { orderBy?: landTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, landTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the landTable model
   */
  readonly fields: landTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for landTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__landTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landStakeholdersTable<T extends landTable$landStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, landTable$landStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    csvObjTable<T extends landTable$csvObjTableArgs<ExtArgs> = {}>(args?: Subset<T, landTable$csvObjTableArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    projectsTable<T extends landTable$projectsTableArgs<ExtArgs> = {}>(args?: Subset<T, landTable$projectsTableArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plantingTable<T extends landTable$plantingTableArgs<ExtArgs> = {}>(args?: Subset<T, landTable$plantingTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the landTable model
   */
  interface landTableFieldRefs {
    readonly landId: FieldRef<"landTable", 'String'>
    readonly landName: FieldRef<"landTable", 'String'>
    readonly projectId: FieldRef<"landTable", 'String'>
    readonly hectares: FieldRef<"landTable", 'Decimal'>
    readonly gpsLat: FieldRef<"landTable", 'Decimal'>
    readonly gpsLon: FieldRef<"landTable", 'Decimal'>
    readonly landNotes: FieldRef<"landTable", 'String'>
    readonly createdAt: FieldRef<"landTable", 'DateTime'>
    readonly lastEditedAt: FieldRef<"landTable", 'DateTime'>
    readonly editedBy: FieldRef<"landTable", 'String'>
    readonly deleted: FieldRef<"landTable", 'Boolean'>
    readonly preparation: FieldRef<"landTable", 'Preparation'>
    readonly csvobjId: FieldRef<"landTable", 'String'>
    readonly polygon: FieldRef<"landTable", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * landTable findUnique
   */
  export type landTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * Filter, which landTable to fetch.
     */
    where: landTableWhereUniqueInput
  }

  /**
   * landTable findUniqueOrThrow
   */
  export type landTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * Filter, which landTable to fetch.
     */
    where: landTableWhereUniqueInput
  }

  /**
   * landTable findFirst
   */
  export type landTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * Filter, which landTable to fetch.
     */
    where?: landTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landTables to fetch.
     */
    orderBy?: landTableOrderByWithRelationInput | landTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landTables.
     */
    cursor?: landTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landTables.
     */
    distinct?: LandTableScalarFieldEnum | LandTableScalarFieldEnum[]
  }

  /**
   * landTable findFirstOrThrow
   */
  export type landTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * Filter, which landTable to fetch.
     */
    where?: landTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landTables to fetch.
     */
    orderBy?: landTableOrderByWithRelationInput | landTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landTables.
     */
    cursor?: landTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landTables.
     */
    distinct?: LandTableScalarFieldEnum | LandTableScalarFieldEnum[]
  }

  /**
   * landTable findMany
   */
  export type landTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * Filter, which landTables to fetch.
     */
    where?: landTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landTables to fetch.
     */
    orderBy?: landTableOrderByWithRelationInput | landTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing landTables.
     */
    cursor?: landTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landTables.
     */
    skip?: number
    distinct?: LandTableScalarFieldEnum | LandTableScalarFieldEnum[]
  }

  /**
   * landTable create
   */
  export type landTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * The data needed to create a landTable.
     */
    data: XOR<landTableCreateInput, landTableUncheckedCreateInput>
  }

  /**
   * landTable createMany
   */
  export type landTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many landTables.
     */
    data: landTableCreateManyInput | landTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * landTable createManyAndReturn
   */
  export type landTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * The data used to create many landTables.
     */
    data: landTableCreateManyInput | landTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * landTable update
   */
  export type landTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * The data needed to update a landTable.
     */
    data: XOR<landTableUpdateInput, landTableUncheckedUpdateInput>
    /**
     * Choose, which landTable to update.
     */
    where: landTableWhereUniqueInput
  }

  /**
   * landTable updateMany
   */
  export type landTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update landTables.
     */
    data: XOR<landTableUpdateManyMutationInput, landTableUncheckedUpdateManyInput>
    /**
     * Filter which landTables to update
     */
    where?: landTableWhereInput
    /**
     * Limit how many landTables to update.
     */
    limit?: number
  }

  /**
   * landTable updateManyAndReturn
   */
  export type landTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * The data used to update landTables.
     */
    data: XOR<landTableUpdateManyMutationInput, landTableUncheckedUpdateManyInput>
    /**
     * Filter which landTables to update
     */
    where?: landTableWhereInput
    /**
     * Limit how many landTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * landTable upsert
   */
  export type landTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * The filter to search for the landTable to update in case it exists.
     */
    where: landTableWhereUniqueInput
    /**
     * In case the landTable found by the `where` argument doesn't exist, create a new landTable with this data.
     */
    create: XOR<landTableCreateInput, landTableUncheckedCreateInput>
    /**
     * In case the landTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<landTableUpdateInput, landTableUncheckedUpdateInput>
  }

  /**
   * landTable delete
   */
  export type landTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    /**
     * Filter which landTable to delete.
     */
    where: landTableWhereUniqueInput
  }

  /**
   * landTable deleteMany
   */
  export type landTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landTables to delete
     */
    where?: landTableWhereInput
    /**
     * Limit how many landTables to delete.
     */
    limit?: number
  }

  /**
   * landTable.landStakeholdersTable
   */
  export type landTable$landStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    where?: landStakeholdersTableWhereInput
    orderBy?: landStakeholdersTableOrderByWithRelationInput | landStakeholdersTableOrderByWithRelationInput[]
    cursor?: landStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandStakeholdersTableScalarFieldEnum | LandStakeholdersTableScalarFieldEnum[]
  }

  /**
   * landTable.csvObjTable
   */
  export type landTable$csvObjTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    where?: csvObjTableWhereInput
  }

  /**
   * landTable.projectsTable
   */
  export type landTable$projectsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    where?: projectsTableWhereInput
  }

  /**
   * landTable.plantingTable
   */
  export type landTable$plantingTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    where?: plantingTableWhereInput
    orderBy?: plantingTableOrderByWithRelationInput | plantingTableOrderByWithRelationInput[]
    cursor?: plantingTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantingTableScalarFieldEnum | PlantingTableScalarFieldEnum[]
  }

  /**
   * landTable without action
   */
  export type landTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
  }


  /**
   * Model metadataTable
   */

  export type AggregateMetadataTable = {
    _count: MetadataTableCountAggregateOutputType | null
    _min: MetadataTableMinAggregateOutputType | null
    _max: MetadataTableMaxAggregateOutputType | null
  }

  export type MetadataTableMinAggregateOutputType = {
    metadataId: string | null
    csvobjId: string | null
    csvKey: string | null
    dbKey: string | null
    createdAt: Date | null
  }

  export type MetadataTableMaxAggregateOutputType = {
    metadataId: string | null
    csvobjId: string | null
    csvKey: string | null
    dbKey: string | null
    createdAt: Date | null
  }

  export type MetadataTableCountAggregateOutputType = {
    metadataId: number
    csvobjId: number
    csvKey: number
    dbKey: number
    createdAt: number
    _all: number
  }


  export type MetadataTableMinAggregateInputType = {
    metadataId?: true
    csvobjId?: true
    csvKey?: true
    dbKey?: true
    createdAt?: true
  }

  export type MetadataTableMaxAggregateInputType = {
    metadataId?: true
    csvobjId?: true
    csvKey?: true
    dbKey?: true
    createdAt?: true
  }

  export type MetadataTableCountAggregateInputType = {
    metadataId?: true
    csvobjId?: true
    csvKey?: true
    dbKey?: true
    createdAt?: true
    _all?: true
  }

  export type MetadataTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which metadataTable to aggregate.
     */
    where?: metadataTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metadataTables to fetch.
     */
    orderBy?: metadataTableOrderByWithRelationInput | metadataTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: metadataTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metadataTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metadataTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned metadataTables
    **/
    _count?: true | MetadataTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetadataTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetadataTableMaxAggregateInputType
  }

  export type GetMetadataTableAggregateType<T extends MetadataTableAggregateArgs> = {
        [P in keyof T & keyof AggregateMetadataTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetadataTable[P]>
      : GetScalarType<T[P], AggregateMetadataTable[P]>
  }




  export type metadataTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metadataTableWhereInput
    orderBy?: metadataTableOrderByWithAggregationInput | metadataTableOrderByWithAggregationInput[]
    by: MetadataTableScalarFieldEnum[] | MetadataTableScalarFieldEnum
    having?: metadataTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetadataTableCountAggregateInputType | true
    _min?: MetadataTableMinAggregateInputType
    _max?: MetadataTableMaxAggregateInputType
  }

  export type MetadataTableGroupByOutputType = {
    metadataId: string
    csvobjId: string
    csvKey: string
    dbKey: string
    createdAt: Date | null
    _count: MetadataTableCountAggregateOutputType | null
    _min: MetadataTableMinAggregateOutputType | null
    _max: MetadataTableMaxAggregateOutputType | null
  }

  type GetMetadataTableGroupByPayload<T extends metadataTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetadataTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetadataTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetadataTableGroupByOutputType[P]>
            : GetScalarType<T[P], MetadataTableGroupByOutputType[P]>
        }
      >
    >


  export type metadataTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    metadataId?: boolean
    csvobjId?: boolean
    csvKey?: boolean
    dbKey?: boolean
    createdAt?: boolean
    csvObjTable?: boolean | csvObjTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metadataTable"]>

  export type metadataTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    metadataId?: boolean
    csvobjId?: boolean
    csvKey?: boolean
    dbKey?: boolean
    createdAt?: boolean
    csvObjTable?: boolean | csvObjTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metadataTable"]>

  export type metadataTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    metadataId?: boolean
    csvobjId?: boolean
    csvKey?: boolean
    dbKey?: boolean
    createdAt?: boolean
    csvObjTable?: boolean | csvObjTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metadataTable"]>

  export type metadataTableSelectScalar = {
    metadataId?: boolean
    csvobjId?: boolean
    csvKey?: boolean
    dbKey?: boolean
    createdAt?: boolean
  }

  export type metadataTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"metadataId" | "csvobjId" | "csvKey" | "dbKey" | "createdAt", ExtArgs["result"]["metadataTable"]>
  export type metadataTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | csvObjTableDefaultArgs<ExtArgs>
  }
  export type metadataTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | csvObjTableDefaultArgs<ExtArgs>
  }
  export type metadataTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | csvObjTableDefaultArgs<ExtArgs>
  }

  export type $metadataTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "metadataTable"
    objects: {
      csvObjTable: Prisma.$csvObjTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      metadataId: string
      csvobjId: string
      csvKey: string
      dbKey: string
      createdAt: Date | null
    }, ExtArgs["result"]["metadataTable"]>
    composites: {}
  }

  type metadataTableGetPayload<S extends boolean | null | undefined | metadataTableDefaultArgs> = $Result.GetResult<Prisma.$metadataTablePayload, S>

  type metadataTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<metadataTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetadataTableCountAggregateInputType | true
    }

  export interface metadataTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['metadataTable'], meta: { name: 'metadataTable' } }
    /**
     * Find zero or one MetadataTable that matches the filter.
     * @param {metadataTableFindUniqueArgs} args - Arguments to find a MetadataTable
     * @example
     * // Get one MetadataTable
     * const metadataTable = await prisma.metadataTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends metadataTableFindUniqueArgs>(args: SelectSubset<T, metadataTableFindUniqueArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MetadataTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {metadataTableFindUniqueOrThrowArgs} args - Arguments to find a MetadataTable
     * @example
     * // Get one MetadataTable
     * const metadataTable = await prisma.metadataTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends metadataTableFindUniqueOrThrowArgs>(args: SelectSubset<T, metadataTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetadataTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metadataTableFindFirstArgs} args - Arguments to find a MetadataTable
     * @example
     * // Get one MetadataTable
     * const metadataTable = await prisma.metadataTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends metadataTableFindFirstArgs>(args?: SelectSubset<T, metadataTableFindFirstArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetadataTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metadataTableFindFirstOrThrowArgs} args - Arguments to find a MetadataTable
     * @example
     * // Get one MetadataTable
     * const metadataTable = await prisma.metadataTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends metadataTableFindFirstOrThrowArgs>(args?: SelectSubset<T, metadataTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MetadataTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metadataTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetadataTables
     * const metadataTables = await prisma.metadataTable.findMany()
     * 
     * // Get first 10 MetadataTables
     * const metadataTables = await prisma.metadataTable.findMany({ take: 10 })
     * 
     * // Only select the `metadataId`
     * const metadataTableWithMetadataIdOnly = await prisma.metadataTable.findMany({ select: { metadataId: true } })
     * 
     */
    findMany<T extends metadataTableFindManyArgs>(args?: SelectSubset<T, metadataTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MetadataTable.
     * @param {metadataTableCreateArgs} args - Arguments to create a MetadataTable.
     * @example
     * // Create one MetadataTable
     * const MetadataTable = await prisma.metadataTable.create({
     *   data: {
     *     // ... data to create a MetadataTable
     *   }
     * })
     * 
     */
    create<T extends metadataTableCreateArgs>(args: SelectSubset<T, metadataTableCreateArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MetadataTables.
     * @param {metadataTableCreateManyArgs} args - Arguments to create many MetadataTables.
     * @example
     * // Create many MetadataTables
     * const metadataTable = await prisma.metadataTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends metadataTableCreateManyArgs>(args?: SelectSubset<T, metadataTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MetadataTables and returns the data saved in the database.
     * @param {metadataTableCreateManyAndReturnArgs} args - Arguments to create many MetadataTables.
     * @example
     * // Create many MetadataTables
     * const metadataTable = await prisma.metadataTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MetadataTables and only return the `metadataId`
     * const metadataTableWithMetadataIdOnly = await prisma.metadataTable.createManyAndReturn({
     *   select: { metadataId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends metadataTableCreateManyAndReturnArgs>(args?: SelectSubset<T, metadataTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MetadataTable.
     * @param {metadataTableDeleteArgs} args - Arguments to delete one MetadataTable.
     * @example
     * // Delete one MetadataTable
     * const MetadataTable = await prisma.metadataTable.delete({
     *   where: {
     *     // ... filter to delete one MetadataTable
     *   }
     * })
     * 
     */
    delete<T extends metadataTableDeleteArgs>(args: SelectSubset<T, metadataTableDeleteArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MetadataTable.
     * @param {metadataTableUpdateArgs} args - Arguments to update one MetadataTable.
     * @example
     * // Update one MetadataTable
     * const metadataTable = await prisma.metadataTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends metadataTableUpdateArgs>(args: SelectSubset<T, metadataTableUpdateArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MetadataTables.
     * @param {metadataTableDeleteManyArgs} args - Arguments to filter MetadataTables to delete.
     * @example
     * // Delete a few MetadataTables
     * const { count } = await prisma.metadataTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends metadataTableDeleteManyArgs>(args?: SelectSubset<T, metadataTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetadataTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metadataTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetadataTables
     * const metadataTable = await prisma.metadataTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends metadataTableUpdateManyArgs>(args: SelectSubset<T, metadataTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetadataTables and returns the data updated in the database.
     * @param {metadataTableUpdateManyAndReturnArgs} args - Arguments to update many MetadataTables.
     * @example
     * // Update many MetadataTables
     * const metadataTable = await prisma.metadataTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MetadataTables and only return the `metadataId`
     * const metadataTableWithMetadataIdOnly = await prisma.metadataTable.updateManyAndReturn({
     *   select: { metadataId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends metadataTableUpdateManyAndReturnArgs>(args: SelectSubset<T, metadataTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MetadataTable.
     * @param {metadataTableUpsertArgs} args - Arguments to update or create a MetadataTable.
     * @example
     * // Update or create a MetadataTable
     * const metadataTable = await prisma.metadataTable.upsert({
     *   create: {
     *     // ... data to create a MetadataTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetadataTable we want to update
     *   }
     * })
     */
    upsert<T extends metadataTableUpsertArgs>(args: SelectSubset<T, metadataTableUpsertArgs<ExtArgs>>): Prisma__metadataTableClient<$Result.GetResult<Prisma.$metadataTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MetadataTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metadataTableCountArgs} args - Arguments to filter MetadataTables to count.
     * @example
     * // Count the number of MetadataTables
     * const count = await prisma.metadataTable.count({
     *   where: {
     *     // ... the filter for the MetadataTables we want to count
     *   }
     * })
    **/
    count<T extends metadataTableCountArgs>(
      args?: Subset<T, metadataTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetadataTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetadataTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetadataTableAggregateArgs>(args: Subset<T, MetadataTableAggregateArgs>): Prisma.PrismaPromise<GetMetadataTableAggregateType<T>>

    /**
     * Group by MetadataTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metadataTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends metadataTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: metadataTableGroupByArgs['orderBy'] }
        : { orderBy?: metadataTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, metadataTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetadataTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the metadataTable model
   */
  readonly fields: metadataTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for metadataTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__metadataTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    csvObjTable<T extends csvObjTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, csvObjTableDefaultArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the metadataTable model
   */
  interface metadataTableFieldRefs {
    readonly metadataId: FieldRef<"metadataTable", 'String'>
    readonly csvobjId: FieldRef<"metadataTable", 'String'>
    readonly csvKey: FieldRef<"metadataTable", 'String'>
    readonly dbKey: FieldRef<"metadataTable", 'String'>
    readonly createdAt: FieldRef<"metadataTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * metadataTable findUnique
   */
  export type metadataTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * Filter, which metadataTable to fetch.
     */
    where: metadataTableWhereUniqueInput
  }

  /**
   * metadataTable findUniqueOrThrow
   */
  export type metadataTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * Filter, which metadataTable to fetch.
     */
    where: metadataTableWhereUniqueInput
  }

  /**
   * metadataTable findFirst
   */
  export type metadataTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * Filter, which metadataTable to fetch.
     */
    where?: metadataTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metadataTables to fetch.
     */
    orderBy?: metadataTableOrderByWithRelationInput | metadataTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metadataTables.
     */
    cursor?: metadataTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metadataTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metadataTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metadataTables.
     */
    distinct?: MetadataTableScalarFieldEnum | MetadataTableScalarFieldEnum[]
  }

  /**
   * metadataTable findFirstOrThrow
   */
  export type metadataTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * Filter, which metadataTable to fetch.
     */
    where?: metadataTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metadataTables to fetch.
     */
    orderBy?: metadataTableOrderByWithRelationInput | metadataTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metadataTables.
     */
    cursor?: metadataTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metadataTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metadataTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metadataTables.
     */
    distinct?: MetadataTableScalarFieldEnum | MetadataTableScalarFieldEnum[]
  }

  /**
   * metadataTable findMany
   */
  export type metadataTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * Filter, which metadataTables to fetch.
     */
    where?: metadataTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metadataTables to fetch.
     */
    orderBy?: metadataTableOrderByWithRelationInput | metadataTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing metadataTables.
     */
    cursor?: metadataTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metadataTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metadataTables.
     */
    skip?: number
    distinct?: MetadataTableScalarFieldEnum | MetadataTableScalarFieldEnum[]
  }

  /**
   * metadataTable create
   */
  export type metadataTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * The data needed to create a metadataTable.
     */
    data: XOR<metadataTableCreateInput, metadataTableUncheckedCreateInput>
  }

  /**
   * metadataTable createMany
   */
  export type metadataTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many metadataTables.
     */
    data: metadataTableCreateManyInput | metadataTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * metadataTable createManyAndReturn
   */
  export type metadataTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * The data used to create many metadataTables.
     */
    data: metadataTableCreateManyInput | metadataTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * metadataTable update
   */
  export type metadataTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * The data needed to update a metadataTable.
     */
    data: XOR<metadataTableUpdateInput, metadataTableUncheckedUpdateInput>
    /**
     * Choose, which metadataTable to update.
     */
    where: metadataTableWhereUniqueInput
  }

  /**
   * metadataTable updateMany
   */
  export type metadataTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update metadataTables.
     */
    data: XOR<metadataTableUpdateManyMutationInput, metadataTableUncheckedUpdateManyInput>
    /**
     * Filter which metadataTables to update
     */
    where?: metadataTableWhereInput
    /**
     * Limit how many metadataTables to update.
     */
    limit?: number
  }

  /**
   * metadataTable updateManyAndReturn
   */
  export type metadataTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * The data used to update metadataTables.
     */
    data: XOR<metadataTableUpdateManyMutationInput, metadataTableUncheckedUpdateManyInput>
    /**
     * Filter which metadataTables to update
     */
    where?: metadataTableWhereInput
    /**
     * Limit how many metadataTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * metadataTable upsert
   */
  export type metadataTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * The filter to search for the metadataTable to update in case it exists.
     */
    where: metadataTableWhereUniqueInput
    /**
     * In case the metadataTable found by the `where` argument doesn't exist, create a new metadataTable with this data.
     */
    create: XOR<metadataTableCreateInput, metadataTableUncheckedCreateInput>
    /**
     * In case the metadataTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<metadataTableUpdateInput, metadataTableUncheckedUpdateInput>
  }

  /**
   * metadataTable delete
   */
  export type metadataTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
    /**
     * Filter which metadataTable to delete.
     */
    where: metadataTableWhereUniqueInput
  }

  /**
   * metadataTable deleteMany
   */
  export type metadataTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which metadataTables to delete
     */
    where?: metadataTableWhereInput
    /**
     * Limit how many metadataTables to delete.
     */
    limit?: number
  }

  /**
   * metadataTable without action
   */
  export type metadataTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metadataTable
     */
    select?: metadataTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metadataTable
     */
    omit?: metadataTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metadataTableInclude<ExtArgs> | null
  }


  /**
   * Model nurseryTable
   */

  export type AggregateNurseryTable = {
    _count: NurseryTableCountAggregateOutputType | null
    _avg: NurseryTableAvgAggregateOutputType | null
    _sum: NurseryTableSumAggregateOutputType | null
    _min: NurseryTableMinAggregateOutputType | null
    _max: NurseryTableMaxAggregateOutputType | null
  }

  export type NurseryTableAvgAggregateOutputType = {
    gpsLat: number | null
    gpsLon: number | null
    capacity: number | null
  }

  export type NurseryTableSumAggregateOutputType = {
    gpsLat: number | null
    gpsLon: number | null
    capacity: number | null
  }

  export type NurseryTableMinAggregateOutputType = {
    nurseryId: string | null
    gpsLat: number | null
    gpsLon: number | null
    capacity: number | null
    nurseryNotes: string | null
    tradeName: string | null
    createdAt: Date | null
    createdBy: string | null
    lastEditedAt: Date | null
  }

  export type NurseryTableMaxAggregateOutputType = {
    nurseryId: string | null
    gpsLat: number | null
    gpsLon: number | null
    capacity: number | null
    nurseryNotes: string | null
    tradeName: string | null
    createdAt: Date | null
    createdBy: string | null
    lastEditedAt: Date | null
  }

  export type NurseryTableCountAggregateOutputType = {
    nurseryId: number
    gpsLat: number
    gpsLon: number
    capacity: number
    nurseryNotes: number
    tradeName: number
    createdAt: number
    createdBy: number
    lastEditedAt: number
    _all: number
  }


  export type NurseryTableAvgAggregateInputType = {
    gpsLat?: true
    gpsLon?: true
    capacity?: true
  }

  export type NurseryTableSumAggregateInputType = {
    gpsLat?: true
    gpsLon?: true
    capacity?: true
  }

  export type NurseryTableMinAggregateInputType = {
    nurseryId?: true
    gpsLat?: true
    gpsLon?: true
    capacity?: true
    nurseryNotes?: true
    tradeName?: true
    createdAt?: true
    createdBy?: true
    lastEditedAt?: true
  }

  export type NurseryTableMaxAggregateInputType = {
    nurseryId?: true
    gpsLat?: true
    gpsLon?: true
    capacity?: true
    nurseryNotes?: true
    tradeName?: true
    createdAt?: true
    createdBy?: true
    lastEditedAt?: true
  }

  export type NurseryTableCountAggregateInputType = {
    nurseryId?: true
    gpsLat?: true
    gpsLon?: true
    capacity?: true
    nurseryNotes?: true
    tradeName?: true
    createdAt?: true
    createdBy?: true
    lastEditedAt?: true
    _all?: true
  }

  export type NurseryTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nurseryTable to aggregate.
     */
    where?: nurseryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nurseryTables to fetch.
     */
    orderBy?: nurseryTableOrderByWithRelationInput | nurseryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: nurseryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nurseryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nurseryTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nurseryTables
    **/
    _count?: true | NurseryTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NurseryTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NurseryTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NurseryTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NurseryTableMaxAggregateInputType
  }

  export type GetNurseryTableAggregateType<T extends NurseryTableAggregateArgs> = {
        [P in keyof T & keyof AggregateNurseryTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNurseryTable[P]>
      : GetScalarType<T[P], AggregateNurseryTable[P]>
  }




  export type nurseryTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: nurseryTableWhereInput
    orderBy?: nurseryTableOrderByWithAggregationInput | nurseryTableOrderByWithAggregationInput[]
    by: NurseryTableScalarFieldEnum[] | NurseryTableScalarFieldEnum
    having?: nurseryTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NurseryTableCountAggregateInputType | true
    _avg?: NurseryTableAvgAggregateInputType
    _sum?: NurseryTableSumAggregateInputType
    _min?: NurseryTableMinAggregateInputType
    _max?: NurseryTableMaxAggregateInputType
  }

  export type NurseryTableGroupByOutputType = {
    nurseryId: string
    gpsLat: number
    gpsLon: number
    capacity: number
    nurseryNotes: string | null
    tradeName: string
    createdAt: Date | null
    createdBy: string
    lastEditedAt: Date | null
    _count: NurseryTableCountAggregateOutputType | null
    _avg: NurseryTableAvgAggregateOutputType | null
    _sum: NurseryTableSumAggregateOutputType | null
    _min: NurseryTableMinAggregateOutputType | null
    _max: NurseryTableMaxAggregateOutputType | null
  }

  type GetNurseryTableGroupByPayload<T extends nurseryTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NurseryTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NurseryTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NurseryTableGroupByOutputType[P]>
            : GetScalarType<T[P], NurseryTableGroupByOutputType[P]>
        }
      >
    >


  export type nurseryTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nurseryId?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    capacity?: boolean
    nurseryNotes?: boolean
    tradeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    lastEditedAt?: boolean
  }, ExtArgs["result"]["nurseryTable"]>

  export type nurseryTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nurseryId?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    capacity?: boolean
    nurseryNotes?: boolean
    tradeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    lastEditedAt?: boolean
  }, ExtArgs["result"]["nurseryTable"]>

  export type nurseryTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nurseryId?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    capacity?: boolean
    nurseryNotes?: boolean
    tradeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    lastEditedAt?: boolean
  }, ExtArgs["result"]["nurseryTable"]>

  export type nurseryTableSelectScalar = {
    nurseryId?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    capacity?: boolean
    nurseryNotes?: boolean
    tradeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    lastEditedAt?: boolean
  }

  export type nurseryTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nurseryId" | "gpsLat" | "gpsLon" | "capacity" | "nurseryNotes" | "tradeName" | "createdAt" | "createdBy" | "lastEditedAt", ExtArgs["result"]["nurseryTable"]>

  export type $nurseryTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "nurseryTable"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      nurseryId: string
      gpsLat: number
      gpsLon: number
      capacity: number
      nurseryNotes: string | null
      tradeName: string
      createdAt: Date | null
      createdBy: string
      lastEditedAt: Date | null
    }, ExtArgs["result"]["nurseryTable"]>
    composites: {}
  }

  type nurseryTableGetPayload<S extends boolean | null | undefined | nurseryTableDefaultArgs> = $Result.GetResult<Prisma.$nurseryTablePayload, S>

  type nurseryTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<nurseryTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NurseryTableCountAggregateInputType | true
    }

  export interface nurseryTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['nurseryTable'], meta: { name: 'nurseryTable' } }
    /**
     * Find zero or one NurseryTable that matches the filter.
     * @param {nurseryTableFindUniqueArgs} args - Arguments to find a NurseryTable
     * @example
     * // Get one NurseryTable
     * const nurseryTable = await prisma.nurseryTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends nurseryTableFindUniqueArgs>(args: SelectSubset<T, nurseryTableFindUniqueArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NurseryTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {nurseryTableFindUniqueOrThrowArgs} args - Arguments to find a NurseryTable
     * @example
     * // Get one NurseryTable
     * const nurseryTable = await prisma.nurseryTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends nurseryTableFindUniqueOrThrowArgs>(args: SelectSubset<T, nurseryTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NurseryTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nurseryTableFindFirstArgs} args - Arguments to find a NurseryTable
     * @example
     * // Get one NurseryTable
     * const nurseryTable = await prisma.nurseryTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends nurseryTableFindFirstArgs>(args?: SelectSubset<T, nurseryTableFindFirstArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NurseryTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nurseryTableFindFirstOrThrowArgs} args - Arguments to find a NurseryTable
     * @example
     * // Get one NurseryTable
     * const nurseryTable = await prisma.nurseryTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends nurseryTableFindFirstOrThrowArgs>(args?: SelectSubset<T, nurseryTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NurseryTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nurseryTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NurseryTables
     * const nurseryTables = await prisma.nurseryTable.findMany()
     * 
     * // Get first 10 NurseryTables
     * const nurseryTables = await prisma.nurseryTable.findMany({ take: 10 })
     * 
     * // Only select the `nurseryId`
     * const nurseryTableWithNurseryIdOnly = await prisma.nurseryTable.findMany({ select: { nurseryId: true } })
     * 
     */
    findMany<T extends nurseryTableFindManyArgs>(args?: SelectSubset<T, nurseryTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NurseryTable.
     * @param {nurseryTableCreateArgs} args - Arguments to create a NurseryTable.
     * @example
     * // Create one NurseryTable
     * const NurseryTable = await prisma.nurseryTable.create({
     *   data: {
     *     // ... data to create a NurseryTable
     *   }
     * })
     * 
     */
    create<T extends nurseryTableCreateArgs>(args: SelectSubset<T, nurseryTableCreateArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NurseryTables.
     * @param {nurseryTableCreateManyArgs} args - Arguments to create many NurseryTables.
     * @example
     * // Create many NurseryTables
     * const nurseryTable = await prisma.nurseryTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends nurseryTableCreateManyArgs>(args?: SelectSubset<T, nurseryTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NurseryTables and returns the data saved in the database.
     * @param {nurseryTableCreateManyAndReturnArgs} args - Arguments to create many NurseryTables.
     * @example
     * // Create many NurseryTables
     * const nurseryTable = await prisma.nurseryTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NurseryTables and only return the `nurseryId`
     * const nurseryTableWithNurseryIdOnly = await prisma.nurseryTable.createManyAndReturn({
     *   select: { nurseryId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends nurseryTableCreateManyAndReturnArgs>(args?: SelectSubset<T, nurseryTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NurseryTable.
     * @param {nurseryTableDeleteArgs} args - Arguments to delete one NurseryTable.
     * @example
     * // Delete one NurseryTable
     * const NurseryTable = await prisma.nurseryTable.delete({
     *   where: {
     *     // ... filter to delete one NurseryTable
     *   }
     * })
     * 
     */
    delete<T extends nurseryTableDeleteArgs>(args: SelectSubset<T, nurseryTableDeleteArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NurseryTable.
     * @param {nurseryTableUpdateArgs} args - Arguments to update one NurseryTable.
     * @example
     * // Update one NurseryTable
     * const nurseryTable = await prisma.nurseryTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends nurseryTableUpdateArgs>(args: SelectSubset<T, nurseryTableUpdateArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NurseryTables.
     * @param {nurseryTableDeleteManyArgs} args - Arguments to filter NurseryTables to delete.
     * @example
     * // Delete a few NurseryTables
     * const { count } = await prisma.nurseryTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends nurseryTableDeleteManyArgs>(args?: SelectSubset<T, nurseryTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseryTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nurseryTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NurseryTables
     * const nurseryTable = await prisma.nurseryTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends nurseryTableUpdateManyArgs>(args: SelectSubset<T, nurseryTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseryTables and returns the data updated in the database.
     * @param {nurseryTableUpdateManyAndReturnArgs} args - Arguments to update many NurseryTables.
     * @example
     * // Update many NurseryTables
     * const nurseryTable = await prisma.nurseryTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NurseryTables and only return the `nurseryId`
     * const nurseryTableWithNurseryIdOnly = await prisma.nurseryTable.updateManyAndReturn({
     *   select: { nurseryId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends nurseryTableUpdateManyAndReturnArgs>(args: SelectSubset<T, nurseryTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NurseryTable.
     * @param {nurseryTableUpsertArgs} args - Arguments to update or create a NurseryTable.
     * @example
     * // Update or create a NurseryTable
     * const nurseryTable = await prisma.nurseryTable.upsert({
     *   create: {
     *     // ... data to create a NurseryTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NurseryTable we want to update
     *   }
     * })
     */
    upsert<T extends nurseryTableUpsertArgs>(args: SelectSubset<T, nurseryTableUpsertArgs<ExtArgs>>): Prisma__nurseryTableClient<$Result.GetResult<Prisma.$nurseryTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NurseryTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nurseryTableCountArgs} args - Arguments to filter NurseryTables to count.
     * @example
     * // Count the number of NurseryTables
     * const count = await prisma.nurseryTable.count({
     *   where: {
     *     // ... the filter for the NurseryTables we want to count
     *   }
     * })
    **/
    count<T extends nurseryTableCountArgs>(
      args?: Subset<T, nurseryTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NurseryTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NurseryTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseryTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NurseryTableAggregateArgs>(args: Subset<T, NurseryTableAggregateArgs>): Prisma.PrismaPromise<GetNurseryTableAggregateType<T>>

    /**
     * Group by NurseryTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nurseryTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends nurseryTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: nurseryTableGroupByArgs['orderBy'] }
        : { orderBy?: nurseryTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, nurseryTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNurseryTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the nurseryTable model
   */
  readonly fields: nurseryTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for nurseryTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__nurseryTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the nurseryTable model
   */
  interface nurseryTableFieldRefs {
    readonly nurseryId: FieldRef<"nurseryTable", 'String'>
    readonly gpsLat: FieldRef<"nurseryTable", 'Float'>
    readonly gpsLon: FieldRef<"nurseryTable", 'Float'>
    readonly capacity: FieldRef<"nurseryTable", 'Int'>
    readonly nurseryNotes: FieldRef<"nurseryTable", 'String'>
    readonly tradeName: FieldRef<"nurseryTable", 'String'>
    readonly createdAt: FieldRef<"nurseryTable", 'DateTime'>
    readonly createdBy: FieldRef<"nurseryTable", 'String'>
    readonly lastEditedAt: FieldRef<"nurseryTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * nurseryTable findUnique
   */
  export type nurseryTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * Filter, which nurseryTable to fetch.
     */
    where: nurseryTableWhereUniqueInput
  }

  /**
   * nurseryTable findUniqueOrThrow
   */
  export type nurseryTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * Filter, which nurseryTable to fetch.
     */
    where: nurseryTableWhereUniqueInput
  }

  /**
   * nurseryTable findFirst
   */
  export type nurseryTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * Filter, which nurseryTable to fetch.
     */
    where?: nurseryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nurseryTables to fetch.
     */
    orderBy?: nurseryTableOrderByWithRelationInput | nurseryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nurseryTables.
     */
    cursor?: nurseryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nurseryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nurseryTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nurseryTables.
     */
    distinct?: NurseryTableScalarFieldEnum | NurseryTableScalarFieldEnum[]
  }

  /**
   * nurseryTable findFirstOrThrow
   */
  export type nurseryTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * Filter, which nurseryTable to fetch.
     */
    where?: nurseryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nurseryTables to fetch.
     */
    orderBy?: nurseryTableOrderByWithRelationInput | nurseryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nurseryTables.
     */
    cursor?: nurseryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nurseryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nurseryTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nurseryTables.
     */
    distinct?: NurseryTableScalarFieldEnum | NurseryTableScalarFieldEnum[]
  }

  /**
   * nurseryTable findMany
   */
  export type nurseryTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * Filter, which nurseryTables to fetch.
     */
    where?: nurseryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nurseryTables to fetch.
     */
    orderBy?: nurseryTableOrderByWithRelationInput | nurseryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nurseryTables.
     */
    cursor?: nurseryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nurseryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nurseryTables.
     */
    skip?: number
    distinct?: NurseryTableScalarFieldEnum | NurseryTableScalarFieldEnum[]
  }

  /**
   * nurseryTable create
   */
  export type nurseryTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * The data needed to create a nurseryTable.
     */
    data: XOR<nurseryTableCreateInput, nurseryTableUncheckedCreateInput>
  }

  /**
   * nurseryTable createMany
   */
  export type nurseryTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many nurseryTables.
     */
    data: nurseryTableCreateManyInput | nurseryTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * nurseryTable createManyAndReturn
   */
  export type nurseryTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * The data used to create many nurseryTables.
     */
    data: nurseryTableCreateManyInput | nurseryTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * nurseryTable update
   */
  export type nurseryTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * The data needed to update a nurseryTable.
     */
    data: XOR<nurseryTableUpdateInput, nurseryTableUncheckedUpdateInput>
    /**
     * Choose, which nurseryTable to update.
     */
    where: nurseryTableWhereUniqueInput
  }

  /**
   * nurseryTable updateMany
   */
  export type nurseryTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update nurseryTables.
     */
    data: XOR<nurseryTableUpdateManyMutationInput, nurseryTableUncheckedUpdateManyInput>
    /**
     * Filter which nurseryTables to update
     */
    where?: nurseryTableWhereInput
    /**
     * Limit how many nurseryTables to update.
     */
    limit?: number
  }

  /**
   * nurseryTable updateManyAndReturn
   */
  export type nurseryTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * The data used to update nurseryTables.
     */
    data: XOR<nurseryTableUpdateManyMutationInput, nurseryTableUncheckedUpdateManyInput>
    /**
     * Filter which nurseryTables to update
     */
    where?: nurseryTableWhereInput
    /**
     * Limit how many nurseryTables to update.
     */
    limit?: number
  }

  /**
   * nurseryTable upsert
   */
  export type nurseryTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * The filter to search for the nurseryTable to update in case it exists.
     */
    where: nurseryTableWhereUniqueInput
    /**
     * In case the nurseryTable found by the `where` argument doesn't exist, create a new nurseryTable with this data.
     */
    create: XOR<nurseryTableCreateInput, nurseryTableUncheckedCreateInput>
    /**
     * In case the nurseryTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nurseryTableUpdateInput, nurseryTableUncheckedUpdateInput>
  }

  /**
   * nurseryTable delete
   */
  export type nurseryTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
    /**
     * Filter which nurseryTable to delete.
     */
    where: nurseryTableWhereUniqueInput
  }

  /**
   * nurseryTable deleteMany
   */
  export type nurseryTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nurseryTables to delete
     */
    where?: nurseryTableWhereInput
    /**
     * Limit how many nurseryTables to delete.
     */
    limit?: number
  }

  /**
   * nurseryTable without action
   */
  export type nurseryTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nurseryTable
     */
    select?: nurseryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nurseryTable
     */
    omit?: nurseryTableOmit<ExtArgs> | null
  }


  /**
   * Model organizationsTable
   */

  export type AggregateOrganizationsTable = {
    _count: OrganizationsTableCountAggregateOutputType | null
    _avg: OrganizationsTableAvgAggregateOutputType | null
    _sum: OrganizationsTableSumAggregateOutputType | null
    _min: OrganizationsTableMinAggregateOutputType | null
    _max: OrganizationsTableMaxAggregateOutputType | null
  }

  export type OrganizationsTableAvgAggregateOutputType = {
    gpsLat: number | null
    gpsLon: number | null
  }

  export type OrganizationsTableSumAggregateOutputType = {
    gpsLat: number | null
    gpsLon: number | null
  }

  export type OrganizationsTableMinAggregateOutputType = {
    organizationId: string | null
    organizationName: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    website: string | null
    organizationNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    gpsLat: number | null
    gpsLon: number | null
    stakeholderTypeId: string | null
  }

  export type OrganizationsTableMaxAggregateOutputType = {
    organizationId: string | null
    organizationName: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    website: string | null
    organizationNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    gpsLat: number | null
    gpsLon: number | null
    stakeholderTypeId: string | null
  }

  export type OrganizationsTableCountAggregateOutputType = {
    organizationId: number
    organizationName: number
    contactName: number
    contactEmail: number
    contactPhone: number
    address: number
    website: number
    organizationNotes: number
    createdAt: number
    lastEditedAt: number
    editedBy: number
    deleted: number
    gpsLat: number
    gpsLon: number
    stakeholderTypeId: number
    _all: number
  }


  export type OrganizationsTableAvgAggregateInputType = {
    gpsLat?: true
    gpsLon?: true
  }

  export type OrganizationsTableSumAggregateInputType = {
    gpsLat?: true
    gpsLon?: true
  }

  export type OrganizationsTableMinAggregateInputType = {
    organizationId?: true
    organizationName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    website?: true
    organizationNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    gpsLat?: true
    gpsLon?: true
    stakeholderTypeId?: true
  }

  export type OrganizationsTableMaxAggregateInputType = {
    organizationId?: true
    organizationName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    website?: true
    organizationNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    gpsLat?: true
    gpsLon?: true
    stakeholderTypeId?: true
  }

  export type OrganizationsTableCountAggregateInputType = {
    organizationId?: true
    organizationName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    website?: true
    organizationNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    gpsLat?: true
    gpsLon?: true
    stakeholderTypeId?: true
    _all?: true
  }

  export type OrganizationsTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizationsTable to aggregate.
     */
    where?: organizationsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationsTables to fetch.
     */
    orderBy?: organizationsTableOrderByWithRelationInput | organizationsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizationsTables
    **/
    _count?: true | OrganizationsTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationsTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationsTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationsTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationsTableMaxAggregateInputType
  }

  export type GetOrganizationsTableAggregateType<T extends OrganizationsTableAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationsTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationsTable[P]>
      : GetScalarType<T[P], AggregateOrganizationsTable[P]>
  }




  export type organizationsTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationsTableWhereInput
    orderBy?: organizationsTableOrderByWithAggregationInput | organizationsTableOrderByWithAggregationInput[]
    by: OrganizationsTableScalarFieldEnum[] | OrganizationsTableScalarFieldEnum
    having?: organizationsTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationsTableCountAggregateInputType | true
    _avg?: OrganizationsTableAvgAggregateInputType
    _sum?: OrganizationsTableSumAggregateInputType
    _min?: OrganizationsTableMinAggregateInputType
    _max?: OrganizationsTableMaxAggregateInputType
  }

  export type OrganizationsTableGroupByOutputType = {
    organizationId: string
    organizationName: string
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    website: string | null
    organizationNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    gpsLat: number | null
    gpsLon: number | null
    stakeholderTypeId: string | null
    _count: OrganizationsTableCountAggregateOutputType | null
    _avg: OrganizationsTableAvgAggregateOutputType | null
    _sum: OrganizationsTableSumAggregateOutputType | null
    _min: OrganizationsTableMinAggregateOutputType | null
    _max: OrganizationsTableMaxAggregateOutputType | null
  }

  type GetOrganizationsTableGroupByPayload<T extends organizationsTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationsTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationsTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationsTableGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationsTableGroupByOutputType[P]>
        }
      >
    >


  export type organizationsTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organizationId?: boolean
    organizationName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    website?: boolean
    organizationNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    stakeholderTypeId?: boolean
    cropStakeholdersTable?: boolean | organizationsTable$cropStakeholdersTableArgs<ExtArgs>
    cropTable?: boolean | organizationsTable$cropTableArgs<ExtArgs>
    landStakeholdersTable?: boolean | organizationsTable$landStakeholdersTableArgs<ExtArgs>
    stakeholderTypesTable?: boolean | organizationsTable$stakeholderTypesTableArgs<ExtArgs>
    profilesTable?: boolean | organizationsTable$profilesTableArgs<ExtArgs>
    projectStakeholdersTable?: boolean | organizationsTable$projectStakeholdersTableArgs<ExtArgs>
    _count?: boolean | OrganizationsTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationsTable"]>

  export type organizationsTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organizationId?: boolean
    organizationName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    website?: boolean
    organizationNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    stakeholderTypeId?: boolean
    stakeholderTypesTable?: boolean | organizationsTable$stakeholderTypesTableArgs<ExtArgs>
  }, ExtArgs["result"]["organizationsTable"]>

  export type organizationsTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organizationId?: boolean
    organizationName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    website?: boolean
    organizationNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    stakeholderTypeId?: boolean
    stakeholderTypesTable?: boolean | organizationsTable$stakeholderTypesTableArgs<ExtArgs>
  }, ExtArgs["result"]["organizationsTable"]>

  export type organizationsTableSelectScalar = {
    organizationId?: boolean
    organizationName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    website?: boolean
    organizationNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    gpsLat?: boolean
    gpsLon?: boolean
    stakeholderTypeId?: boolean
  }

  export type organizationsTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"organizationId" | "organizationName" | "contactName" | "contactEmail" | "contactPhone" | "address" | "website" | "organizationNotes" | "createdAt" | "lastEditedAt" | "editedBy" | "deleted" | "gpsLat" | "gpsLon" | "stakeholderTypeId", ExtArgs["result"]["organizationsTable"]>
  export type organizationsTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropStakeholdersTable?: boolean | organizationsTable$cropStakeholdersTableArgs<ExtArgs>
    cropTable?: boolean | organizationsTable$cropTableArgs<ExtArgs>
    landStakeholdersTable?: boolean | organizationsTable$landStakeholdersTableArgs<ExtArgs>
    stakeholderTypesTable?: boolean | organizationsTable$stakeholderTypesTableArgs<ExtArgs>
    profilesTable?: boolean | organizationsTable$profilesTableArgs<ExtArgs>
    projectStakeholdersTable?: boolean | organizationsTable$projectStakeholdersTableArgs<ExtArgs>
    _count?: boolean | OrganizationsTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type organizationsTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholderTypesTable?: boolean | organizationsTable$stakeholderTypesTableArgs<ExtArgs>
  }
  export type organizationsTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stakeholderTypesTable?: boolean | organizationsTable$stakeholderTypesTableArgs<ExtArgs>
  }

  export type $organizationsTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organizationsTable"
    objects: {
      cropStakeholdersTable: Prisma.$cropStakeholdersTablePayload<ExtArgs>[]
      cropTable: Prisma.$cropTablePayload<ExtArgs>[]
      landStakeholdersTable: Prisma.$landStakeholdersTablePayload<ExtArgs>[]
      stakeholderTypesTable: Prisma.$stakeholderTypesTablePayload<ExtArgs> | null
      profilesTable: Prisma.$profilesTablePayload<ExtArgs>[]
      projectStakeholdersTable: Prisma.$projectStakeholdersTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      organizationId: string
      organizationName: string
      contactName: string | null
      contactEmail: string | null
      contactPhone: string | null
      address: string | null
      website: string | null
      organizationNotes: string | null
      createdAt: Date | null
      lastEditedAt: Date | null
      editedBy: string | null
      deleted: boolean | null
      gpsLat: number | null
      gpsLon: number | null
      stakeholderTypeId: string | null
    }, ExtArgs["result"]["organizationsTable"]>
    composites: {}
  }

  type organizationsTableGetPayload<S extends boolean | null | undefined | organizationsTableDefaultArgs> = $Result.GetResult<Prisma.$organizationsTablePayload, S>

  type organizationsTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<organizationsTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationsTableCountAggregateInputType | true
    }

  export interface organizationsTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organizationsTable'], meta: { name: 'organizationsTable' } }
    /**
     * Find zero or one OrganizationsTable that matches the filter.
     * @param {organizationsTableFindUniqueArgs} args - Arguments to find a OrganizationsTable
     * @example
     * // Get one OrganizationsTable
     * const organizationsTable = await prisma.organizationsTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends organizationsTableFindUniqueArgs>(args: SelectSubset<T, organizationsTableFindUniqueArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationsTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {organizationsTableFindUniqueOrThrowArgs} args - Arguments to find a OrganizationsTable
     * @example
     * // Get one OrganizationsTable
     * const organizationsTable = await prisma.organizationsTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends organizationsTableFindUniqueOrThrowArgs>(args: SelectSubset<T, organizationsTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationsTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsTableFindFirstArgs} args - Arguments to find a OrganizationsTable
     * @example
     * // Get one OrganizationsTable
     * const organizationsTable = await prisma.organizationsTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends organizationsTableFindFirstArgs>(args?: SelectSubset<T, organizationsTableFindFirstArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationsTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsTableFindFirstOrThrowArgs} args - Arguments to find a OrganizationsTable
     * @example
     * // Get one OrganizationsTable
     * const organizationsTable = await prisma.organizationsTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends organizationsTableFindFirstOrThrowArgs>(args?: SelectSubset<T, organizationsTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationsTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationsTables
     * const organizationsTables = await prisma.organizationsTable.findMany()
     * 
     * // Get first 10 OrganizationsTables
     * const organizationsTables = await prisma.organizationsTable.findMany({ take: 10 })
     * 
     * // Only select the `organizationId`
     * const organizationsTableWithOrganizationIdOnly = await prisma.organizationsTable.findMany({ select: { organizationId: true } })
     * 
     */
    findMany<T extends organizationsTableFindManyArgs>(args?: SelectSubset<T, organizationsTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationsTable.
     * @param {organizationsTableCreateArgs} args - Arguments to create a OrganizationsTable.
     * @example
     * // Create one OrganizationsTable
     * const OrganizationsTable = await prisma.organizationsTable.create({
     *   data: {
     *     // ... data to create a OrganizationsTable
     *   }
     * })
     * 
     */
    create<T extends organizationsTableCreateArgs>(args: SelectSubset<T, organizationsTableCreateArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationsTables.
     * @param {organizationsTableCreateManyArgs} args - Arguments to create many OrganizationsTables.
     * @example
     * // Create many OrganizationsTables
     * const organizationsTable = await prisma.organizationsTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends organizationsTableCreateManyArgs>(args?: SelectSubset<T, organizationsTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationsTables and returns the data saved in the database.
     * @param {organizationsTableCreateManyAndReturnArgs} args - Arguments to create many OrganizationsTables.
     * @example
     * // Create many OrganizationsTables
     * const organizationsTable = await prisma.organizationsTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationsTables and only return the `organizationId`
     * const organizationsTableWithOrganizationIdOnly = await prisma.organizationsTable.createManyAndReturn({
     *   select: { organizationId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends organizationsTableCreateManyAndReturnArgs>(args?: SelectSubset<T, organizationsTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationsTable.
     * @param {organizationsTableDeleteArgs} args - Arguments to delete one OrganizationsTable.
     * @example
     * // Delete one OrganizationsTable
     * const OrganizationsTable = await prisma.organizationsTable.delete({
     *   where: {
     *     // ... filter to delete one OrganizationsTable
     *   }
     * })
     * 
     */
    delete<T extends organizationsTableDeleteArgs>(args: SelectSubset<T, organizationsTableDeleteArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationsTable.
     * @param {organizationsTableUpdateArgs} args - Arguments to update one OrganizationsTable.
     * @example
     * // Update one OrganizationsTable
     * const organizationsTable = await prisma.organizationsTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends organizationsTableUpdateArgs>(args: SelectSubset<T, organizationsTableUpdateArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationsTables.
     * @param {organizationsTableDeleteManyArgs} args - Arguments to filter OrganizationsTables to delete.
     * @example
     * // Delete a few OrganizationsTables
     * const { count } = await prisma.organizationsTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends organizationsTableDeleteManyArgs>(args?: SelectSubset<T, organizationsTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationsTables
     * const organizationsTable = await prisma.organizationsTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends organizationsTableUpdateManyArgs>(args: SelectSubset<T, organizationsTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationsTables and returns the data updated in the database.
     * @param {organizationsTableUpdateManyAndReturnArgs} args - Arguments to update many OrganizationsTables.
     * @example
     * // Update many OrganizationsTables
     * const organizationsTable = await prisma.organizationsTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationsTables and only return the `organizationId`
     * const organizationsTableWithOrganizationIdOnly = await prisma.organizationsTable.updateManyAndReturn({
     *   select: { organizationId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends organizationsTableUpdateManyAndReturnArgs>(args: SelectSubset<T, organizationsTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationsTable.
     * @param {organizationsTableUpsertArgs} args - Arguments to update or create a OrganizationsTable.
     * @example
     * // Update or create a OrganizationsTable
     * const organizationsTable = await prisma.organizationsTable.upsert({
     *   create: {
     *     // ... data to create a OrganizationsTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationsTable we want to update
     *   }
     * })
     */
    upsert<T extends organizationsTableUpsertArgs>(args: SelectSubset<T, organizationsTableUpsertArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsTableCountArgs} args - Arguments to filter OrganizationsTables to count.
     * @example
     * // Count the number of OrganizationsTables
     * const count = await prisma.organizationsTable.count({
     *   where: {
     *     // ... the filter for the OrganizationsTables we want to count
     *   }
     * })
    **/
    count<T extends organizationsTableCountArgs>(
      args?: Subset<T, organizationsTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationsTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationsTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationsTableAggregateArgs>(args: Subset<T, OrganizationsTableAggregateArgs>): Prisma.PrismaPromise<GetOrganizationsTableAggregateType<T>>

    /**
     * Group by OrganizationsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organizationsTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organizationsTableGroupByArgs['orderBy'] }
        : { orderBy?: organizationsTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organizationsTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationsTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organizationsTable model
   */
  readonly fields: organizationsTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organizationsTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organizationsTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropStakeholdersTable<T extends organizationsTable$cropStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTable$cropStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cropTable<T extends organizationsTable$cropTableArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTable$cropTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    landStakeholdersTable<T extends organizationsTable$landStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTable$landStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stakeholderTypesTable<T extends organizationsTable$stakeholderTypesTableArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTable$stakeholderTypesTableArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profilesTable<T extends organizationsTable$profilesTableArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTable$profilesTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectStakeholdersTable<T extends organizationsTable$projectStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTable$projectStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the organizationsTable model
   */
  interface organizationsTableFieldRefs {
    readonly organizationId: FieldRef<"organizationsTable", 'String'>
    readonly organizationName: FieldRef<"organizationsTable", 'String'>
    readonly contactName: FieldRef<"organizationsTable", 'String'>
    readonly contactEmail: FieldRef<"organizationsTable", 'String'>
    readonly contactPhone: FieldRef<"organizationsTable", 'String'>
    readonly address: FieldRef<"organizationsTable", 'String'>
    readonly website: FieldRef<"organizationsTable", 'String'>
    readonly organizationNotes: FieldRef<"organizationsTable", 'String'>
    readonly createdAt: FieldRef<"organizationsTable", 'DateTime'>
    readonly lastEditedAt: FieldRef<"organizationsTable", 'DateTime'>
    readonly editedBy: FieldRef<"organizationsTable", 'String'>
    readonly deleted: FieldRef<"organizationsTable", 'Boolean'>
    readonly gpsLat: FieldRef<"organizationsTable", 'Float'>
    readonly gpsLon: FieldRef<"organizationsTable", 'Float'>
    readonly stakeholderTypeId: FieldRef<"organizationsTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * organizationsTable findUnique
   */
  export type organizationsTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * Filter, which organizationsTable to fetch.
     */
    where: organizationsTableWhereUniqueInput
  }

  /**
   * organizationsTable findUniqueOrThrow
   */
  export type organizationsTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * Filter, which organizationsTable to fetch.
     */
    where: organizationsTableWhereUniqueInput
  }

  /**
   * organizationsTable findFirst
   */
  export type organizationsTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * Filter, which organizationsTable to fetch.
     */
    where?: organizationsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationsTables to fetch.
     */
    orderBy?: organizationsTableOrderByWithRelationInput | organizationsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizationsTables.
     */
    cursor?: organizationsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizationsTables.
     */
    distinct?: OrganizationsTableScalarFieldEnum | OrganizationsTableScalarFieldEnum[]
  }

  /**
   * organizationsTable findFirstOrThrow
   */
  export type organizationsTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * Filter, which organizationsTable to fetch.
     */
    where?: organizationsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationsTables to fetch.
     */
    orderBy?: organizationsTableOrderByWithRelationInput | organizationsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizationsTables.
     */
    cursor?: organizationsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizationsTables.
     */
    distinct?: OrganizationsTableScalarFieldEnum | OrganizationsTableScalarFieldEnum[]
  }

  /**
   * organizationsTable findMany
   */
  export type organizationsTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * Filter, which organizationsTables to fetch.
     */
    where?: organizationsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationsTables to fetch.
     */
    orderBy?: organizationsTableOrderByWithRelationInput | organizationsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizationsTables.
     */
    cursor?: organizationsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationsTables.
     */
    skip?: number
    distinct?: OrganizationsTableScalarFieldEnum | OrganizationsTableScalarFieldEnum[]
  }

  /**
   * organizationsTable create
   */
  export type organizationsTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * The data needed to create a organizationsTable.
     */
    data: XOR<organizationsTableCreateInput, organizationsTableUncheckedCreateInput>
  }

  /**
   * organizationsTable createMany
   */
  export type organizationsTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organizationsTables.
     */
    data: organizationsTableCreateManyInput | organizationsTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * organizationsTable createManyAndReturn
   */
  export type organizationsTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * The data used to create many organizationsTables.
     */
    data: organizationsTableCreateManyInput | organizationsTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * organizationsTable update
   */
  export type organizationsTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * The data needed to update a organizationsTable.
     */
    data: XOR<organizationsTableUpdateInput, organizationsTableUncheckedUpdateInput>
    /**
     * Choose, which organizationsTable to update.
     */
    where: organizationsTableWhereUniqueInput
  }

  /**
   * organizationsTable updateMany
   */
  export type organizationsTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organizationsTables.
     */
    data: XOR<organizationsTableUpdateManyMutationInput, organizationsTableUncheckedUpdateManyInput>
    /**
     * Filter which organizationsTables to update
     */
    where?: organizationsTableWhereInput
    /**
     * Limit how many organizationsTables to update.
     */
    limit?: number
  }

  /**
   * organizationsTable updateManyAndReturn
   */
  export type organizationsTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * The data used to update organizationsTables.
     */
    data: XOR<organizationsTableUpdateManyMutationInput, organizationsTableUncheckedUpdateManyInput>
    /**
     * Filter which organizationsTables to update
     */
    where?: organizationsTableWhereInput
    /**
     * Limit how many organizationsTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * organizationsTable upsert
   */
  export type organizationsTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * The filter to search for the organizationsTable to update in case it exists.
     */
    where: organizationsTableWhereUniqueInput
    /**
     * In case the organizationsTable found by the `where` argument doesn't exist, create a new organizationsTable with this data.
     */
    create: XOR<organizationsTableCreateInput, organizationsTableUncheckedCreateInput>
    /**
     * In case the organizationsTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationsTableUpdateInput, organizationsTableUncheckedUpdateInput>
  }

  /**
   * organizationsTable delete
   */
  export type organizationsTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    /**
     * Filter which organizationsTable to delete.
     */
    where: organizationsTableWhereUniqueInput
  }

  /**
   * organizationsTable deleteMany
   */
  export type organizationsTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizationsTables to delete
     */
    where?: organizationsTableWhereInput
    /**
     * Limit how many organizationsTables to delete.
     */
    limit?: number
  }

  /**
   * organizationsTable.cropStakeholdersTable
   */
  export type organizationsTable$cropStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    where?: cropStakeholdersTableWhereInput
    orderBy?: cropStakeholdersTableOrderByWithRelationInput | cropStakeholdersTableOrderByWithRelationInput[]
    cursor?: cropStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropStakeholdersTableScalarFieldEnum | CropStakeholdersTableScalarFieldEnum[]
  }

  /**
   * organizationsTable.cropTable
   */
  export type organizationsTable$cropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    where?: cropTableWhereInput
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    cursor?: cropTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropTableScalarFieldEnum | CropTableScalarFieldEnum[]
  }

  /**
   * organizationsTable.landStakeholdersTable
   */
  export type organizationsTable$landStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    where?: landStakeholdersTableWhereInput
    orderBy?: landStakeholdersTableOrderByWithRelationInput | landStakeholdersTableOrderByWithRelationInput[]
    cursor?: landStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandStakeholdersTableScalarFieldEnum | LandStakeholdersTableScalarFieldEnum[]
  }

  /**
   * organizationsTable.stakeholderTypesTable
   */
  export type organizationsTable$stakeholderTypesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    where?: stakeholderTypesTableWhereInput
  }

  /**
   * organizationsTable.profilesTable
   */
  export type organizationsTable$profilesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    where?: profilesTableWhereInput
    orderBy?: profilesTableOrderByWithRelationInput | profilesTableOrderByWithRelationInput[]
    cursor?: profilesTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfilesTableScalarFieldEnum | ProfilesTableScalarFieldEnum[]
  }

  /**
   * organizationsTable.projectStakeholdersTable
   */
  export type organizationsTable$projectStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    where?: projectStakeholdersTableWhereInput
    orderBy?: projectStakeholdersTableOrderByWithRelationInput | projectStakeholdersTableOrderByWithRelationInput[]
    cursor?: projectStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectStakeholdersTableScalarFieldEnum | ProjectStakeholdersTableScalarFieldEnum[]
  }

  /**
   * organizationsTable without action
   */
  export type organizationsTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
  }


  /**
   * Model plantingTable
   */

  export type AggregatePlantingTable = {
    _count: PlantingTableCountAggregateOutputType | null
    _avg: PlantingTableAvgAggregateOutputType | null
    _sum: PlantingTableSumAggregateOutputType | null
    _min: PlantingTableMinAggregateOutputType | null
    _max: PlantingTableMaxAggregateOutputType | null
  }

  export type PlantingTableAvgAggregateOutputType = {
    planted: number | null
  }

  export type PlantingTableSumAggregateOutputType = {
    planted: number | null
  }

  export type PlantingTableMinAggregateOutputType = {
    plantingId: string | null
    landId: string | null
    planted: number | null
    plantingDate: Date | null
    createdAt: Date | null
    lastEditedAt: Date | null
    deleted: boolean | null
    cropId: string | null
    plantingNotes: string | null
  }

  export type PlantingTableMaxAggregateOutputType = {
    plantingId: string | null
    landId: string | null
    planted: number | null
    plantingDate: Date | null
    createdAt: Date | null
    lastEditedAt: Date | null
    deleted: boolean | null
    cropId: string | null
    plantingNotes: string | null
  }

  export type PlantingTableCountAggregateOutputType = {
    plantingId: number
    landId: number
    planted: number
    plantingDate: number
    createdAt: number
    lastEditedAt: number
    deleted: number
    cropId: number
    plantingNotes: number
    _all: number
  }


  export type PlantingTableAvgAggregateInputType = {
    planted?: true
  }

  export type PlantingTableSumAggregateInputType = {
    planted?: true
  }

  export type PlantingTableMinAggregateInputType = {
    plantingId?: true
    landId?: true
    planted?: true
    plantingDate?: true
    createdAt?: true
    lastEditedAt?: true
    deleted?: true
    cropId?: true
    plantingNotes?: true
  }

  export type PlantingTableMaxAggregateInputType = {
    plantingId?: true
    landId?: true
    planted?: true
    plantingDate?: true
    createdAt?: true
    lastEditedAt?: true
    deleted?: true
    cropId?: true
    plantingNotes?: true
  }

  export type PlantingTableCountAggregateInputType = {
    plantingId?: true
    landId?: true
    planted?: true
    plantingDate?: true
    createdAt?: true
    lastEditedAt?: true
    deleted?: true
    cropId?: true
    plantingNotes?: true
    _all?: true
  }

  export type PlantingTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plantingTable to aggregate.
     */
    where?: plantingTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plantingTables to fetch.
     */
    orderBy?: plantingTableOrderByWithRelationInput | plantingTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plantingTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plantingTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plantingTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plantingTables
    **/
    _count?: true | PlantingTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantingTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantingTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantingTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantingTableMaxAggregateInputType
  }

  export type GetPlantingTableAggregateType<T extends PlantingTableAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantingTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantingTable[P]>
      : GetScalarType<T[P], AggregatePlantingTable[P]>
  }




  export type plantingTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plantingTableWhereInput
    orderBy?: plantingTableOrderByWithAggregationInput | plantingTableOrderByWithAggregationInput[]
    by: PlantingTableScalarFieldEnum[] | PlantingTableScalarFieldEnum
    having?: plantingTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantingTableCountAggregateInputType | true
    _avg?: PlantingTableAvgAggregateInputType
    _sum?: PlantingTableSumAggregateInputType
    _min?: PlantingTableMinAggregateInputType
    _max?: PlantingTableMaxAggregateInputType
  }

  export type PlantingTableGroupByOutputType = {
    plantingId: string
    landId: string | null
    planted: number | null
    plantingDate: Date | null
    createdAt: Date | null
    lastEditedAt: Date | null
    deleted: boolean | null
    cropId: string | null
    plantingNotes: string | null
    _count: PlantingTableCountAggregateOutputType | null
    _avg: PlantingTableAvgAggregateOutputType | null
    _sum: PlantingTableSumAggregateOutputType | null
    _min: PlantingTableMinAggregateOutputType | null
    _max: PlantingTableMaxAggregateOutputType | null
  }

  type GetPlantingTableGroupByPayload<T extends plantingTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantingTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantingTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantingTableGroupByOutputType[P]>
            : GetScalarType<T[P], PlantingTableGroupByOutputType[P]>
        }
      >
    >


  export type plantingTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plantingId?: boolean
    landId?: boolean
    planted?: boolean
    plantingDate?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    cropId?: boolean
    plantingNotes?: boolean
    cropTable?: boolean | plantingTable$cropTableArgs<ExtArgs>
    landTable?: boolean | plantingTable$landTableArgs<ExtArgs>
  }, ExtArgs["result"]["plantingTable"]>

  export type plantingTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plantingId?: boolean
    landId?: boolean
    planted?: boolean
    plantingDate?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    cropId?: boolean
    plantingNotes?: boolean
    cropTable?: boolean | plantingTable$cropTableArgs<ExtArgs>
    landTable?: boolean | plantingTable$landTableArgs<ExtArgs>
  }, ExtArgs["result"]["plantingTable"]>

  export type plantingTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plantingId?: boolean
    landId?: boolean
    planted?: boolean
    plantingDate?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    cropId?: boolean
    plantingNotes?: boolean
    cropTable?: boolean | plantingTable$cropTableArgs<ExtArgs>
    landTable?: boolean | plantingTable$landTableArgs<ExtArgs>
  }, ExtArgs["result"]["plantingTable"]>

  export type plantingTableSelectScalar = {
    plantingId?: boolean
    landId?: boolean
    planted?: boolean
    plantingDate?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    cropId?: boolean
    plantingNotes?: boolean
  }

  export type plantingTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"plantingId" | "landId" | "planted" | "plantingDate" | "createdAt" | "lastEditedAt" | "deleted" | "cropId" | "plantingNotes", ExtArgs["result"]["plantingTable"]>
  export type plantingTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | plantingTable$cropTableArgs<ExtArgs>
    landTable?: boolean | plantingTable$landTableArgs<ExtArgs>
  }
  export type plantingTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | plantingTable$cropTableArgs<ExtArgs>
    landTable?: boolean | plantingTable$landTableArgs<ExtArgs>
  }
  export type plantingTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | plantingTable$cropTableArgs<ExtArgs>
    landTable?: boolean | plantingTable$landTableArgs<ExtArgs>
  }

  export type $plantingTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plantingTable"
    objects: {
      cropTable: Prisma.$cropTablePayload<ExtArgs> | null
      landTable: Prisma.$landTablePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      plantingId: string
      landId: string | null
      planted: number | null
      plantingDate: Date | null
      createdAt: Date | null
      lastEditedAt: Date | null
      deleted: boolean | null
      cropId: string | null
      plantingNotes: string | null
    }, ExtArgs["result"]["plantingTable"]>
    composites: {}
  }

  type plantingTableGetPayload<S extends boolean | null | undefined | plantingTableDefaultArgs> = $Result.GetResult<Prisma.$plantingTablePayload, S>

  type plantingTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plantingTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantingTableCountAggregateInputType | true
    }

  export interface plantingTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plantingTable'], meta: { name: 'plantingTable' } }
    /**
     * Find zero or one PlantingTable that matches the filter.
     * @param {plantingTableFindUniqueArgs} args - Arguments to find a PlantingTable
     * @example
     * // Get one PlantingTable
     * const plantingTable = await prisma.plantingTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plantingTableFindUniqueArgs>(args: SelectSubset<T, plantingTableFindUniqueArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantingTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plantingTableFindUniqueOrThrowArgs} args - Arguments to find a PlantingTable
     * @example
     * // Get one PlantingTable
     * const plantingTable = await prisma.plantingTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plantingTableFindUniqueOrThrowArgs>(args: SelectSubset<T, plantingTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantingTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantingTableFindFirstArgs} args - Arguments to find a PlantingTable
     * @example
     * // Get one PlantingTable
     * const plantingTable = await prisma.plantingTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plantingTableFindFirstArgs>(args?: SelectSubset<T, plantingTableFindFirstArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantingTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantingTableFindFirstOrThrowArgs} args - Arguments to find a PlantingTable
     * @example
     * // Get one PlantingTable
     * const plantingTable = await prisma.plantingTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plantingTableFindFirstOrThrowArgs>(args?: SelectSubset<T, plantingTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantingTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantingTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantingTables
     * const plantingTables = await prisma.plantingTable.findMany()
     * 
     * // Get first 10 PlantingTables
     * const plantingTables = await prisma.plantingTable.findMany({ take: 10 })
     * 
     * // Only select the `plantingId`
     * const plantingTableWithPlantingIdOnly = await prisma.plantingTable.findMany({ select: { plantingId: true } })
     * 
     */
    findMany<T extends plantingTableFindManyArgs>(args?: SelectSubset<T, plantingTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantingTable.
     * @param {plantingTableCreateArgs} args - Arguments to create a PlantingTable.
     * @example
     * // Create one PlantingTable
     * const PlantingTable = await prisma.plantingTable.create({
     *   data: {
     *     // ... data to create a PlantingTable
     *   }
     * })
     * 
     */
    create<T extends plantingTableCreateArgs>(args: SelectSubset<T, plantingTableCreateArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantingTables.
     * @param {plantingTableCreateManyArgs} args - Arguments to create many PlantingTables.
     * @example
     * // Create many PlantingTables
     * const plantingTable = await prisma.plantingTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plantingTableCreateManyArgs>(args?: SelectSubset<T, plantingTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantingTables and returns the data saved in the database.
     * @param {plantingTableCreateManyAndReturnArgs} args - Arguments to create many PlantingTables.
     * @example
     * // Create many PlantingTables
     * const plantingTable = await prisma.plantingTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantingTables and only return the `plantingId`
     * const plantingTableWithPlantingIdOnly = await prisma.plantingTable.createManyAndReturn({
     *   select: { plantingId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends plantingTableCreateManyAndReturnArgs>(args?: SelectSubset<T, plantingTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantingTable.
     * @param {plantingTableDeleteArgs} args - Arguments to delete one PlantingTable.
     * @example
     * // Delete one PlantingTable
     * const PlantingTable = await prisma.plantingTable.delete({
     *   where: {
     *     // ... filter to delete one PlantingTable
     *   }
     * })
     * 
     */
    delete<T extends plantingTableDeleteArgs>(args: SelectSubset<T, plantingTableDeleteArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantingTable.
     * @param {plantingTableUpdateArgs} args - Arguments to update one PlantingTable.
     * @example
     * // Update one PlantingTable
     * const plantingTable = await prisma.plantingTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plantingTableUpdateArgs>(args: SelectSubset<T, plantingTableUpdateArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantingTables.
     * @param {plantingTableDeleteManyArgs} args - Arguments to filter PlantingTables to delete.
     * @example
     * // Delete a few PlantingTables
     * const { count } = await prisma.plantingTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plantingTableDeleteManyArgs>(args?: SelectSubset<T, plantingTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantingTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantingTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantingTables
     * const plantingTable = await prisma.plantingTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plantingTableUpdateManyArgs>(args: SelectSubset<T, plantingTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantingTables and returns the data updated in the database.
     * @param {plantingTableUpdateManyAndReturnArgs} args - Arguments to update many PlantingTables.
     * @example
     * // Update many PlantingTables
     * const plantingTable = await prisma.plantingTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantingTables and only return the `plantingId`
     * const plantingTableWithPlantingIdOnly = await prisma.plantingTable.updateManyAndReturn({
     *   select: { plantingId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends plantingTableUpdateManyAndReturnArgs>(args: SelectSubset<T, plantingTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantingTable.
     * @param {plantingTableUpsertArgs} args - Arguments to update or create a PlantingTable.
     * @example
     * // Update or create a PlantingTable
     * const plantingTable = await prisma.plantingTable.upsert({
     *   create: {
     *     // ... data to create a PlantingTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantingTable we want to update
     *   }
     * })
     */
    upsert<T extends plantingTableUpsertArgs>(args: SelectSubset<T, plantingTableUpsertArgs<ExtArgs>>): Prisma__plantingTableClient<$Result.GetResult<Prisma.$plantingTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantingTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantingTableCountArgs} args - Arguments to filter PlantingTables to count.
     * @example
     * // Count the number of PlantingTables
     * const count = await prisma.plantingTable.count({
     *   where: {
     *     // ... the filter for the PlantingTables we want to count
     *   }
     * })
    **/
    count<T extends plantingTableCountArgs>(
      args?: Subset<T, plantingTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantingTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantingTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantingTableAggregateArgs>(args: Subset<T, PlantingTableAggregateArgs>): Prisma.PrismaPromise<GetPlantingTableAggregateType<T>>

    /**
     * Group by PlantingTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantingTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plantingTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plantingTableGroupByArgs['orderBy'] }
        : { orderBy?: plantingTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plantingTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantingTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plantingTable model
   */
  readonly fields: plantingTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plantingTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plantingTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropTable<T extends plantingTable$cropTableArgs<ExtArgs> = {}>(args?: Subset<T, plantingTable$cropTableArgs<ExtArgs>>): Prisma__cropTableClient<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    landTable<T extends plantingTable$landTableArgs<ExtArgs> = {}>(args?: Subset<T, plantingTable$landTableArgs<ExtArgs>>): Prisma__landTableClient<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plantingTable model
   */
  interface plantingTableFieldRefs {
    readonly plantingId: FieldRef<"plantingTable", 'String'>
    readonly landId: FieldRef<"plantingTable", 'String'>
    readonly planted: FieldRef<"plantingTable", 'Int'>
    readonly plantingDate: FieldRef<"plantingTable", 'DateTime'>
    readonly createdAt: FieldRef<"plantingTable", 'DateTime'>
    readonly lastEditedAt: FieldRef<"plantingTable", 'DateTime'>
    readonly deleted: FieldRef<"plantingTable", 'Boolean'>
    readonly cropId: FieldRef<"plantingTable", 'String'>
    readonly plantingNotes: FieldRef<"plantingTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plantingTable findUnique
   */
  export type plantingTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * Filter, which plantingTable to fetch.
     */
    where: plantingTableWhereUniqueInput
  }

  /**
   * plantingTable findUniqueOrThrow
   */
  export type plantingTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * Filter, which plantingTable to fetch.
     */
    where: plantingTableWhereUniqueInput
  }

  /**
   * plantingTable findFirst
   */
  export type plantingTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * Filter, which plantingTable to fetch.
     */
    where?: plantingTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plantingTables to fetch.
     */
    orderBy?: plantingTableOrderByWithRelationInput | plantingTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plantingTables.
     */
    cursor?: plantingTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plantingTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plantingTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plantingTables.
     */
    distinct?: PlantingTableScalarFieldEnum | PlantingTableScalarFieldEnum[]
  }

  /**
   * plantingTable findFirstOrThrow
   */
  export type plantingTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * Filter, which plantingTable to fetch.
     */
    where?: plantingTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plantingTables to fetch.
     */
    orderBy?: plantingTableOrderByWithRelationInput | plantingTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plantingTables.
     */
    cursor?: plantingTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plantingTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plantingTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plantingTables.
     */
    distinct?: PlantingTableScalarFieldEnum | PlantingTableScalarFieldEnum[]
  }

  /**
   * plantingTable findMany
   */
  export type plantingTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * Filter, which plantingTables to fetch.
     */
    where?: plantingTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plantingTables to fetch.
     */
    orderBy?: plantingTableOrderByWithRelationInput | plantingTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plantingTables.
     */
    cursor?: plantingTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plantingTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plantingTables.
     */
    skip?: number
    distinct?: PlantingTableScalarFieldEnum | PlantingTableScalarFieldEnum[]
  }

  /**
   * plantingTable create
   */
  export type plantingTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * The data needed to create a plantingTable.
     */
    data?: XOR<plantingTableCreateInput, plantingTableUncheckedCreateInput>
  }

  /**
   * plantingTable createMany
   */
  export type plantingTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plantingTables.
     */
    data: plantingTableCreateManyInput | plantingTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plantingTable createManyAndReturn
   */
  export type plantingTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * The data used to create many plantingTables.
     */
    data: plantingTableCreateManyInput | plantingTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * plantingTable update
   */
  export type plantingTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * The data needed to update a plantingTable.
     */
    data: XOR<plantingTableUpdateInput, plantingTableUncheckedUpdateInput>
    /**
     * Choose, which plantingTable to update.
     */
    where: plantingTableWhereUniqueInput
  }

  /**
   * plantingTable updateMany
   */
  export type plantingTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plantingTables.
     */
    data: XOR<plantingTableUpdateManyMutationInput, plantingTableUncheckedUpdateManyInput>
    /**
     * Filter which plantingTables to update
     */
    where?: plantingTableWhereInput
    /**
     * Limit how many plantingTables to update.
     */
    limit?: number
  }

  /**
   * plantingTable updateManyAndReturn
   */
  export type plantingTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * The data used to update plantingTables.
     */
    data: XOR<plantingTableUpdateManyMutationInput, plantingTableUncheckedUpdateManyInput>
    /**
     * Filter which plantingTables to update
     */
    where?: plantingTableWhereInput
    /**
     * Limit how many plantingTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * plantingTable upsert
   */
  export type plantingTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * The filter to search for the plantingTable to update in case it exists.
     */
    where: plantingTableWhereUniqueInput
    /**
     * In case the plantingTable found by the `where` argument doesn't exist, create a new plantingTable with this data.
     */
    create: XOR<plantingTableCreateInput, plantingTableUncheckedCreateInput>
    /**
     * In case the plantingTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plantingTableUpdateInput, plantingTableUncheckedUpdateInput>
  }

  /**
   * plantingTable delete
   */
  export type plantingTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
    /**
     * Filter which plantingTable to delete.
     */
    where: plantingTableWhereUniqueInput
  }

  /**
   * plantingTable deleteMany
   */
  export type plantingTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plantingTables to delete
     */
    where?: plantingTableWhereInput
    /**
     * Limit how many plantingTables to delete.
     */
    limit?: number
  }

  /**
   * plantingTable.cropTable
   */
  export type plantingTable$cropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    where?: cropTableWhereInput
  }

  /**
   * plantingTable.landTable
   */
  export type plantingTable$landTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    where?: landTableWhereInput
  }

  /**
   * plantingTable without action
   */
  export type plantingTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plantingTable
     */
    select?: plantingTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plantingTable
     */
    omit?: plantingTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantingTableInclude<ExtArgs> | null
  }


  /**
   * Model profilesTable
   */

  export type AggregateProfilesTable = {
    _count: ProfilesTableCountAggregateOutputType | null
    _min: ProfilesTableMinAggregateOutputType | null
    _max: ProfilesTableMaxAggregateOutputType | null
  }

  export type ProfilesTableMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    firstname: string | null
    lastname: string | null
    phonenumber: string | null
    isactive: boolean | null
    isverified: boolean | null
    role: $Enums.user_role | null
    createdat: Date | null
    updatedat: Date | null
    lastlogin: Date | null
    twofactorenabled: boolean | null
    twofactorsecret: string | null
    organizationid: string | null
    locale: string | null
    timezone: string | null
  }

  export type ProfilesTableMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    firstname: string | null
    lastname: string | null
    phonenumber: string | null
    isactive: boolean | null
    isverified: boolean | null
    role: $Enums.user_role | null
    createdat: Date | null
    updatedat: Date | null
    lastlogin: Date | null
    twofactorenabled: boolean | null
    twofactorsecret: string | null
    organizationid: string | null
    locale: string | null
    timezone: string | null
  }

  export type ProfilesTableCountAggregateOutputType = {
    id: number
    user_id: number
    firstname: number
    lastname: number
    phonenumber: number
    isactive: number
    isverified: number
    role: number
    permissions: number
    createdat: number
    updatedat: number
    lastlogin: number
    twofactorenabled: number
    twofactorsecret: number
    organizationid: number
    locale: number
    timezone: number
    _all: number
  }


  export type ProfilesTableMinAggregateInputType = {
    id?: true
    user_id?: true
    firstname?: true
    lastname?: true
    phonenumber?: true
    isactive?: true
    isverified?: true
    role?: true
    createdat?: true
    updatedat?: true
    lastlogin?: true
    twofactorenabled?: true
    twofactorsecret?: true
    organizationid?: true
    locale?: true
    timezone?: true
  }

  export type ProfilesTableMaxAggregateInputType = {
    id?: true
    user_id?: true
    firstname?: true
    lastname?: true
    phonenumber?: true
    isactive?: true
    isverified?: true
    role?: true
    createdat?: true
    updatedat?: true
    lastlogin?: true
    twofactorenabled?: true
    twofactorsecret?: true
    organizationid?: true
    locale?: true
    timezone?: true
  }

  export type ProfilesTableCountAggregateInputType = {
    id?: true
    user_id?: true
    firstname?: true
    lastname?: true
    phonenumber?: true
    isactive?: true
    isverified?: true
    role?: true
    permissions?: true
    createdat?: true
    updatedat?: true
    lastlogin?: true
    twofactorenabled?: true
    twofactorsecret?: true
    organizationid?: true
    locale?: true
    timezone?: true
    _all?: true
  }

  export type ProfilesTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profilesTable to aggregate.
     */
    where?: profilesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profilesTables to fetch.
     */
    orderBy?: profilesTableOrderByWithRelationInput | profilesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profilesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profilesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profilesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profilesTables
    **/
    _count?: true | ProfilesTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfilesTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfilesTableMaxAggregateInputType
  }

  export type GetProfilesTableAggregateType<T extends ProfilesTableAggregateArgs> = {
        [P in keyof T & keyof AggregateProfilesTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfilesTable[P]>
      : GetScalarType<T[P], AggregateProfilesTable[P]>
  }




  export type profilesTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profilesTableWhereInput
    orderBy?: profilesTableOrderByWithAggregationInput | profilesTableOrderByWithAggregationInput[]
    by: ProfilesTableScalarFieldEnum[] | ProfilesTableScalarFieldEnum
    having?: profilesTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfilesTableCountAggregateInputType | true
    _min?: ProfilesTableMinAggregateInputType
    _max?: ProfilesTableMaxAggregateInputType
  }

  export type ProfilesTableGroupByOutputType = {
    id: string
    user_id: string
    firstname: string
    lastname: string
    phonenumber: string | null
    isactive: boolean | null
    isverified: boolean | null
    role: $Enums.user_role | null
    permissions: JsonValue | null
    createdat: Date | null
    updatedat: Date | null
    lastlogin: Date | null
    twofactorenabled: boolean | null
    twofactorsecret: string | null
    organizationid: string | null
    locale: string | null
    timezone: string | null
    _count: ProfilesTableCountAggregateOutputType | null
    _min: ProfilesTableMinAggregateOutputType | null
    _max: ProfilesTableMaxAggregateOutputType | null
  }

  type GetProfilesTableGroupByPayload<T extends profilesTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfilesTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfilesTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfilesTableGroupByOutputType[P]>
            : GetScalarType<T[P], ProfilesTableGroupByOutputType[P]>
        }
      >
    >


  export type profilesTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    isactive?: boolean
    isverified?: boolean
    role?: boolean
    permissions?: boolean
    createdat?: boolean
    updatedat?: boolean
    lastlogin?: boolean
    twofactorenabled?: boolean
    twofactorsecret?: boolean
    organizationid?: boolean
    locale?: boolean
    timezone?: boolean
    organizationsTable?: boolean | profilesTable$organizationsTableArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profilesTable"]>

  export type profilesTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    isactive?: boolean
    isverified?: boolean
    role?: boolean
    permissions?: boolean
    createdat?: boolean
    updatedat?: boolean
    lastlogin?: boolean
    twofactorenabled?: boolean
    twofactorsecret?: boolean
    organizationid?: boolean
    locale?: boolean
    timezone?: boolean
    organizationsTable?: boolean | profilesTable$organizationsTableArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profilesTable"]>

  export type profilesTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    isactive?: boolean
    isverified?: boolean
    role?: boolean
    permissions?: boolean
    createdat?: boolean
    updatedat?: boolean
    lastlogin?: boolean
    twofactorenabled?: boolean
    twofactorsecret?: boolean
    organizationid?: boolean
    locale?: boolean
    timezone?: boolean
    organizationsTable?: boolean | profilesTable$organizationsTableArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profilesTable"]>

  export type profilesTableSelectScalar = {
    id?: boolean
    user_id?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    isactive?: boolean
    isverified?: boolean
    role?: boolean
    permissions?: boolean
    createdat?: boolean
    updatedat?: boolean
    lastlogin?: boolean
    twofactorenabled?: boolean
    twofactorsecret?: boolean
    organizationid?: boolean
    locale?: boolean
    timezone?: boolean
  }

  export type profilesTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "firstname" | "lastname" | "phonenumber" | "isactive" | "isverified" | "role" | "permissions" | "createdat" | "updatedat" | "lastlogin" | "twofactorenabled" | "twofactorsecret" | "organizationid" | "locale" | "timezone", ExtArgs["result"]["profilesTable"]>
  export type profilesTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationsTable?: boolean | profilesTable$organizationsTableArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type profilesTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationsTable?: boolean | profilesTable$organizationsTableArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type profilesTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationsTable?: boolean | profilesTable$organizationsTableArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $profilesTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profilesTable"
    objects: {
      organizationsTable: Prisma.$organizationsTablePayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      firstname: string
      lastname: string
      phonenumber: string | null
      isactive: boolean | null
      isverified: boolean | null
      role: $Enums.user_role | null
      permissions: Prisma.JsonValue | null
      createdat: Date | null
      updatedat: Date | null
      lastlogin: Date | null
      twofactorenabled: boolean | null
      twofactorsecret: string | null
      organizationid: string | null
      locale: string | null
      timezone: string | null
    }, ExtArgs["result"]["profilesTable"]>
    composites: {}
  }

  type profilesTableGetPayload<S extends boolean | null | undefined | profilesTableDefaultArgs> = $Result.GetResult<Prisma.$profilesTablePayload, S>

  type profilesTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<profilesTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfilesTableCountAggregateInputType | true
    }

  export interface profilesTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profilesTable'], meta: { name: 'profilesTable' } }
    /**
     * Find zero or one ProfilesTable that matches the filter.
     * @param {profilesTableFindUniqueArgs} args - Arguments to find a ProfilesTable
     * @example
     * // Get one ProfilesTable
     * const profilesTable = await prisma.profilesTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profilesTableFindUniqueArgs>(args: SelectSubset<T, profilesTableFindUniqueArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfilesTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {profilesTableFindUniqueOrThrowArgs} args - Arguments to find a ProfilesTable
     * @example
     * // Get one ProfilesTable
     * const profilesTable = await prisma.profilesTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profilesTableFindUniqueOrThrowArgs>(args: SelectSubset<T, profilesTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfilesTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesTableFindFirstArgs} args - Arguments to find a ProfilesTable
     * @example
     * // Get one ProfilesTable
     * const profilesTable = await prisma.profilesTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profilesTableFindFirstArgs>(args?: SelectSubset<T, profilesTableFindFirstArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfilesTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesTableFindFirstOrThrowArgs} args - Arguments to find a ProfilesTable
     * @example
     * // Get one ProfilesTable
     * const profilesTable = await prisma.profilesTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profilesTableFindFirstOrThrowArgs>(args?: SelectSubset<T, profilesTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfilesTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfilesTables
     * const profilesTables = await prisma.profilesTable.findMany()
     * 
     * // Get first 10 ProfilesTables
     * const profilesTables = await prisma.profilesTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profilesTableWithIdOnly = await prisma.profilesTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profilesTableFindManyArgs>(args?: SelectSubset<T, profilesTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfilesTable.
     * @param {profilesTableCreateArgs} args - Arguments to create a ProfilesTable.
     * @example
     * // Create one ProfilesTable
     * const ProfilesTable = await prisma.profilesTable.create({
     *   data: {
     *     // ... data to create a ProfilesTable
     *   }
     * })
     * 
     */
    create<T extends profilesTableCreateArgs>(args: SelectSubset<T, profilesTableCreateArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfilesTables.
     * @param {profilesTableCreateManyArgs} args - Arguments to create many ProfilesTables.
     * @example
     * // Create many ProfilesTables
     * const profilesTable = await prisma.profilesTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profilesTableCreateManyArgs>(args?: SelectSubset<T, profilesTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfilesTables and returns the data saved in the database.
     * @param {profilesTableCreateManyAndReturnArgs} args - Arguments to create many ProfilesTables.
     * @example
     * // Create many ProfilesTables
     * const profilesTable = await prisma.profilesTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfilesTables and only return the `id`
     * const profilesTableWithIdOnly = await prisma.profilesTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends profilesTableCreateManyAndReturnArgs>(args?: SelectSubset<T, profilesTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfilesTable.
     * @param {profilesTableDeleteArgs} args - Arguments to delete one ProfilesTable.
     * @example
     * // Delete one ProfilesTable
     * const ProfilesTable = await prisma.profilesTable.delete({
     *   where: {
     *     // ... filter to delete one ProfilesTable
     *   }
     * })
     * 
     */
    delete<T extends profilesTableDeleteArgs>(args: SelectSubset<T, profilesTableDeleteArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfilesTable.
     * @param {profilesTableUpdateArgs} args - Arguments to update one ProfilesTable.
     * @example
     * // Update one ProfilesTable
     * const profilesTable = await prisma.profilesTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profilesTableUpdateArgs>(args: SelectSubset<T, profilesTableUpdateArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfilesTables.
     * @param {profilesTableDeleteManyArgs} args - Arguments to filter ProfilesTables to delete.
     * @example
     * // Delete a few ProfilesTables
     * const { count } = await prisma.profilesTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profilesTableDeleteManyArgs>(args?: SelectSubset<T, profilesTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfilesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfilesTables
     * const profilesTable = await prisma.profilesTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profilesTableUpdateManyArgs>(args: SelectSubset<T, profilesTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfilesTables and returns the data updated in the database.
     * @param {profilesTableUpdateManyAndReturnArgs} args - Arguments to update many ProfilesTables.
     * @example
     * // Update many ProfilesTables
     * const profilesTable = await prisma.profilesTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfilesTables and only return the `id`
     * const profilesTableWithIdOnly = await prisma.profilesTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends profilesTableUpdateManyAndReturnArgs>(args: SelectSubset<T, profilesTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfilesTable.
     * @param {profilesTableUpsertArgs} args - Arguments to update or create a ProfilesTable.
     * @example
     * // Update or create a ProfilesTable
     * const profilesTable = await prisma.profilesTable.upsert({
     *   create: {
     *     // ... data to create a ProfilesTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfilesTable we want to update
     *   }
     * })
     */
    upsert<T extends profilesTableUpsertArgs>(args: SelectSubset<T, profilesTableUpsertArgs<ExtArgs>>): Prisma__profilesTableClient<$Result.GetResult<Prisma.$profilesTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfilesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesTableCountArgs} args - Arguments to filter ProfilesTables to count.
     * @example
     * // Count the number of ProfilesTables
     * const count = await prisma.profilesTable.count({
     *   where: {
     *     // ... the filter for the ProfilesTables we want to count
     *   }
     * })
    **/
    count<T extends profilesTableCountArgs>(
      args?: Subset<T, profilesTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfilesTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfilesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfilesTableAggregateArgs>(args: Subset<T, ProfilesTableAggregateArgs>): Prisma.PrismaPromise<GetProfilesTableAggregateType<T>>

    /**
     * Group by ProfilesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profilesTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profilesTableGroupByArgs['orderBy'] }
        : { orderBy?: profilesTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profilesTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfilesTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profilesTable model
   */
  readonly fields: profilesTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profilesTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profilesTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizationsTable<T extends profilesTable$organizationsTableArgs<ExtArgs> = {}>(args?: Subset<T, profilesTable$organizationsTableArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profilesTable model
   */
  interface profilesTableFieldRefs {
    readonly id: FieldRef<"profilesTable", 'String'>
    readonly user_id: FieldRef<"profilesTable", 'String'>
    readonly firstname: FieldRef<"profilesTable", 'String'>
    readonly lastname: FieldRef<"profilesTable", 'String'>
    readonly phonenumber: FieldRef<"profilesTable", 'String'>
    readonly isactive: FieldRef<"profilesTable", 'Boolean'>
    readonly isverified: FieldRef<"profilesTable", 'Boolean'>
    readonly role: FieldRef<"profilesTable", 'user_role'>
    readonly permissions: FieldRef<"profilesTable", 'Json'>
    readonly createdat: FieldRef<"profilesTable", 'DateTime'>
    readonly updatedat: FieldRef<"profilesTable", 'DateTime'>
    readonly lastlogin: FieldRef<"profilesTable", 'DateTime'>
    readonly twofactorenabled: FieldRef<"profilesTable", 'Boolean'>
    readonly twofactorsecret: FieldRef<"profilesTable", 'String'>
    readonly organizationid: FieldRef<"profilesTable", 'String'>
    readonly locale: FieldRef<"profilesTable", 'String'>
    readonly timezone: FieldRef<"profilesTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * profilesTable findUnique
   */
  export type profilesTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * Filter, which profilesTable to fetch.
     */
    where: profilesTableWhereUniqueInput
  }

  /**
   * profilesTable findUniqueOrThrow
   */
  export type profilesTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * Filter, which profilesTable to fetch.
     */
    where: profilesTableWhereUniqueInput
  }

  /**
   * profilesTable findFirst
   */
  export type profilesTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * Filter, which profilesTable to fetch.
     */
    where?: profilesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profilesTables to fetch.
     */
    orderBy?: profilesTableOrderByWithRelationInput | profilesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profilesTables.
     */
    cursor?: profilesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profilesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profilesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profilesTables.
     */
    distinct?: ProfilesTableScalarFieldEnum | ProfilesTableScalarFieldEnum[]
  }

  /**
   * profilesTable findFirstOrThrow
   */
  export type profilesTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * Filter, which profilesTable to fetch.
     */
    where?: profilesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profilesTables to fetch.
     */
    orderBy?: profilesTableOrderByWithRelationInput | profilesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profilesTables.
     */
    cursor?: profilesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profilesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profilesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profilesTables.
     */
    distinct?: ProfilesTableScalarFieldEnum | ProfilesTableScalarFieldEnum[]
  }

  /**
   * profilesTable findMany
   */
  export type profilesTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * Filter, which profilesTables to fetch.
     */
    where?: profilesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profilesTables to fetch.
     */
    orderBy?: profilesTableOrderByWithRelationInput | profilesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profilesTables.
     */
    cursor?: profilesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profilesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profilesTables.
     */
    skip?: number
    distinct?: ProfilesTableScalarFieldEnum | ProfilesTableScalarFieldEnum[]
  }

  /**
   * profilesTable create
   */
  export type profilesTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * The data needed to create a profilesTable.
     */
    data: XOR<profilesTableCreateInput, profilesTableUncheckedCreateInput>
  }

  /**
   * profilesTable createMany
   */
  export type profilesTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profilesTables.
     */
    data: profilesTableCreateManyInput | profilesTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profilesTable createManyAndReturn
   */
  export type profilesTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * The data used to create many profilesTables.
     */
    data: profilesTableCreateManyInput | profilesTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * profilesTable update
   */
  export type profilesTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * The data needed to update a profilesTable.
     */
    data: XOR<profilesTableUpdateInput, profilesTableUncheckedUpdateInput>
    /**
     * Choose, which profilesTable to update.
     */
    where: profilesTableWhereUniqueInput
  }

  /**
   * profilesTable updateMany
   */
  export type profilesTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profilesTables.
     */
    data: XOR<profilesTableUpdateManyMutationInput, profilesTableUncheckedUpdateManyInput>
    /**
     * Filter which profilesTables to update
     */
    where?: profilesTableWhereInput
    /**
     * Limit how many profilesTables to update.
     */
    limit?: number
  }

  /**
   * profilesTable updateManyAndReturn
   */
  export type profilesTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * The data used to update profilesTables.
     */
    data: XOR<profilesTableUpdateManyMutationInput, profilesTableUncheckedUpdateManyInput>
    /**
     * Filter which profilesTables to update
     */
    where?: profilesTableWhereInput
    /**
     * Limit how many profilesTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * profilesTable upsert
   */
  export type profilesTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * The filter to search for the profilesTable to update in case it exists.
     */
    where: profilesTableWhereUniqueInput
    /**
     * In case the profilesTable found by the `where` argument doesn't exist, create a new profilesTable with this data.
     */
    create: XOR<profilesTableCreateInput, profilesTableUncheckedCreateInput>
    /**
     * In case the profilesTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profilesTableUpdateInput, profilesTableUncheckedUpdateInput>
  }

  /**
   * profilesTable delete
   */
  export type profilesTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
    /**
     * Filter which profilesTable to delete.
     */
    where: profilesTableWhereUniqueInput
  }

  /**
   * profilesTable deleteMany
   */
  export type profilesTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profilesTables to delete
     */
    where?: profilesTableWhereInput
    /**
     * Limit how many profilesTables to delete.
     */
    limit?: number
  }

  /**
   * profilesTable.organizationsTable
   */
  export type profilesTable$organizationsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    where?: organizationsTableWhereInput
  }

  /**
   * profilesTable without action
   */
  export type profilesTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profilesTable
     */
    select?: profilesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profilesTable
     */
    omit?: profilesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesTableInclude<ExtArgs> | null
  }


  /**
   * Model projectStakeholdersTable
   */

  export type AggregateProjectStakeholdersTable = {
    _count: ProjectStakeholdersTableCountAggregateOutputType | null
    _min: ProjectStakeholdersTableMinAggregateOutputType | null
    _max: ProjectStakeholdersTableMaxAggregateOutputType | null
  }

  export type ProjectStakeholdersTableMinAggregateOutputType = {
    stakeholderId: string | null
    organizationId: string | null
    stakeholderTypeId: string | null
    projectId: string | null
  }

  export type ProjectStakeholdersTableMaxAggregateOutputType = {
    stakeholderId: string | null
    organizationId: string | null
    stakeholderTypeId: string | null
    projectId: string | null
  }

  export type ProjectStakeholdersTableCountAggregateOutputType = {
    stakeholderId: number
    organizationId: number
    stakeholderTypeId: number
    projectId: number
    _all: number
  }


  export type ProjectStakeholdersTableMinAggregateInputType = {
    stakeholderId?: true
    organizationId?: true
    stakeholderTypeId?: true
    projectId?: true
  }

  export type ProjectStakeholdersTableMaxAggregateInputType = {
    stakeholderId?: true
    organizationId?: true
    stakeholderTypeId?: true
    projectId?: true
  }

  export type ProjectStakeholdersTableCountAggregateInputType = {
    stakeholderId?: true
    organizationId?: true
    stakeholderTypeId?: true
    projectId?: true
    _all?: true
  }

  export type ProjectStakeholdersTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectStakeholdersTable to aggregate.
     */
    where?: projectStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectStakeholdersTables to fetch.
     */
    orderBy?: projectStakeholdersTableOrderByWithRelationInput | projectStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projectStakeholdersTables
    **/
    _count?: true | ProjectStakeholdersTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStakeholdersTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStakeholdersTableMaxAggregateInputType
  }

  export type GetProjectStakeholdersTableAggregateType<T extends ProjectStakeholdersTableAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStakeholdersTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStakeholdersTable[P]>
      : GetScalarType<T[P], AggregateProjectStakeholdersTable[P]>
  }




  export type projectStakeholdersTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectStakeholdersTableWhereInput
    orderBy?: projectStakeholdersTableOrderByWithAggregationInput | projectStakeholdersTableOrderByWithAggregationInput[]
    by: ProjectStakeholdersTableScalarFieldEnum[] | ProjectStakeholdersTableScalarFieldEnum
    having?: projectStakeholdersTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStakeholdersTableCountAggregateInputType | true
    _min?: ProjectStakeholdersTableMinAggregateInputType
    _max?: ProjectStakeholdersTableMaxAggregateInputType
  }

  export type ProjectStakeholdersTableGroupByOutputType = {
    stakeholderId: string
    organizationId: string
    stakeholderTypeId: string
    projectId: string
    _count: ProjectStakeholdersTableCountAggregateOutputType | null
    _min: ProjectStakeholdersTableMinAggregateOutputType | null
    _max: ProjectStakeholdersTableMaxAggregateOutputType | null
  }

  type GetProjectStakeholdersTableGroupByPayload<T extends projectStakeholdersTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStakeholdersTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStakeholdersTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStakeholdersTableGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStakeholdersTableGroupByOutputType[P]>
        }
      >
    >


  export type projectStakeholdersTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stakeholderId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    projectId?: boolean
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    projectsTable?: boolean | projectsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStakeholdersTable"]>

  export type projectStakeholdersTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stakeholderId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    projectId?: boolean
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    projectsTable?: boolean | projectsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStakeholdersTable"]>

  export type projectStakeholdersTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stakeholderId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    projectId?: boolean
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    projectsTable?: boolean | projectsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStakeholdersTable"]>

  export type projectStakeholdersTableSelectScalar = {
    stakeholderId?: boolean
    organizationId?: boolean
    stakeholderTypeId?: boolean
    projectId?: boolean
  }

  export type projectStakeholdersTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stakeholderId" | "organizationId" | "stakeholderTypeId" | "projectId", ExtArgs["result"]["projectStakeholdersTable"]>
  export type projectStakeholdersTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    projectsTable?: boolean | projectsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }
  export type projectStakeholdersTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    projectsTable?: boolean | projectsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }
  export type projectStakeholdersTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationsTable?: boolean | organizationsTableDefaultArgs<ExtArgs>
    projectsTable?: boolean | projectsTableDefaultArgs<ExtArgs>
    stakeholderTypesTable?: boolean | stakeholderTypesTableDefaultArgs<ExtArgs>
  }

  export type $projectStakeholdersTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projectStakeholdersTable"
    objects: {
      organizationsTable: Prisma.$organizationsTablePayload<ExtArgs>
      projectsTable: Prisma.$projectsTablePayload<ExtArgs>
      stakeholderTypesTable: Prisma.$stakeholderTypesTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      stakeholderId: string
      organizationId: string
      stakeholderTypeId: string
      projectId: string
    }, ExtArgs["result"]["projectStakeholdersTable"]>
    composites: {}
  }

  type projectStakeholdersTableGetPayload<S extends boolean | null | undefined | projectStakeholdersTableDefaultArgs> = $Result.GetResult<Prisma.$projectStakeholdersTablePayload, S>

  type projectStakeholdersTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectStakeholdersTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectStakeholdersTableCountAggregateInputType | true
    }

  export interface projectStakeholdersTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projectStakeholdersTable'], meta: { name: 'projectStakeholdersTable' } }
    /**
     * Find zero or one ProjectStakeholdersTable that matches the filter.
     * @param {projectStakeholdersTableFindUniqueArgs} args - Arguments to find a ProjectStakeholdersTable
     * @example
     * // Get one ProjectStakeholdersTable
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectStakeholdersTableFindUniqueArgs>(args: SelectSubset<T, projectStakeholdersTableFindUniqueArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectStakeholdersTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectStakeholdersTableFindUniqueOrThrowArgs} args - Arguments to find a ProjectStakeholdersTable
     * @example
     * // Get one ProjectStakeholdersTable
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectStakeholdersTableFindUniqueOrThrowArgs>(args: SelectSubset<T, projectStakeholdersTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStakeholdersTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectStakeholdersTableFindFirstArgs} args - Arguments to find a ProjectStakeholdersTable
     * @example
     * // Get one ProjectStakeholdersTable
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectStakeholdersTableFindFirstArgs>(args?: SelectSubset<T, projectStakeholdersTableFindFirstArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStakeholdersTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectStakeholdersTableFindFirstOrThrowArgs} args - Arguments to find a ProjectStakeholdersTable
     * @example
     * // Get one ProjectStakeholdersTable
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectStakeholdersTableFindFirstOrThrowArgs>(args?: SelectSubset<T, projectStakeholdersTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectStakeholdersTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectStakeholdersTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStakeholdersTables
     * const projectStakeholdersTables = await prisma.projectStakeholdersTable.findMany()
     * 
     * // Get first 10 ProjectStakeholdersTables
     * const projectStakeholdersTables = await prisma.projectStakeholdersTable.findMany({ take: 10 })
     * 
     * // Only select the `stakeholderId`
     * const projectStakeholdersTableWithStakeholderIdOnly = await prisma.projectStakeholdersTable.findMany({ select: { stakeholderId: true } })
     * 
     */
    findMany<T extends projectStakeholdersTableFindManyArgs>(args?: SelectSubset<T, projectStakeholdersTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectStakeholdersTable.
     * @param {projectStakeholdersTableCreateArgs} args - Arguments to create a ProjectStakeholdersTable.
     * @example
     * // Create one ProjectStakeholdersTable
     * const ProjectStakeholdersTable = await prisma.projectStakeholdersTable.create({
     *   data: {
     *     // ... data to create a ProjectStakeholdersTable
     *   }
     * })
     * 
     */
    create<T extends projectStakeholdersTableCreateArgs>(args: SelectSubset<T, projectStakeholdersTableCreateArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectStakeholdersTables.
     * @param {projectStakeholdersTableCreateManyArgs} args - Arguments to create many ProjectStakeholdersTables.
     * @example
     * // Create many ProjectStakeholdersTables
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectStakeholdersTableCreateManyArgs>(args?: SelectSubset<T, projectStakeholdersTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectStakeholdersTables and returns the data saved in the database.
     * @param {projectStakeholdersTableCreateManyAndReturnArgs} args - Arguments to create many ProjectStakeholdersTables.
     * @example
     * // Create many ProjectStakeholdersTables
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectStakeholdersTables and only return the `stakeholderId`
     * const projectStakeholdersTableWithStakeholderIdOnly = await prisma.projectStakeholdersTable.createManyAndReturn({
     *   select: { stakeholderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectStakeholdersTableCreateManyAndReturnArgs>(args?: SelectSubset<T, projectStakeholdersTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectStakeholdersTable.
     * @param {projectStakeholdersTableDeleteArgs} args - Arguments to delete one ProjectStakeholdersTable.
     * @example
     * // Delete one ProjectStakeholdersTable
     * const ProjectStakeholdersTable = await prisma.projectStakeholdersTable.delete({
     *   where: {
     *     // ... filter to delete one ProjectStakeholdersTable
     *   }
     * })
     * 
     */
    delete<T extends projectStakeholdersTableDeleteArgs>(args: SelectSubset<T, projectStakeholdersTableDeleteArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectStakeholdersTable.
     * @param {projectStakeholdersTableUpdateArgs} args - Arguments to update one ProjectStakeholdersTable.
     * @example
     * // Update one ProjectStakeholdersTable
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectStakeholdersTableUpdateArgs>(args: SelectSubset<T, projectStakeholdersTableUpdateArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectStakeholdersTables.
     * @param {projectStakeholdersTableDeleteManyArgs} args - Arguments to filter ProjectStakeholdersTables to delete.
     * @example
     * // Delete a few ProjectStakeholdersTables
     * const { count } = await prisma.projectStakeholdersTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectStakeholdersTableDeleteManyArgs>(args?: SelectSubset<T, projectStakeholdersTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStakeholdersTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectStakeholdersTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStakeholdersTables
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectStakeholdersTableUpdateManyArgs>(args: SelectSubset<T, projectStakeholdersTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStakeholdersTables and returns the data updated in the database.
     * @param {projectStakeholdersTableUpdateManyAndReturnArgs} args - Arguments to update many ProjectStakeholdersTables.
     * @example
     * // Update many ProjectStakeholdersTables
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectStakeholdersTables and only return the `stakeholderId`
     * const projectStakeholdersTableWithStakeholderIdOnly = await prisma.projectStakeholdersTable.updateManyAndReturn({
     *   select: { stakeholderId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projectStakeholdersTableUpdateManyAndReturnArgs>(args: SelectSubset<T, projectStakeholdersTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectStakeholdersTable.
     * @param {projectStakeholdersTableUpsertArgs} args - Arguments to update or create a ProjectStakeholdersTable.
     * @example
     * // Update or create a ProjectStakeholdersTable
     * const projectStakeholdersTable = await prisma.projectStakeholdersTable.upsert({
     *   create: {
     *     // ... data to create a ProjectStakeholdersTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStakeholdersTable we want to update
     *   }
     * })
     */
    upsert<T extends projectStakeholdersTableUpsertArgs>(args: SelectSubset<T, projectStakeholdersTableUpsertArgs<ExtArgs>>): Prisma__projectStakeholdersTableClient<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectStakeholdersTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectStakeholdersTableCountArgs} args - Arguments to filter ProjectStakeholdersTables to count.
     * @example
     * // Count the number of ProjectStakeholdersTables
     * const count = await prisma.projectStakeholdersTable.count({
     *   where: {
     *     // ... the filter for the ProjectStakeholdersTables we want to count
     *   }
     * })
    **/
    count<T extends projectStakeholdersTableCountArgs>(
      args?: Subset<T, projectStakeholdersTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStakeholdersTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStakeholdersTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStakeholdersTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStakeholdersTableAggregateArgs>(args: Subset<T, ProjectStakeholdersTableAggregateArgs>): Prisma.PrismaPromise<GetProjectStakeholdersTableAggregateType<T>>

    /**
     * Group by ProjectStakeholdersTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectStakeholdersTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectStakeholdersTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectStakeholdersTableGroupByArgs['orderBy'] }
        : { orderBy?: projectStakeholdersTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectStakeholdersTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStakeholdersTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projectStakeholdersTable model
   */
  readonly fields: projectStakeholdersTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projectStakeholdersTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectStakeholdersTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizationsTable<T extends organizationsTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsTableDefaultArgs<ExtArgs>>): Prisma__organizationsTableClient<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectsTable<T extends projectsTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projectsTableDefaultArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stakeholderTypesTable<T extends stakeholderTypesTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderTypesTableDefaultArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projectStakeholdersTable model
   */
  interface projectStakeholdersTableFieldRefs {
    readonly stakeholderId: FieldRef<"projectStakeholdersTable", 'String'>
    readonly organizationId: FieldRef<"projectStakeholdersTable", 'String'>
    readonly stakeholderTypeId: FieldRef<"projectStakeholdersTable", 'String'>
    readonly projectId: FieldRef<"projectStakeholdersTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * projectStakeholdersTable findUnique
   */
  export type projectStakeholdersTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which projectStakeholdersTable to fetch.
     */
    where: projectStakeholdersTableWhereUniqueInput
  }

  /**
   * projectStakeholdersTable findUniqueOrThrow
   */
  export type projectStakeholdersTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which projectStakeholdersTable to fetch.
     */
    where: projectStakeholdersTableWhereUniqueInput
  }

  /**
   * projectStakeholdersTable findFirst
   */
  export type projectStakeholdersTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which projectStakeholdersTable to fetch.
     */
    where?: projectStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectStakeholdersTables to fetch.
     */
    orderBy?: projectStakeholdersTableOrderByWithRelationInput | projectStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectStakeholdersTables.
     */
    cursor?: projectStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectStakeholdersTables.
     */
    distinct?: ProjectStakeholdersTableScalarFieldEnum | ProjectStakeholdersTableScalarFieldEnum[]
  }

  /**
   * projectStakeholdersTable findFirstOrThrow
   */
  export type projectStakeholdersTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which projectStakeholdersTable to fetch.
     */
    where?: projectStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectStakeholdersTables to fetch.
     */
    orderBy?: projectStakeholdersTableOrderByWithRelationInput | projectStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectStakeholdersTables.
     */
    cursor?: projectStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectStakeholdersTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectStakeholdersTables.
     */
    distinct?: ProjectStakeholdersTableScalarFieldEnum | ProjectStakeholdersTableScalarFieldEnum[]
  }

  /**
   * projectStakeholdersTable findMany
   */
  export type projectStakeholdersTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter, which projectStakeholdersTables to fetch.
     */
    where?: projectStakeholdersTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectStakeholdersTables to fetch.
     */
    orderBy?: projectStakeholdersTableOrderByWithRelationInput | projectStakeholdersTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projectStakeholdersTables.
     */
    cursor?: projectStakeholdersTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectStakeholdersTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectStakeholdersTables.
     */
    skip?: number
    distinct?: ProjectStakeholdersTableScalarFieldEnum | ProjectStakeholdersTableScalarFieldEnum[]
  }

  /**
   * projectStakeholdersTable create
   */
  export type projectStakeholdersTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * The data needed to create a projectStakeholdersTable.
     */
    data: XOR<projectStakeholdersTableCreateInput, projectStakeholdersTableUncheckedCreateInput>
  }

  /**
   * projectStakeholdersTable createMany
   */
  export type projectStakeholdersTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projectStakeholdersTables.
     */
    data: projectStakeholdersTableCreateManyInput | projectStakeholdersTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projectStakeholdersTable createManyAndReturn
   */
  export type projectStakeholdersTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * The data used to create many projectStakeholdersTables.
     */
    data: projectStakeholdersTableCreateManyInput | projectStakeholdersTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectStakeholdersTable update
   */
  export type projectStakeholdersTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * The data needed to update a projectStakeholdersTable.
     */
    data: XOR<projectStakeholdersTableUpdateInput, projectStakeholdersTableUncheckedUpdateInput>
    /**
     * Choose, which projectStakeholdersTable to update.
     */
    where: projectStakeholdersTableWhereUniqueInput
  }

  /**
   * projectStakeholdersTable updateMany
   */
  export type projectStakeholdersTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projectStakeholdersTables.
     */
    data: XOR<projectStakeholdersTableUpdateManyMutationInput, projectStakeholdersTableUncheckedUpdateManyInput>
    /**
     * Filter which projectStakeholdersTables to update
     */
    where?: projectStakeholdersTableWhereInput
    /**
     * Limit how many projectStakeholdersTables to update.
     */
    limit?: number
  }

  /**
   * projectStakeholdersTable updateManyAndReturn
   */
  export type projectStakeholdersTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * The data used to update projectStakeholdersTables.
     */
    data: XOR<projectStakeholdersTableUpdateManyMutationInput, projectStakeholdersTableUncheckedUpdateManyInput>
    /**
     * Filter which projectStakeholdersTables to update
     */
    where?: projectStakeholdersTableWhereInput
    /**
     * Limit how many projectStakeholdersTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectStakeholdersTable upsert
   */
  export type projectStakeholdersTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * The filter to search for the projectStakeholdersTable to update in case it exists.
     */
    where: projectStakeholdersTableWhereUniqueInput
    /**
     * In case the projectStakeholdersTable found by the `where` argument doesn't exist, create a new projectStakeholdersTable with this data.
     */
    create: XOR<projectStakeholdersTableCreateInput, projectStakeholdersTableUncheckedCreateInput>
    /**
     * In case the projectStakeholdersTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectStakeholdersTableUpdateInput, projectStakeholdersTableUncheckedUpdateInput>
  }

  /**
   * projectStakeholdersTable delete
   */
  export type projectStakeholdersTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    /**
     * Filter which projectStakeholdersTable to delete.
     */
    where: projectStakeholdersTableWhereUniqueInput
  }

  /**
   * projectStakeholdersTable deleteMany
   */
  export type projectStakeholdersTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectStakeholdersTables to delete
     */
    where?: projectStakeholdersTableWhereInput
    /**
     * Limit how many projectStakeholdersTables to delete.
     */
    limit?: number
  }

  /**
   * projectStakeholdersTable without action
   */
  export type projectStakeholdersTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
  }


  /**
   * Model projectsTable
   */

  export type AggregateProjectsTable = {
    _count: ProjectsTableCountAggregateOutputType | null
    _min: ProjectsTableMinAggregateOutputType | null
    _max: ProjectsTableMaxAggregateOutputType | null
  }

  export type ProjectsTableMinAggregateOutputType = {
    projectId: string | null
    projectName: string | null
    projectNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    csvobjId: string | null
    source: string | null
  }

  export type ProjectsTableMaxAggregateOutputType = {
    projectId: string | null
    projectName: string | null
    projectNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    csvobjId: string | null
    source: string | null
  }

  export type ProjectsTableCountAggregateOutputType = {
    projectId: number
    projectName: number
    projectNotes: number
    createdAt: number
    lastEditedAt: number
    editedBy: number
    deleted: number
    csvobjId: number
    source: number
    _all: number
  }


  export type ProjectsTableMinAggregateInputType = {
    projectId?: true
    projectName?: true
    projectNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    csvobjId?: true
    source?: true
  }

  export type ProjectsTableMaxAggregateInputType = {
    projectId?: true
    projectName?: true
    projectNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    csvobjId?: true
    source?: true
  }

  export type ProjectsTableCountAggregateInputType = {
    projectId?: true
    projectName?: true
    projectNotes?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    csvobjId?: true
    source?: true
    _all?: true
  }

  export type ProjectsTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectsTable to aggregate.
     */
    where?: projectsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectsTables to fetch.
     */
    orderBy?: projectsTableOrderByWithRelationInput | projectsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projectsTables
    **/
    _count?: true | ProjectsTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectsTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectsTableMaxAggregateInputType
  }

  export type GetProjectsTableAggregateType<T extends ProjectsTableAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectsTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectsTable[P]>
      : GetScalarType<T[P], AggregateProjectsTable[P]>
  }




  export type projectsTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectsTableWhereInput
    orderBy?: projectsTableOrderByWithAggregationInput | projectsTableOrderByWithAggregationInput[]
    by: ProjectsTableScalarFieldEnum[] | ProjectsTableScalarFieldEnum
    having?: projectsTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectsTableCountAggregateInputType | true
    _min?: ProjectsTableMinAggregateInputType
    _max?: ProjectsTableMaxAggregateInputType
  }

  export type ProjectsTableGroupByOutputType = {
    projectId: string
    projectName: string
    projectNotes: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    csvobjId: string | null
    source: string | null
    _count: ProjectsTableCountAggregateOutputType | null
    _min: ProjectsTableMinAggregateOutputType | null
    _max: ProjectsTableMaxAggregateOutputType | null
  }

  type GetProjectsTableGroupByPayload<T extends projectsTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectsTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectsTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectsTableGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectsTableGroupByOutputType[P]>
        }
      >
    >


  export type projectsTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    projectName?: boolean
    projectNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    csvobjId?: boolean
    source?: boolean
    cropTable?: boolean | projectsTable$cropTableArgs<ExtArgs>
    landTable?: boolean | projectsTable$landTableArgs<ExtArgs>
    projectStakeholdersTable?: boolean | projectsTable$projectStakeholdersTableArgs<ExtArgs>
    csvObjTable?: boolean | projectsTable$csvObjTableArgs<ExtArgs>
    _count?: boolean | ProjectsTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectsTable"]>

  export type projectsTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    projectName?: boolean
    projectNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    csvobjId?: boolean
    source?: boolean
    csvObjTable?: boolean | projectsTable$csvObjTableArgs<ExtArgs>
  }, ExtArgs["result"]["projectsTable"]>

  export type projectsTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    projectName?: boolean
    projectNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    csvobjId?: boolean
    source?: boolean
    csvObjTable?: boolean | projectsTable$csvObjTableArgs<ExtArgs>
  }, ExtArgs["result"]["projectsTable"]>

  export type projectsTableSelectScalar = {
    projectId?: boolean
    projectName?: boolean
    projectNotes?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    csvobjId?: boolean
    source?: boolean
  }

  export type projectsTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "projectName" | "projectNotes" | "createdAt" | "lastEditedAt" | "editedBy" | "deleted" | "csvobjId" | "source", ExtArgs["result"]["projectsTable"]>
  export type projectsTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | projectsTable$cropTableArgs<ExtArgs>
    landTable?: boolean | projectsTable$landTableArgs<ExtArgs>
    projectStakeholdersTable?: boolean | projectsTable$projectStakeholdersTableArgs<ExtArgs>
    csvObjTable?: boolean | projectsTable$csvObjTableArgs<ExtArgs>
    _count?: boolean | ProjectsTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type projectsTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | projectsTable$csvObjTableArgs<ExtArgs>
  }
  export type projectsTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csvObjTable?: boolean | projectsTable$csvObjTableArgs<ExtArgs>
  }

  export type $projectsTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projectsTable"
    objects: {
      cropTable: Prisma.$cropTablePayload<ExtArgs>[]
      landTable: Prisma.$landTablePayload<ExtArgs>[]
      projectStakeholdersTable: Prisma.$projectStakeholdersTablePayload<ExtArgs>[]
      csvObjTable: Prisma.$csvObjTablePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      projectName: string
      projectNotes: string | null
      createdAt: Date | null
      lastEditedAt: Date | null
      editedBy: string | null
      deleted: boolean | null
      csvobjId: string | null
      source: string | null
    }, ExtArgs["result"]["projectsTable"]>
    composites: {}
  }

  type projectsTableGetPayload<S extends boolean | null | undefined | projectsTableDefaultArgs> = $Result.GetResult<Prisma.$projectsTablePayload, S>

  type projectsTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectsTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectsTableCountAggregateInputType | true
    }

  export interface projectsTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projectsTable'], meta: { name: 'projectsTable' } }
    /**
     * Find zero or one ProjectsTable that matches the filter.
     * @param {projectsTableFindUniqueArgs} args - Arguments to find a ProjectsTable
     * @example
     * // Get one ProjectsTable
     * const projectsTable = await prisma.projectsTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectsTableFindUniqueArgs>(args: SelectSubset<T, projectsTableFindUniqueArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectsTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectsTableFindUniqueOrThrowArgs} args - Arguments to find a ProjectsTable
     * @example
     * // Get one ProjectsTable
     * const projectsTable = await prisma.projectsTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectsTableFindUniqueOrThrowArgs>(args: SelectSubset<T, projectsTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectsTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsTableFindFirstArgs} args - Arguments to find a ProjectsTable
     * @example
     * // Get one ProjectsTable
     * const projectsTable = await prisma.projectsTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectsTableFindFirstArgs>(args?: SelectSubset<T, projectsTableFindFirstArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectsTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsTableFindFirstOrThrowArgs} args - Arguments to find a ProjectsTable
     * @example
     * // Get one ProjectsTable
     * const projectsTable = await prisma.projectsTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectsTableFindFirstOrThrowArgs>(args?: SelectSubset<T, projectsTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectsTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectsTables
     * const projectsTables = await prisma.projectsTable.findMany()
     * 
     * // Get first 10 ProjectsTables
     * const projectsTables = await prisma.projectsTable.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectsTableWithProjectIdOnly = await prisma.projectsTable.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends projectsTableFindManyArgs>(args?: SelectSubset<T, projectsTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectsTable.
     * @param {projectsTableCreateArgs} args - Arguments to create a ProjectsTable.
     * @example
     * // Create one ProjectsTable
     * const ProjectsTable = await prisma.projectsTable.create({
     *   data: {
     *     // ... data to create a ProjectsTable
     *   }
     * })
     * 
     */
    create<T extends projectsTableCreateArgs>(args: SelectSubset<T, projectsTableCreateArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectsTables.
     * @param {projectsTableCreateManyArgs} args - Arguments to create many ProjectsTables.
     * @example
     * // Create many ProjectsTables
     * const projectsTable = await prisma.projectsTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectsTableCreateManyArgs>(args?: SelectSubset<T, projectsTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectsTables and returns the data saved in the database.
     * @param {projectsTableCreateManyAndReturnArgs} args - Arguments to create many ProjectsTables.
     * @example
     * // Create many ProjectsTables
     * const projectsTable = await prisma.projectsTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectsTables and only return the `projectId`
     * const projectsTableWithProjectIdOnly = await prisma.projectsTable.createManyAndReturn({
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectsTableCreateManyAndReturnArgs>(args?: SelectSubset<T, projectsTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectsTable.
     * @param {projectsTableDeleteArgs} args - Arguments to delete one ProjectsTable.
     * @example
     * // Delete one ProjectsTable
     * const ProjectsTable = await prisma.projectsTable.delete({
     *   where: {
     *     // ... filter to delete one ProjectsTable
     *   }
     * })
     * 
     */
    delete<T extends projectsTableDeleteArgs>(args: SelectSubset<T, projectsTableDeleteArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectsTable.
     * @param {projectsTableUpdateArgs} args - Arguments to update one ProjectsTable.
     * @example
     * // Update one ProjectsTable
     * const projectsTable = await prisma.projectsTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectsTableUpdateArgs>(args: SelectSubset<T, projectsTableUpdateArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectsTables.
     * @param {projectsTableDeleteManyArgs} args - Arguments to filter ProjectsTables to delete.
     * @example
     * // Delete a few ProjectsTables
     * const { count } = await prisma.projectsTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectsTableDeleteManyArgs>(args?: SelectSubset<T, projectsTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectsTables
     * const projectsTable = await prisma.projectsTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectsTableUpdateManyArgs>(args: SelectSubset<T, projectsTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectsTables and returns the data updated in the database.
     * @param {projectsTableUpdateManyAndReturnArgs} args - Arguments to update many ProjectsTables.
     * @example
     * // Update many ProjectsTables
     * const projectsTable = await prisma.projectsTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectsTables and only return the `projectId`
     * const projectsTableWithProjectIdOnly = await prisma.projectsTable.updateManyAndReturn({
     *   select: { projectId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projectsTableUpdateManyAndReturnArgs>(args: SelectSubset<T, projectsTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectsTable.
     * @param {projectsTableUpsertArgs} args - Arguments to update or create a ProjectsTable.
     * @example
     * // Update or create a ProjectsTable
     * const projectsTable = await prisma.projectsTable.upsert({
     *   create: {
     *     // ... data to create a ProjectsTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectsTable we want to update
     *   }
     * })
     */
    upsert<T extends projectsTableUpsertArgs>(args: SelectSubset<T, projectsTableUpsertArgs<ExtArgs>>): Prisma__projectsTableClient<$Result.GetResult<Prisma.$projectsTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsTableCountArgs} args - Arguments to filter ProjectsTables to count.
     * @example
     * // Count the number of ProjectsTables
     * const count = await prisma.projectsTable.count({
     *   where: {
     *     // ... the filter for the ProjectsTables we want to count
     *   }
     * })
    **/
    count<T extends projectsTableCountArgs>(
      args?: Subset<T, projectsTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsTableAggregateArgs>(args: Subset<T, ProjectsTableAggregateArgs>): Prisma.PrismaPromise<GetProjectsTableAggregateType<T>>

    /**
     * Group by ProjectsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectsTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectsTableGroupByArgs['orderBy'] }
        : { orderBy?: projectsTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectsTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectsTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projectsTable model
   */
  readonly fields: projectsTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projectsTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectsTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropTable<T extends projectsTable$cropTableArgs<ExtArgs> = {}>(args?: Subset<T, projectsTable$cropTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    landTable<T extends projectsTable$landTableArgs<ExtArgs> = {}>(args?: Subset<T, projectsTable$landTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectStakeholdersTable<T extends projectsTable$projectStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, projectsTable$projectStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    csvObjTable<T extends projectsTable$csvObjTableArgs<ExtArgs> = {}>(args?: Subset<T, projectsTable$csvObjTableArgs<ExtArgs>>): Prisma__csvObjTableClient<$Result.GetResult<Prisma.$csvObjTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projectsTable model
   */
  interface projectsTableFieldRefs {
    readonly projectId: FieldRef<"projectsTable", 'String'>
    readonly projectName: FieldRef<"projectsTable", 'String'>
    readonly projectNotes: FieldRef<"projectsTable", 'String'>
    readonly createdAt: FieldRef<"projectsTable", 'DateTime'>
    readonly lastEditedAt: FieldRef<"projectsTable", 'DateTime'>
    readonly editedBy: FieldRef<"projectsTable", 'String'>
    readonly deleted: FieldRef<"projectsTable", 'Boolean'>
    readonly csvobjId: FieldRef<"projectsTable", 'String'>
    readonly source: FieldRef<"projectsTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * projectsTable findUnique
   */
  export type projectsTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * Filter, which projectsTable to fetch.
     */
    where: projectsTableWhereUniqueInput
  }

  /**
   * projectsTable findUniqueOrThrow
   */
  export type projectsTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * Filter, which projectsTable to fetch.
     */
    where: projectsTableWhereUniqueInput
  }

  /**
   * projectsTable findFirst
   */
  export type projectsTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * Filter, which projectsTable to fetch.
     */
    where?: projectsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectsTables to fetch.
     */
    orderBy?: projectsTableOrderByWithRelationInput | projectsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectsTables.
     */
    cursor?: projectsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectsTables.
     */
    distinct?: ProjectsTableScalarFieldEnum | ProjectsTableScalarFieldEnum[]
  }

  /**
   * projectsTable findFirstOrThrow
   */
  export type projectsTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * Filter, which projectsTable to fetch.
     */
    where?: projectsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectsTables to fetch.
     */
    orderBy?: projectsTableOrderByWithRelationInput | projectsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectsTables.
     */
    cursor?: projectsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectsTables.
     */
    distinct?: ProjectsTableScalarFieldEnum | ProjectsTableScalarFieldEnum[]
  }

  /**
   * projectsTable findMany
   */
  export type projectsTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * Filter, which projectsTables to fetch.
     */
    where?: projectsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectsTables to fetch.
     */
    orderBy?: projectsTableOrderByWithRelationInput | projectsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projectsTables.
     */
    cursor?: projectsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectsTables.
     */
    skip?: number
    distinct?: ProjectsTableScalarFieldEnum | ProjectsTableScalarFieldEnum[]
  }

  /**
   * projectsTable create
   */
  export type projectsTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * The data needed to create a projectsTable.
     */
    data: XOR<projectsTableCreateInput, projectsTableUncheckedCreateInput>
  }

  /**
   * projectsTable createMany
   */
  export type projectsTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projectsTables.
     */
    data: projectsTableCreateManyInput | projectsTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projectsTable createManyAndReturn
   */
  export type projectsTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * The data used to create many projectsTables.
     */
    data: projectsTableCreateManyInput | projectsTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectsTable update
   */
  export type projectsTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * The data needed to update a projectsTable.
     */
    data: XOR<projectsTableUpdateInput, projectsTableUncheckedUpdateInput>
    /**
     * Choose, which projectsTable to update.
     */
    where: projectsTableWhereUniqueInput
  }

  /**
   * projectsTable updateMany
   */
  export type projectsTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projectsTables.
     */
    data: XOR<projectsTableUpdateManyMutationInput, projectsTableUncheckedUpdateManyInput>
    /**
     * Filter which projectsTables to update
     */
    where?: projectsTableWhereInput
    /**
     * Limit how many projectsTables to update.
     */
    limit?: number
  }

  /**
   * projectsTable updateManyAndReturn
   */
  export type projectsTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * The data used to update projectsTables.
     */
    data: XOR<projectsTableUpdateManyMutationInput, projectsTableUncheckedUpdateManyInput>
    /**
     * Filter which projectsTables to update
     */
    where?: projectsTableWhereInput
    /**
     * Limit how many projectsTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projectsTable upsert
   */
  export type projectsTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * The filter to search for the projectsTable to update in case it exists.
     */
    where: projectsTableWhereUniqueInput
    /**
     * In case the projectsTable found by the `where` argument doesn't exist, create a new projectsTable with this data.
     */
    create: XOR<projectsTableCreateInput, projectsTableUncheckedCreateInput>
    /**
     * In case the projectsTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectsTableUpdateInput, projectsTableUncheckedUpdateInput>
  }

  /**
   * projectsTable delete
   */
  export type projectsTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
    /**
     * Filter which projectsTable to delete.
     */
    where: projectsTableWhereUniqueInput
  }

  /**
   * projectsTable deleteMany
   */
  export type projectsTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projectsTables to delete
     */
    where?: projectsTableWhereInput
    /**
     * Limit how many projectsTables to delete.
     */
    limit?: number
  }

  /**
   * projectsTable.cropTable
   */
  export type projectsTable$cropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    where?: cropTableWhereInput
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    cursor?: cropTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropTableScalarFieldEnum | CropTableScalarFieldEnum[]
  }

  /**
   * projectsTable.landTable
   */
  export type projectsTable$landTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landTable
     */
    select?: landTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landTable
     */
    omit?: landTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landTableInclude<ExtArgs> | null
    where?: landTableWhereInput
    orderBy?: landTableOrderByWithRelationInput | landTableOrderByWithRelationInput[]
    cursor?: landTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandTableScalarFieldEnum | LandTableScalarFieldEnum[]
  }

  /**
   * projectsTable.projectStakeholdersTable
   */
  export type projectsTable$projectStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    where?: projectStakeholdersTableWhereInput
    orderBy?: projectStakeholdersTableOrderByWithRelationInput | projectStakeholdersTableOrderByWithRelationInput[]
    cursor?: projectStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectStakeholdersTableScalarFieldEnum | ProjectStakeholdersTableScalarFieldEnum[]
  }

  /**
   * projectsTable.csvObjTable
   */
  export type projectsTable$csvObjTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the csvObjTable
     */
    select?: csvObjTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the csvObjTable
     */
    omit?: csvObjTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: csvObjTableInclude<ExtArgs> | null
    where?: csvObjTableWhereInput
  }

  /**
   * projectsTable without action
   */
  export type projectsTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectsTable
     */
    select?: projectsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectsTable
     */
    omit?: projectsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsTableInclude<ExtArgs> | null
  }


  /**
   * Model speciesTable
   */

  export type AggregateSpeciesTable = {
    _count: SpeciesTableCountAggregateOutputType | null
    _min: SpeciesTableMinAggregateOutputType | null
    _max: SpeciesTableMaxAggregateOutputType | null
  }

  export type SpeciesTableMinAggregateOutputType = {
    speciesId: string | null
    commonName: string | null
    scientificName: string | null
    type: string | null
    family: string | null
    reference: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
  }

  export type SpeciesTableMaxAggregateOutputType = {
    speciesId: string | null
    commonName: string | null
    scientificName: string | null
    type: string | null
    family: string | null
    reference: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
  }

  export type SpeciesTableCountAggregateOutputType = {
    speciesId: number
    commonName: number
    scientificName: number
    type: number
    family: number
    reference: number
    createdAt: number
    lastEditedAt: number
    editedBy: number
    deleted: number
    _all: number
  }


  export type SpeciesTableMinAggregateInputType = {
    speciesId?: true
    commonName?: true
    scientificName?: true
    type?: true
    family?: true
    reference?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
  }

  export type SpeciesTableMaxAggregateInputType = {
    speciesId?: true
    commonName?: true
    scientificName?: true
    type?: true
    family?: true
    reference?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
  }

  export type SpeciesTableCountAggregateInputType = {
    speciesId?: true
    commonName?: true
    scientificName?: true
    type?: true
    family?: true
    reference?: true
    createdAt?: true
    lastEditedAt?: true
    editedBy?: true
    deleted?: true
    _all?: true
  }

  export type SpeciesTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which speciesTable to aggregate.
     */
    where?: speciesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speciesTables to fetch.
     */
    orderBy?: speciesTableOrderByWithRelationInput | speciesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: speciesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speciesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speciesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned speciesTables
    **/
    _count?: true | SpeciesTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeciesTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeciesTableMaxAggregateInputType
  }

  export type GetSpeciesTableAggregateType<T extends SpeciesTableAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeciesTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeciesTable[P]>
      : GetScalarType<T[P], AggregateSpeciesTable[P]>
  }




  export type speciesTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: speciesTableWhereInput
    orderBy?: speciesTableOrderByWithAggregationInput | speciesTableOrderByWithAggregationInput[]
    by: SpeciesTableScalarFieldEnum[] | SpeciesTableScalarFieldEnum
    having?: speciesTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeciesTableCountAggregateInputType | true
    _min?: SpeciesTableMinAggregateInputType
    _max?: SpeciesTableMaxAggregateInputType
  }

  export type SpeciesTableGroupByOutputType = {
    speciesId: string
    commonName: string
    scientificName: string | null
    type: string | null
    family: string | null
    reference: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    editedBy: string | null
    deleted: boolean | null
    _count: SpeciesTableCountAggregateOutputType | null
    _min: SpeciesTableMinAggregateOutputType | null
    _max: SpeciesTableMaxAggregateOutputType | null
  }

  type GetSpeciesTableGroupByPayload<T extends speciesTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeciesTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeciesTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeciesTableGroupByOutputType[P]>
            : GetScalarType<T[P], SpeciesTableGroupByOutputType[P]>
        }
      >
    >


  export type speciesTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    speciesId?: boolean
    commonName?: boolean
    scientificName?: boolean
    type?: boolean
    family?: boolean
    reference?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
    cropTable?: boolean | speciesTable$cropTableArgs<ExtArgs>
    _count?: boolean | SpeciesTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speciesTable"]>

  export type speciesTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    speciesId?: boolean
    commonName?: boolean
    scientificName?: boolean
    type?: boolean
    family?: boolean
    reference?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["speciesTable"]>

  export type speciesTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    speciesId?: boolean
    commonName?: boolean
    scientificName?: boolean
    type?: boolean
    family?: boolean
    reference?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["speciesTable"]>

  export type speciesTableSelectScalar = {
    speciesId?: boolean
    commonName?: boolean
    scientificName?: boolean
    type?: boolean
    family?: boolean
    reference?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    editedBy?: boolean
    deleted?: boolean
  }

  export type speciesTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"speciesId" | "commonName" | "scientificName" | "type" | "family" | "reference" | "createdAt" | "lastEditedAt" | "editedBy" | "deleted", ExtArgs["result"]["speciesTable"]>
  export type speciesTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropTable?: boolean | speciesTable$cropTableArgs<ExtArgs>
    _count?: boolean | SpeciesTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type speciesTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type speciesTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $speciesTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "speciesTable"
    objects: {
      cropTable: Prisma.$cropTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      speciesId: string
      commonName: string
      scientificName: string | null
      type: string | null
      family: string | null
      reference: string | null
      createdAt: Date | null
      lastEditedAt: Date | null
      editedBy: string | null
      deleted: boolean | null
    }, ExtArgs["result"]["speciesTable"]>
    composites: {}
  }

  type speciesTableGetPayload<S extends boolean | null | undefined | speciesTableDefaultArgs> = $Result.GetResult<Prisma.$speciesTablePayload, S>

  type speciesTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<speciesTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeciesTableCountAggregateInputType | true
    }

  export interface speciesTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['speciesTable'], meta: { name: 'speciesTable' } }
    /**
     * Find zero or one SpeciesTable that matches the filter.
     * @param {speciesTableFindUniqueArgs} args - Arguments to find a SpeciesTable
     * @example
     * // Get one SpeciesTable
     * const speciesTable = await prisma.speciesTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends speciesTableFindUniqueArgs>(args: SelectSubset<T, speciesTableFindUniqueArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpeciesTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {speciesTableFindUniqueOrThrowArgs} args - Arguments to find a SpeciesTable
     * @example
     * // Get one SpeciesTable
     * const speciesTable = await prisma.speciesTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends speciesTableFindUniqueOrThrowArgs>(args: SelectSubset<T, speciesTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeciesTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speciesTableFindFirstArgs} args - Arguments to find a SpeciesTable
     * @example
     * // Get one SpeciesTable
     * const speciesTable = await prisma.speciesTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends speciesTableFindFirstArgs>(args?: SelectSubset<T, speciesTableFindFirstArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeciesTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speciesTableFindFirstOrThrowArgs} args - Arguments to find a SpeciesTable
     * @example
     * // Get one SpeciesTable
     * const speciesTable = await prisma.speciesTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends speciesTableFindFirstOrThrowArgs>(args?: SelectSubset<T, speciesTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpeciesTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speciesTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeciesTables
     * const speciesTables = await prisma.speciesTable.findMany()
     * 
     * // Get first 10 SpeciesTables
     * const speciesTables = await prisma.speciesTable.findMany({ take: 10 })
     * 
     * // Only select the `speciesId`
     * const speciesTableWithSpeciesIdOnly = await prisma.speciesTable.findMany({ select: { speciesId: true } })
     * 
     */
    findMany<T extends speciesTableFindManyArgs>(args?: SelectSubset<T, speciesTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpeciesTable.
     * @param {speciesTableCreateArgs} args - Arguments to create a SpeciesTable.
     * @example
     * // Create one SpeciesTable
     * const SpeciesTable = await prisma.speciesTable.create({
     *   data: {
     *     // ... data to create a SpeciesTable
     *   }
     * })
     * 
     */
    create<T extends speciesTableCreateArgs>(args: SelectSubset<T, speciesTableCreateArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpeciesTables.
     * @param {speciesTableCreateManyArgs} args - Arguments to create many SpeciesTables.
     * @example
     * // Create many SpeciesTables
     * const speciesTable = await prisma.speciesTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends speciesTableCreateManyArgs>(args?: SelectSubset<T, speciesTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeciesTables and returns the data saved in the database.
     * @param {speciesTableCreateManyAndReturnArgs} args - Arguments to create many SpeciesTables.
     * @example
     * // Create many SpeciesTables
     * const speciesTable = await prisma.speciesTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeciesTables and only return the `speciesId`
     * const speciesTableWithSpeciesIdOnly = await prisma.speciesTable.createManyAndReturn({
     *   select: { speciesId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends speciesTableCreateManyAndReturnArgs>(args?: SelectSubset<T, speciesTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpeciesTable.
     * @param {speciesTableDeleteArgs} args - Arguments to delete one SpeciesTable.
     * @example
     * // Delete one SpeciesTable
     * const SpeciesTable = await prisma.speciesTable.delete({
     *   where: {
     *     // ... filter to delete one SpeciesTable
     *   }
     * })
     * 
     */
    delete<T extends speciesTableDeleteArgs>(args: SelectSubset<T, speciesTableDeleteArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpeciesTable.
     * @param {speciesTableUpdateArgs} args - Arguments to update one SpeciesTable.
     * @example
     * // Update one SpeciesTable
     * const speciesTable = await prisma.speciesTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends speciesTableUpdateArgs>(args: SelectSubset<T, speciesTableUpdateArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpeciesTables.
     * @param {speciesTableDeleteManyArgs} args - Arguments to filter SpeciesTables to delete.
     * @example
     * // Delete a few SpeciesTables
     * const { count } = await prisma.speciesTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends speciesTableDeleteManyArgs>(args?: SelectSubset<T, speciesTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeciesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speciesTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeciesTables
     * const speciesTable = await prisma.speciesTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends speciesTableUpdateManyArgs>(args: SelectSubset<T, speciesTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeciesTables and returns the data updated in the database.
     * @param {speciesTableUpdateManyAndReturnArgs} args - Arguments to update many SpeciesTables.
     * @example
     * // Update many SpeciesTables
     * const speciesTable = await prisma.speciesTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpeciesTables and only return the `speciesId`
     * const speciesTableWithSpeciesIdOnly = await prisma.speciesTable.updateManyAndReturn({
     *   select: { speciesId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends speciesTableUpdateManyAndReturnArgs>(args: SelectSubset<T, speciesTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpeciesTable.
     * @param {speciesTableUpsertArgs} args - Arguments to update or create a SpeciesTable.
     * @example
     * // Update or create a SpeciesTable
     * const speciesTable = await prisma.speciesTable.upsert({
     *   create: {
     *     // ... data to create a SpeciesTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeciesTable we want to update
     *   }
     * })
     */
    upsert<T extends speciesTableUpsertArgs>(args: SelectSubset<T, speciesTableUpsertArgs<ExtArgs>>): Prisma__speciesTableClient<$Result.GetResult<Prisma.$speciesTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpeciesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speciesTableCountArgs} args - Arguments to filter SpeciesTables to count.
     * @example
     * // Count the number of SpeciesTables
     * const count = await prisma.speciesTable.count({
     *   where: {
     *     // ... the filter for the SpeciesTables we want to count
     *   }
     * })
    **/
    count<T extends speciesTableCountArgs>(
      args?: Subset<T, speciesTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeciesTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeciesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeciesTableAggregateArgs>(args: Subset<T, SpeciesTableAggregateArgs>): Prisma.PrismaPromise<GetSpeciesTableAggregateType<T>>

    /**
     * Group by SpeciesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speciesTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends speciesTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: speciesTableGroupByArgs['orderBy'] }
        : { orderBy?: speciesTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, speciesTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeciesTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the speciesTable model
   */
  readonly fields: speciesTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for speciesTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__speciesTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropTable<T extends speciesTable$cropTableArgs<ExtArgs> = {}>(args?: Subset<T, speciesTable$cropTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the speciesTable model
   */
  interface speciesTableFieldRefs {
    readonly speciesId: FieldRef<"speciesTable", 'String'>
    readonly commonName: FieldRef<"speciesTable", 'String'>
    readonly scientificName: FieldRef<"speciesTable", 'String'>
    readonly type: FieldRef<"speciesTable", 'String'>
    readonly family: FieldRef<"speciesTable", 'String'>
    readonly reference: FieldRef<"speciesTable", 'String'>
    readonly createdAt: FieldRef<"speciesTable", 'DateTime'>
    readonly lastEditedAt: FieldRef<"speciesTable", 'DateTime'>
    readonly editedBy: FieldRef<"speciesTable", 'String'>
    readonly deleted: FieldRef<"speciesTable", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * speciesTable findUnique
   */
  export type speciesTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * Filter, which speciesTable to fetch.
     */
    where: speciesTableWhereUniqueInput
  }

  /**
   * speciesTable findUniqueOrThrow
   */
  export type speciesTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * Filter, which speciesTable to fetch.
     */
    where: speciesTableWhereUniqueInput
  }

  /**
   * speciesTable findFirst
   */
  export type speciesTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * Filter, which speciesTable to fetch.
     */
    where?: speciesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speciesTables to fetch.
     */
    orderBy?: speciesTableOrderByWithRelationInput | speciesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for speciesTables.
     */
    cursor?: speciesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speciesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speciesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of speciesTables.
     */
    distinct?: SpeciesTableScalarFieldEnum | SpeciesTableScalarFieldEnum[]
  }

  /**
   * speciesTable findFirstOrThrow
   */
  export type speciesTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * Filter, which speciesTable to fetch.
     */
    where?: speciesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speciesTables to fetch.
     */
    orderBy?: speciesTableOrderByWithRelationInput | speciesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for speciesTables.
     */
    cursor?: speciesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speciesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speciesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of speciesTables.
     */
    distinct?: SpeciesTableScalarFieldEnum | SpeciesTableScalarFieldEnum[]
  }

  /**
   * speciesTable findMany
   */
  export type speciesTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * Filter, which speciesTables to fetch.
     */
    where?: speciesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speciesTables to fetch.
     */
    orderBy?: speciesTableOrderByWithRelationInput | speciesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing speciesTables.
     */
    cursor?: speciesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speciesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speciesTables.
     */
    skip?: number
    distinct?: SpeciesTableScalarFieldEnum | SpeciesTableScalarFieldEnum[]
  }

  /**
   * speciesTable create
   */
  export type speciesTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * The data needed to create a speciesTable.
     */
    data: XOR<speciesTableCreateInput, speciesTableUncheckedCreateInput>
  }

  /**
   * speciesTable createMany
   */
  export type speciesTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many speciesTables.
     */
    data: speciesTableCreateManyInput | speciesTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * speciesTable createManyAndReturn
   */
  export type speciesTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * The data used to create many speciesTables.
     */
    data: speciesTableCreateManyInput | speciesTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * speciesTable update
   */
  export type speciesTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * The data needed to update a speciesTable.
     */
    data: XOR<speciesTableUpdateInput, speciesTableUncheckedUpdateInput>
    /**
     * Choose, which speciesTable to update.
     */
    where: speciesTableWhereUniqueInput
  }

  /**
   * speciesTable updateMany
   */
  export type speciesTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update speciesTables.
     */
    data: XOR<speciesTableUpdateManyMutationInput, speciesTableUncheckedUpdateManyInput>
    /**
     * Filter which speciesTables to update
     */
    where?: speciesTableWhereInput
    /**
     * Limit how many speciesTables to update.
     */
    limit?: number
  }

  /**
   * speciesTable updateManyAndReturn
   */
  export type speciesTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * The data used to update speciesTables.
     */
    data: XOR<speciesTableUpdateManyMutationInput, speciesTableUncheckedUpdateManyInput>
    /**
     * Filter which speciesTables to update
     */
    where?: speciesTableWhereInput
    /**
     * Limit how many speciesTables to update.
     */
    limit?: number
  }

  /**
   * speciesTable upsert
   */
  export type speciesTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * The filter to search for the speciesTable to update in case it exists.
     */
    where: speciesTableWhereUniqueInput
    /**
     * In case the speciesTable found by the `where` argument doesn't exist, create a new speciesTable with this data.
     */
    create: XOR<speciesTableCreateInput, speciesTableUncheckedCreateInput>
    /**
     * In case the speciesTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<speciesTableUpdateInput, speciesTableUncheckedUpdateInput>
  }

  /**
   * speciesTable delete
   */
  export type speciesTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
    /**
     * Filter which speciesTable to delete.
     */
    where: speciesTableWhereUniqueInput
  }

  /**
   * speciesTable deleteMany
   */
  export type speciesTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which speciesTables to delete
     */
    where?: speciesTableWhereInput
    /**
     * Limit how many speciesTables to delete.
     */
    limit?: number
  }

  /**
   * speciesTable.cropTable
   */
  export type speciesTable$cropTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropTable
     */
    select?: cropTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropTable
     */
    omit?: cropTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropTableInclude<ExtArgs> | null
    where?: cropTableWhereInput
    orderBy?: cropTableOrderByWithRelationInput | cropTableOrderByWithRelationInput[]
    cursor?: cropTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropTableScalarFieldEnum | CropTableScalarFieldEnum[]
  }

  /**
   * speciesTable without action
   */
  export type speciesTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speciesTable
     */
    select?: speciesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speciesTable
     */
    omit?: speciesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: speciesTableInclude<ExtArgs> | null
  }


  /**
   * Model stakeholderTypesTable
   */

  export type AggregateStakeholderTypesTable = {
    _count: StakeholderTypesTableCountAggregateOutputType | null
    _min: StakeholderTypesTableMinAggregateOutputType | null
    _max: StakeholderTypesTableMaxAggregateOutputType | null
  }

  export type StakeholderTypesTableMinAggregateOutputType = {
    stakeholderType: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    deleted: boolean | null
    stakeholderTypeId: string | null
  }

  export type StakeholderTypesTableMaxAggregateOutputType = {
    stakeholderType: string | null
    createdAt: Date | null
    lastEditedAt: Date | null
    deleted: boolean | null
    stakeholderTypeId: string | null
  }

  export type StakeholderTypesTableCountAggregateOutputType = {
    stakeholderType: number
    createdAt: number
    lastEditedAt: number
    deleted: number
    stakeholderTypeId: number
    _all: number
  }


  export type StakeholderTypesTableMinAggregateInputType = {
    stakeholderType?: true
    createdAt?: true
    lastEditedAt?: true
    deleted?: true
    stakeholderTypeId?: true
  }

  export type StakeholderTypesTableMaxAggregateInputType = {
    stakeholderType?: true
    createdAt?: true
    lastEditedAt?: true
    deleted?: true
    stakeholderTypeId?: true
  }

  export type StakeholderTypesTableCountAggregateInputType = {
    stakeholderType?: true
    createdAt?: true
    lastEditedAt?: true
    deleted?: true
    stakeholderTypeId?: true
    _all?: true
  }

  export type StakeholderTypesTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stakeholderTypesTable to aggregate.
     */
    where?: stakeholderTypesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderTypesTables to fetch.
     */
    orderBy?: stakeholderTypesTableOrderByWithRelationInput | stakeholderTypesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stakeholderTypesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderTypesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderTypesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stakeholderTypesTables
    **/
    _count?: true | StakeholderTypesTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StakeholderTypesTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StakeholderTypesTableMaxAggregateInputType
  }

  export type GetStakeholderTypesTableAggregateType<T extends StakeholderTypesTableAggregateArgs> = {
        [P in keyof T & keyof AggregateStakeholderTypesTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStakeholderTypesTable[P]>
      : GetScalarType<T[P], AggregateStakeholderTypesTable[P]>
  }




  export type stakeholderTypesTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stakeholderTypesTableWhereInput
    orderBy?: stakeholderTypesTableOrderByWithAggregationInput | stakeholderTypesTableOrderByWithAggregationInput[]
    by: StakeholderTypesTableScalarFieldEnum[] | StakeholderTypesTableScalarFieldEnum
    having?: stakeholderTypesTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StakeholderTypesTableCountAggregateInputType | true
    _min?: StakeholderTypesTableMinAggregateInputType
    _max?: StakeholderTypesTableMaxAggregateInputType
  }

  export type StakeholderTypesTableGroupByOutputType = {
    stakeholderType: string
    createdAt: Date | null
    lastEditedAt: Date | null
    deleted: boolean | null
    stakeholderTypeId: string
    _count: StakeholderTypesTableCountAggregateOutputType | null
    _min: StakeholderTypesTableMinAggregateOutputType | null
    _max: StakeholderTypesTableMaxAggregateOutputType | null
  }

  type GetStakeholderTypesTableGroupByPayload<T extends stakeholderTypesTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StakeholderTypesTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StakeholderTypesTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StakeholderTypesTableGroupByOutputType[P]>
            : GetScalarType<T[P], StakeholderTypesTableGroupByOutputType[P]>
        }
      >
    >


  export type stakeholderTypesTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stakeholderType?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    stakeholderTypeId?: boolean
    cropStakeholdersTable?: boolean | stakeholderTypesTable$cropStakeholdersTableArgs<ExtArgs>
    landStakeholdersTable?: boolean | stakeholderTypesTable$landStakeholdersTableArgs<ExtArgs>
    organizationsTable?: boolean | stakeholderTypesTable$organizationsTableArgs<ExtArgs>
    projectStakeholdersTable?: boolean | stakeholderTypesTable$projectStakeholdersTableArgs<ExtArgs>
    _count?: boolean | StakeholderTypesTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stakeholderTypesTable"]>

  export type stakeholderTypesTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stakeholderType?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    stakeholderTypeId?: boolean
  }, ExtArgs["result"]["stakeholderTypesTable"]>

  export type stakeholderTypesTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stakeholderType?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    stakeholderTypeId?: boolean
  }, ExtArgs["result"]["stakeholderTypesTable"]>

  export type stakeholderTypesTableSelectScalar = {
    stakeholderType?: boolean
    createdAt?: boolean
    lastEditedAt?: boolean
    deleted?: boolean
    stakeholderTypeId?: boolean
  }

  export type stakeholderTypesTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stakeholderType" | "createdAt" | "lastEditedAt" | "deleted" | "stakeholderTypeId", ExtArgs["result"]["stakeholderTypesTable"]>
  export type stakeholderTypesTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cropStakeholdersTable?: boolean | stakeholderTypesTable$cropStakeholdersTableArgs<ExtArgs>
    landStakeholdersTable?: boolean | stakeholderTypesTable$landStakeholdersTableArgs<ExtArgs>
    organizationsTable?: boolean | stakeholderTypesTable$organizationsTableArgs<ExtArgs>
    projectStakeholdersTable?: boolean | stakeholderTypesTable$projectStakeholdersTableArgs<ExtArgs>
    _count?: boolean | StakeholderTypesTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type stakeholderTypesTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type stakeholderTypesTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $stakeholderTypesTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stakeholderTypesTable"
    objects: {
      cropStakeholdersTable: Prisma.$cropStakeholdersTablePayload<ExtArgs>[]
      landStakeholdersTable: Prisma.$landStakeholdersTablePayload<ExtArgs>[]
      organizationsTable: Prisma.$organizationsTablePayload<ExtArgs>[]
      projectStakeholdersTable: Prisma.$projectStakeholdersTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      stakeholderType: string
      createdAt: Date | null
      lastEditedAt: Date | null
      deleted: boolean | null
      stakeholderTypeId: string
    }, ExtArgs["result"]["stakeholderTypesTable"]>
    composites: {}
  }

  type stakeholderTypesTableGetPayload<S extends boolean | null | undefined | stakeholderTypesTableDefaultArgs> = $Result.GetResult<Prisma.$stakeholderTypesTablePayload, S>

  type stakeholderTypesTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stakeholderTypesTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StakeholderTypesTableCountAggregateInputType | true
    }

  export interface stakeholderTypesTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stakeholderTypesTable'], meta: { name: 'stakeholderTypesTable' } }
    /**
     * Find zero or one StakeholderTypesTable that matches the filter.
     * @param {stakeholderTypesTableFindUniqueArgs} args - Arguments to find a StakeholderTypesTable
     * @example
     * // Get one StakeholderTypesTable
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stakeholderTypesTableFindUniqueArgs>(args: SelectSubset<T, stakeholderTypesTableFindUniqueArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StakeholderTypesTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stakeholderTypesTableFindUniqueOrThrowArgs} args - Arguments to find a StakeholderTypesTable
     * @example
     * // Get one StakeholderTypesTable
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stakeholderTypesTableFindUniqueOrThrowArgs>(args: SelectSubset<T, stakeholderTypesTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderTypesTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderTypesTableFindFirstArgs} args - Arguments to find a StakeholderTypesTable
     * @example
     * // Get one StakeholderTypesTable
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stakeholderTypesTableFindFirstArgs>(args?: SelectSubset<T, stakeholderTypesTableFindFirstArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StakeholderTypesTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderTypesTableFindFirstOrThrowArgs} args - Arguments to find a StakeholderTypesTable
     * @example
     * // Get one StakeholderTypesTable
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stakeholderTypesTableFindFirstOrThrowArgs>(args?: SelectSubset<T, stakeholderTypesTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StakeholderTypesTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderTypesTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StakeholderTypesTables
     * const stakeholderTypesTables = await prisma.stakeholderTypesTable.findMany()
     * 
     * // Get first 10 StakeholderTypesTables
     * const stakeholderTypesTables = await prisma.stakeholderTypesTable.findMany({ take: 10 })
     * 
     * // Only select the `stakeholderType`
     * const stakeholderTypesTableWithStakeholderTypeOnly = await prisma.stakeholderTypesTable.findMany({ select: { stakeholderType: true } })
     * 
     */
    findMany<T extends stakeholderTypesTableFindManyArgs>(args?: SelectSubset<T, stakeholderTypesTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StakeholderTypesTable.
     * @param {stakeholderTypesTableCreateArgs} args - Arguments to create a StakeholderTypesTable.
     * @example
     * // Create one StakeholderTypesTable
     * const StakeholderTypesTable = await prisma.stakeholderTypesTable.create({
     *   data: {
     *     // ... data to create a StakeholderTypesTable
     *   }
     * })
     * 
     */
    create<T extends stakeholderTypesTableCreateArgs>(args: SelectSubset<T, stakeholderTypesTableCreateArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StakeholderTypesTables.
     * @param {stakeholderTypesTableCreateManyArgs} args - Arguments to create many StakeholderTypesTables.
     * @example
     * // Create many StakeholderTypesTables
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stakeholderTypesTableCreateManyArgs>(args?: SelectSubset<T, stakeholderTypesTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StakeholderTypesTables and returns the data saved in the database.
     * @param {stakeholderTypesTableCreateManyAndReturnArgs} args - Arguments to create many StakeholderTypesTables.
     * @example
     * // Create many StakeholderTypesTables
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StakeholderTypesTables and only return the `stakeholderType`
     * const stakeholderTypesTableWithStakeholderTypeOnly = await prisma.stakeholderTypesTable.createManyAndReturn({
     *   select: { stakeholderType: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends stakeholderTypesTableCreateManyAndReturnArgs>(args?: SelectSubset<T, stakeholderTypesTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StakeholderTypesTable.
     * @param {stakeholderTypesTableDeleteArgs} args - Arguments to delete one StakeholderTypesTable.
     * @example
     * // Delete one StakeholderTypesTable
     * const StakeholderTypesTable = await prisma.stakeholderTypesTable.delete({
     *   where: {
     *     // ... filter to delete one StakeholderTypesTable
     *   }
     * })
     * 
     */
    delete<T extends stakeholderTypesTableDeleteArgs>(args: SelectSubset<T, stakeholderTypesTableDeleteArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StakeholderTypesTable.
     * @param {stakeholderTypesTableUpdateArgs} args - Arguments to update one StakeholderTypesTable.
     * @example
     * // Update one StakeholderTypesTable
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stakeholderTypesTableUpdateArgs>(args: SelectSubset<T, stakeholderTypesTableUpdateArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StakeholderTypesTables.
     * @param {stakeholderTypesTableDeleteManyArgs} args - Arguments to filter StakeholderTypesTables to delete.
     * @example
     * // Delete a few StakeholderTypesTables
     * const { count } = await prisma.stakeholderTypesTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stakeholderTypesTableDeleteManyArgs>(args?: SelectSubset<T, stakeholderTypesTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakeholderTypesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderTypesTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StakeholderTypesTables
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stakeholderTypesTableUpdateManyArgs>(args: SelectSubset<T, stakeholderTypesTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StakeholderTypesTables and returns the data updated in the database.
     * @param {stakeholderTypesTableUpdateManyAndReturnArgs} args - Arguments to update many StakeholderTypesTables.
     * @example
     * // Update many StakeholderTypesTables
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StakeholderTypesTables and only return the `stakeholderType`
     * const stakeholderTypesTableWithStakeholderTypeOnly = await prisma.stakeholderTypesTable.updateManyAndReturn({
     *   select: { stakeholderType: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends stakeholderTypesTableUpdateManyAndReturnArgs>(args: SelectSubset<T, stakeholderTypesTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StakeholderTypesTable.
     * @param {stakeholderTypesTableUpsertArgs} args - Arguments to update or create a StakeholderTypesTable.
     * @example
     * // Update or create a StakeholderTypesTable
     * const stakeholderTypesTable = await prisma.stakeholderTypesTable.upsert({
     *   create: {
     *     // ... data to create a StakeholderTypesTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StakeholderTypesTable we want to update
     *   }
     * })
     */
    upsert<T extends stakeholderTypesTableUpsertArgs>(args: SelectSubset<T, stakeholderTypesTableUpsertArgs<ExtArgs>>): Prisma__stakeholderTypesTableClient<$Result.GetResult<Prisma.$stakeholderTypesTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StakeholderTypesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderTypesTableCountArgs} args - Arguments to filter StakeholderTypesTables to count.
     * @example
     * // Count the number of StakeholderTypesTables
     * const count = await prisma.stakeholderTypesTable.count({
     *   where: {
     *     // ... the filter for the StakeholderTypesTables we want to count
     *   }
     * })
    **/
    count<T extends stakeholderTypesTableCountArgs>(
      args?: Subset<T, stakeholderTypesTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StakeholderTypesTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StakeholderTypesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StakeholderTypesTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StakeholderTypesTableAggregateArgs>(args: Subset<T, StakeholderTypesTableAggregateArgs>): Prisma.PrismaPromise<GetStakeholderTypesTableAggregateType<T>>

    /**
     * Group by StakeholderTypesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stakeholderTypesTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stakeholderTypesTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stakeholderTypesTableGroupByArgs['orderBy'] }
        : { orderBy?: stakeholderTypesTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stakeholderTypesTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStakeholderTypesTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stakeholderTypesTable model
   */
  readonly fields: stakeholderTypesTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stakeholderTypesTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stakeholderTypesTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cropStakeholdersTable<T extends stakeholderTypesTable$cropStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderTypesTable$cropStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cropStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    landStakeholdersTable<T extends stakeholderTypesTable$landStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderTypesTable$landStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizationsTable<T extends stakeholderTypesTable$organizationsTableArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderTypesTable$organizationsTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectStakeholdersTable<T extends stakeholderTypesTable$projectStakeholdersTableArgs<ExtArgs> = {}>(args?: Subset<T, stakeholderTypesTable$projectStakeholdersTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectStakeholdersTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stakeholderTypesTable model
   */
  interface stakeholderTypesTableFieldRefs {
    readonly stakeholderType: FieldRef<"stakeholderTypesTable", 'String'>
    readonly createdAt: FieldRef<"stakeholderTypesTable", 'DateTime'>
    readonly lastEditedAt: FieldRef<"stakeholderTypesTable", 'DateTime'>
    readonly deleted: FieldRef<"stakeholderTypesTable", 'Boolean'>
    readonly stakeholderTypeId: FieldRef<"stakeholderTypesTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * stakeholderTypesTable findUnique
   */
  export type stakeholderTypesTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderTypesTable to fetch.
     */
    where: stakeholderTypesTableWhereUniqueInput
  }

  /**
   * stakeholderTypesTable findUniqueOrThrow
   */
  export type stakeholderTypesTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderTypesTable to fetch.
     */
    where: stakeholderTypesTableWhereUniqueInput
  }

  /**
   * stakeholderTypesTable findFirst
   */
  export type stakeholderTypesTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderTypesTable to fetch.
     */
    where?: stakeholderTypesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderTypesTables to fetch.
     */
    orderBy?: stakeholderTypesTableOrderByWithRelationInput | stakeholderTypesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stakeholderTypesTables.
     */
    cursor?: stakeholderTypesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderTypesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderTypesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stakeholderTypesTables.
     */
    distinct?: StakeholderTypesTableScalarFieldEnum | StakeholderTypesTableScalarFieldEnum[]
  }

  /**
   * stakeholderTypesTable findFirstOrThrow
   */
  export type stakeholderTypesTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderTypesTable to fetch.
     */
    where?: stakeholderTypesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderTypesTables to fetch.
     */
    orderBy?: stakeholderTypesTableOrderByWithRelationInput | stakeholderTypesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stakeholderTypesTables.
     */
    cursor?: stakeholderTypesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderTypesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderTypesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stakeholderTypesTables.
     */
    distinct?: StakeholderTypesTableScalarFieldEnum | StakeholderTypesTableScalarFieldEnum[]
  }

  /**
   * stakeholderTypesTable findMany
   */
  export type stakeholderTypesTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * Filter, which stakeholderTypesTables to fetch.
     */
    where?: stakeholderTypesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stakeholderTypesTables to fetch.
     */
    orderBy?: stakeholderTypesTableOrderByWithRelationInput | stakeholderTypesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stakeholderTypesTables.
     */
    cursor?: stakeholderTypesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stakeholderTypesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stakeholderTypesTables.
     */
    skip?: number
    distinct?: StakeholderTypesTableScalarFieldEnum | StakeholderTypesTableScalarFieldEnum[]
  }

  /**
   * stakeholderTypesTable create
   */
  export type stakeholderTypesTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * The data needed to create a stakeholderTypesTable.
     */
    data: XOR<stakeholderTypesTableCreateInput, stakeholderTypesTableUncheckedCreateInput>
  }

  /**
   * stakeholderTypesTable createMany
   */
  export type stakeholderTypesTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stakeholderTypesTables.
     */
    data: stakeholderTypesTableCreateManyInput | stakeholderTypesTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stakeholderTypesTable createManyAndReturn
   */
  export type stakeholderTypesTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * The data used to create many stakeholderTypesTables.
     */
    data: stakeholderTypesTableCreateManyInput | stakeholderTypesTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stakeholderTypesTable update
   */
  export type stakeholderTypesTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * The data needed to update a stakeholderTypesTable.
     */
    data: XOR<stakeholderTypesTableUpdateInput, stakeholderTypesTableUncheckedUpdateInput>
    /**
     * Choose, which stakeholderTypesTable to update.
     */
    where: stakeholderTypesTableWhereUniqueInput
  }

  /**
   * stakeholderTypesTable updateMany
   */
  export type stakeholderTypesTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stakeholderTypesTables.
     */
    data: XOR<stakeholderTypesTableUpdateManyMutationInput, stakeholderTypesTableUncheckedUpdateManyInput>
    /**
     * Filter which stakeholderTypesTables to update
     */
    where?: stakeholderTypesTableWhereInput
    /**
     * Limit how many stakeholderTypesTables to update.
     */
    limit?: number
  }

  /**
   * stakeholderTypesTable updateManyAndReturn
   */
  export type stakeholderTypesTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * The data used to update stakeholderTypesTables.
     */
    data: XOR<stakeholderTypesTableUpdateManyMutationInput, stakeholderTypesTableUncheckedUpdateManyInput>
    /**
     * Filter which stakeholderTypesTables to update
     */
    where?: stakeholderTypesTableWhereInput
    /**
     * Limit how many stakeholderTypesTables to update.
     */
    limit?: number
  }

  /**
   * stakeholderTypesTable upsert
   */
  export type stakeholderTypesTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * The filter to search for the stakeholderTypesTable to update in case it exists.
     */
    where: stakeholderTypesTableWhereUniqueInput
    /**
     * In case the stakeholderTypesTable found by the `where` argument doesn't exist, create a new stakeholderTypesTable with this data.
     */
    create: XOR<stakeholderTypesTableCreateInput, stakeholderTypesTableUncheckedCreateInput>
    /**
     * In case the stakeholderTypesTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stakeholderTypesTableUpdateInput, stakeholderTypesTableUncheckedUpdateInput>
  }

  /**
   * stakeholderTypesTable delete
   */
  export type stakeholderTypesTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
    /**
     * Filter which stakeholderTypesTable to delete.
     */
    where: stakeholderTypesTableWhereUniqueInput
  }

  /**
   * stakeholderTypesTable deleteMany
   */
  export type stakeholderTypesTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stakeholderTypesTables to delete
     */
    where?: stakeholderTypesTableWhereInput
    /**
     * Limit how many stakeholderTypesTables to delete.
     */
    limit?: number
  }

  /**
   * stakeholderTypesTable.cropStakeholdersTable
   */
  export type stakeholderTypesTable$cropStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cropStakeholdersTable
     */
    select?: cropStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cropStakeholdersTable
     */
    omit?: cropStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cropStakeholdersTableInclude<ExtArgs> | null
    where?: cropStakeholdersTableWhereInput
    orderBy?: cropStakeholdersTableOrderByWithRelationInput | cropStakeholdersTableOrderByWithRelationInput[]
    cursor?: cropStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropStakeholdersTableScalarFieldEnum | CropStakeholdersTableScalarFieldEnum[]
  }

  /**
   * stakeholderTypesTable.landStakeholdersTable
   */
  export type stakeholderTypesTable$landStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landStakeholdersTable
     */
    select?: landStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landStakeholdersTable
     */
    omit?: landStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landStakeholdersTableInclude<ExtArgs> | null
    where?: landStakeholdersTableWhereInput
    orderBy?: landStakeholdersTableOrderByWithRelationInput | landStakeholdersTableOrderByWithRelationInput[]
    cursor?: landStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandStakeholdersTableScalarFieldEnum | LandStakeholdersTableScalarFieldEnum[]
  }

  /**
   * stakeholderTypesTable.organizationsTable
   */
  export type stakeholderTypesTable$organizationsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizationsTable
     */
    select?: organizationsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizationsTable
     */
    omit?: organizationsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsTableInclude<ExtArgs> | null
    where?: organizationsTableWhereInput
    orderBy?: organizationsTableOrderByWithRelationInput | organizationsTableOrderByWithRelationInput[]
    cursor?: organizationsTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationsTableScalarFieldEnum | OrganizationsTableScalarFieldEnum[]
  }

  /**
   * stakeholderTypesTable.projectStakeholdersTable
   */
  export type stakeholderTypesTable$projectStakeholdersTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projectStakeholdersTable
     */
    select?: projectStakeholdersTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projectStakeholdersTable
     */
    omit?: projectStakeholdersTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectStakeholdersTableInclude<ExtArgs> | null
    where?: projectStakeholdersTableWhereInput
    orderBy?: projectStakeholdersTableOrderByWithRelationInput | projectStakeholdersTableOrderByWithRelationInput[]
    cursor?: projectStakeholdersTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectStakeholdersTableScalarFieldEnum | ProjectStakeholdersTableScalarFieldEnum[]
  }

  /**
   * stakeholderTypesTable without action
   */
  export type stakeholderTypesTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stakeholderTypesTable
     */
    select?: stakeholderTypesTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stakeholderTypesTable
     */
    omit?: stakeholderTypesTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stakeholderTypesTableInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Audit_log_entriesScalarFieldEnum: {
    instance_id: 'instance_id',
    id: 'id',
    payload: 'payload',
    created_at: 'created_at',
    ip_address: 'ip_address'
  };

  export type Audit_log_entriesScalarFieldEnum = (typeof Audit_log_entriesScalarFieldEnum)[keyof typeof Audit_log_entriesScalarFieldEnum]


  export const Flow_stateScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    auth_code: 'auth_code',
    code_challenge_method: 'code_challenge_method',
    code_challenge: 'code_challenge',
    provider_type: 'provider_type',
    provider_access_token: 'provider_access_token',
    provider_refresh_token: 'provider_refresh_token',
    created_at: 'created_at',
    updated_at: 'updated_at',
    authentication_method: 'authentication_method',
    auth_code_issued_at: 'auth_code_issued_at'
  };

  export type Flow_stateScalarFieldEnum = (typeof Flow_stateScalarFieldEnum)[keyof typeof Flow_stateScalarFieldEnum]


  export const IdentitiesScalarFieldEnum: {
    provider_id: 'provider_id',
    user_id: 'user_id',
    identity_data: 'identity_data',
    provider: 'provider',
    last_sign_in_at: 'last_sign_in_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    email: 'email',
    id: 'id'
  };

  export type IdentitiesScalarFieldEnum = (typeof IdentitiesScalarFieldEnum)[keyof typeof IdentitiesScalarFieldEnum]


  export const InstancesScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    raw_base_config: 'raw_base_config',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InstancesScalarFieldEnum = (typeof InstancesScalarFieldEnum)[keyof typeof InstancesScalarFieldEnum]


  export const Mfa_amr_claimsScalarFieldEnum: {
    session_id: 'session_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    authentication_method: 'authentication_method',
    id: 'id'
  };

  export type Mfa_amr_claimsScalarFieldEnum = (typeof Mfa_amr_claimsScalarFieldEnum)[keyof typeof Mfa_amr_claimsScalarFieldEnum]


  export const Mfa_challengesScalarFieldEnum: {
    id: 'id',
    factor_id: 'factor_id',
    created_at: 'created_at',
    verified_at: 'verified_at',
    ip_address: 'ip_address',
    otp_code: 'otp_code',
    web_authn_session_data: 'web_authn_session_data'
  };

  export type Mfa_challengesScalarFieldEnum = (typeof Mfa_challengesScalarFieldEnum)[keyof typeof Mfa_challengesScalarFieldEnum]


  export const Mfa_factorsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    friendly_name: 'friendly_name',
    factor_type: 'factor_type',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    secret: 'secret',
    phone: 'phone',
    last_challenged_at: 'last_challenged_at',
    web_authn_credential: 'web_authn_credential',
    web_authn_aaguid: 'web_authn_aaguid'
  };

  export type Mfa_factorsScalarFieldEnum = (typeof Mfa_factorsScalarFieldEnum)[keyof typeof Mfa_factorsScalarFieldEnum]


  export const One_time_tokensScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token_type: 'token_type',
    token_hash: 'token_hash',
    relates_to: 'relates_to',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type One_time_tokensScalarFieldEnum = (typeof One_time_tokensScalarFieldEnum)[keyof typeof One_time_tokensScalarFieldEnum]


  export const Refresh_tokensScalarFieldEnum: {
    instance_id: 'instance_id',
    id: 'id',
    token: 'token',
    user_id: 'user_id',
    revoked: 'revoked',
    created_at: 'created_at',
    updated_at: 'updated_at',
    parent: 'parent',
    session_id: 'session_id'
  };

  export type Refresh_tokensScalarFieldEnum = (typeof Refresh_tokensScalarFieldEnum)[keyof typeof Refresh_tokensScalarFieldEnum]


  export const Saml_providersScalarFieldEnum: {
    id: 'id',
    sso_provider_id: 'sso_provider_id',
    entity_id: 'entity_id',
    metadata_xml: 'metadata_xml',
    metadata_url: 'metadata_url',
    attribute_mapping: 'attribute_mapping',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name_id_format: 'name_id_format'
  };

  export type Saml_providersScalarFieldEnum = (typeof Saml_providersScalarFieldEnum)[keyof typeof Saml_providersScalarFieldEnum]


  export const Saml_relay_statesScalarFieldEnum: {
    id: 'id',
    sso_provider_id: 'sso_provider_id',
    request_id: 'request_id',
    for_email: 'for_email',
    redirect_to: 'redirect_to',
    created_at: 'created_at',
    updated_at: 'updated_at',
    flow_state_id: 'flow_state_id'
  };

  export type Saml_relay_statesScalarFieldEnum = (typeof Saml_relay_statesScalarFieldEnum)[keyof typeof Saml_relay_statesScalarFieldEnum]


  export const Schema_migrationsScalarFieldEnum: {
    version: 'version'
  };

  export type Schema_migrationsScalarFieldEnum = (typeof Schema_migrationsScalarFieldEnum)[keyof typeof Schema_migrationsScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    factor_id: 'factor_id',
    aal: 'aal',
    not_after: 'not_after',
    refreshed_at: 'refreshed_at',
    user_agent: 'user_agent',
    ip: 'ip',
    tag: 'tag'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const Sso_domainsScalarFieldEnum: {
    id: 'id',
    sso_provider_id: 'sso_provider_id',
    domain: 'domain',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Sso_domainsScalarFieldEnum = (typeof Sso_domainsScalarFieldEnum)[keyof typeof Sso_domainsScalarFieldEnum]


  export const Sso_providersScalarFieldEnum: {
    id: 'id',
    resource_id: 'resource_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Sso_providersScalarFieldEnum = (typeof Sso_providersScalarFieldEnum)[keyof typeof Sso_providersScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    instance_id: 'instance_id',
    id: 'id',
    aud: 'aud',
    role: 'role',
    email: 'email',
    encrypted_password: 'encrypted_password',
    email_confirmed_at: 'email_confirmed_at',
    invited_at: 'invited_at',
    confirmation_token: 'confirmation_token',
    confirmation_sent_at: 'confirmation_sent_at',
    recovery_token: 'recovery_token',
    recovery_sent_at: 'recovery_sent_at',
    email_change_token_new: 'email_change_token_new',
    email_change: 'email_change',
    email_change_sent_at: 'email_change_sent_at',
    last_sign_in_at: 'last_sign_in_at',
    raw_app_meta_data: 'raw_app_meta_data',
    raw_user_meta_data: 'raw_user_meta_data',
    is_super_admin: 'is_super_admin',
    created_at: 'created_at',
    updated_at: 'updated_at',
    phone: 'phone',
    phone_confirmed_at: 'phone_confirmed_at',
    phone_change: 'phone_change',
    phone_change_token: 'phone_change_token',
    phone_change_sent_at: 'phone_change_sent_at',
    confirmed_at: 'confirmed_at',
    email_change_token_current: 'email_change_token_current',
    email_change_confirm_status: 'email_change_confirm_status',
    banned_until: 'banned_until',
    reauthentication_token: 'reauthentication_token',
    reauthentication_sent_at: 'reauthentication_sent_at',
    is_sso_user: 'is_sso_user',
    deleted_at: 'deleted_at',
    is_anonymous: 'is_anonymous'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CropStakeholdersTableScalarFieldEnum: {
    cropStakeholderId: 'cropStakeholderId',
    cropId: 'cropId',
    organizationId: 'organizationId',
    stakeholderTypeId: 'stakeholderTypeId'
  };

  export type CropStakeholdersTableScalarFieldEnum = (typeof CropStakeholdersTableScalarFieldEnum)[keyof typeof CropStakeholdersTableScalarFieldEnum]


  export const CropTableScalarFieldEnum: {
    cropId: 'cropId',
    cropName: 'cropName',
    speciesId: 'speciesId',
    seedInfo: 'seedInfo',
    cropStock: 'cropStock',
    createdAt: 'createdAt',
    lastEditedAt: 'lastEditedAt',
    editedBy: 'editedBy',
    deleted: 'deleted',
    projectId: 'projectId',
    organizationId: 'organizationId',
    cropNotes: 'cropNotes',
    csvobjId: 'csvobjId',
    speciesTemp: 'speciesTemp'
  };

  export type CropTableScalarFieldEnum = (typeof CropTableScalarFieldEnum)[keyof typeof CropTableScalarFieldEnum]


  export const CsvObjTableScalarFieldEnum: {
    csvobjId: 'csvobjId',
    jsonData: 'jsonData',
    createdAt: 'createdAt'
  };

  export type CsvObjTableScalarFieldEnum = (typeof CsvObjTableScalarFieldEnum)[keyof typeof CsvObjTableScalarFieldEnum]


  export const LandStakeholdersTableScalarFieldEnum: {
    landStakeholderId: 'landStakeholderId',
    landId: 'landId',
    organizationId: 'organizationId',
    stakeholderTypeId: 'stakeholderTypeId'
  };

  export type LandStakeholdersTableScalarFieldEnum = (typeof LandStakeholdersTableScalarFieldEnum)[keyof typeof LandStakeholdersTableScalarFieldEnum]


  export const LandTableScalarFieldEnum: {
    landId: 'landId',
    landName: 'landName',
    projectId: 'projectId',
    hectares: 'hectares',
    gpsLat: 'gpsLat',
    gpsLon: 'gpsLon',
    landNotes: 'landNotes',
    createdAt: 'createdAt',
    lastEditedAt: 'lastEditedAt',
    editedBy: 'editedBy',
    deleted: 'deleted',
    preparation: 'preparation',
    csvobjId: 'csvobjId',
    polygon: 'polygon'
  };

  export type LandTableScalarFieldEnum = (typeof LandTableScalarFieldEnum)[keyof typeof LandTableScalarFieldEnum]


  export const MetadataTableScalarFieldEnum: {
    metadataId: 'metadataId',
    csvobjId: 'csvobjId',
    csvKey: 'csvKey',
    dbKey: 'dbKey',
    createdAt: 'createdAt'
  };

  export type MetadataTableScalarFieldEnum = (typeof MetadataTableScalarFieldEnum)[keyof typeof MetadataTableScalarFieldEnum]


  export const NurseryTableScalarFieldEnum: {
    nurseryId: 'nurseryId',
    gpsLat: 'gpsLat',
    gpsLon: 'gpsLon',
    capacity: 'capacity',
    nurseryNotes: 'nurseryNotes',
    tradeName: 'tradeName',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    lastEditedAt: 'lastEditedAt'
  };

  export type NurseryTableScalarFieldEnum = (typeof NurseryTableScalarFieldEnum)[keyof typeof NurseryTableScalarFieldEnum]


  export const OrganizationsTableScalarFieldEnum: {
    organizationId: 'organizationId',
    organizationName: 'organizationName',
    contactName: 'contactName',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    website: 'website',
    organizationNotes: 'organizationNotes',
    createdAt: 'createdAt',
    lastEditedAt: 'lastEditedAt',
    editedBy: 'editedBy',
    deleted: 'deleted',
    gpsLat: 'gpsLat',
    gpsLon: 'gpsLon',
    stakeholderTypeId: 'stakeholderTypeId'
  };

  export type OrganizationsTableScalarFieldEnum = (typeof OrganizationsTableScalarFieldEnum)[keyof typeof OrganizationsTableScalarFieldEnum]


  export const PlantingTableScalarFieldEnum: {
    plantingId: 'plantingId',
    landId: 'landId',
    planted: 'planted',
    plantingDate: 'plantingDate',
    createdAt: 'createdAt',
    lastEditedAt: 'lastEditedAt',
    deleted: 'deleted',
    cropId: 'cropId',
    plantingNotes: 'plantingNotes'
  };

  export type PlantingTableScalarFieldEnum = (typeof PlantingTableScalarFieldEnum)[keyof typeof PlantingTableScalarFieldEnum]


  export const ProfilesTableScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    firstname: 'firstname',
    lastname: 'lastname',
    phonenumber: 'phonenumber',
    isactive: 'isactive',
    isverified: 'isverified',
    role: 'role',
    permissions: 'permissions',
    createdat: 'createdat',
    updatedat: 'updatedat',
    lastlogin: 'lastlogin',
    twofactorenabled: 'twofactorenabled',
    twofactorsecret: 'twofactorsecret',
    organizationid: 'organizationid',
    locale: 'locale',
    timezone: 'timezone'
  };

  export type ProfilesTableScalarFieldEnum = (typeof ProfilesTableScalarFieldEnum)[keyof typeof ProfilesTableScalarFieldEnum]


  export const ProjectStakeholdersTableScalarFieldEnum: {
    stakeholderId: 'stakeholderId',
    organizationId: 'organizationId',
    stakeholderTypeId: 'stakeholderTypeId',
    projectId: 'projectId'
  };

  export type ProjectStakeholdersTableScalarFieldEnum = (typeof ProjectStakeholdersTableScalarFieldEnum)[keyof typeof ProjectStakeholdersTableScalarFieldEnum]


  export const ProjectsTableScalarFieldEnum: {
    projectId: 'projectId',
    projectName: 'projectName',
    projectNotes: 'projectNotes',
    createdAt: 'createdAt',
    lastEditedAt: 'lastEditedAt',
    editedBy: 'editedBy',
    deleted: 'deleted',
    csvobjId: 'csvobjId',
    source: 'source'
  };

  export type ProjectsTableScalarFieldEnum = (typeof ProjectsTableScalarFieldEnum)[keyof typeof ProjectsTableScalarFieldEnum]


  export const SpeciesTableScalarFieldEnum: {
    speciesId: 'speciesId',
    commonName: 'commonName',
    scientificName: 'scientificName',
    type: 'type',
    family: 'family',
    reference: 'reference',
    createdAt: 'createdAt',
    lastEditedAt: 'lastEditedAt',
    editedBy: 'editedBy',
    deleted: 'deleted'
  };

  export type SpeciesTableScalarFieldEnum = (typeof SpeciesTableScalarFieldEnum)[keyof typeof SpeciesTableScalarFieldEnum]


  export const StakeholderTypesTableScalarFieldEnum: {
    stakeholderType: 'stakeholderType',
    createdAt: 'createdAt',
    lastEditedAt: 'lastEditedAt',
    deleted: 'deleted',
    stakeholderTypeId: 'stakeholderTypeId'
  };

  export type StakeholderTypesTableScalarFieldEnum = (typeof StakeholderTypesTableScalarFieldEnum)[keyof typeof StakeholderTypesTableScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'code_challenge_method'
   */
  export type Enumcode_challenge_methodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'code_challenge_method'>
    


  /**
   * Reference to a field of type 'code_challenge_method[]'
   */
  export type ListEnumcode_challenge_methodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'code_challenge_method[]'>
    


  /**
   * Reference to a field of type 'factor_type'
   */
  export type Enumfactor_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'factor_type'>
    


  /**
   * Reference to a field of type 'factor_type[]'
   */
  export type ListEnumfactor_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'factor_type[]'>
    


  /**
   * Reference to a field of type 'factor_status'
   */
  export type Enumfactor_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'factor_status'>
    


  /**
   * Reference to a field of type 'factor_status[]'
   */
  export type ListEnumfactor_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'factor_status[]'>
    


  /**
   * Reference to a field of type 'one_time_token_type'
   */
  export type Enumone_time_token_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'one_time_token_type'>
    


  /**
   * Reference to a field of type 'one_time_token_type[]'
   */
  export type ListEnumone_time_token_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'one_time_token_type[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'aal_level'
   */
  export type Enumaal_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'aal_level'>
    


  /**
   * Reference to a field of type 'aal_level[]'
   */
  export type ListEnumaal_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'aal_level[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Preparation'
   */
  export type EnumPreparationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Preparation'>
    


  /**
   * Reference to a field of type 'Preparation[]'
   */
  export type ListEnumPreparationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Preparation[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'user_role'
   */
  export type Enumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role'>
    


  /**
   * Reference to a field of type 'user_role[]'
   */
  export type ListEnumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role[]'>
    
  /**
   * Deep Input Types
   */


  export type audit_log_entriesWhereInput = {
    AND?: audit_log_entriesWhereInput | audit_log_entriesWhereInput[]
    OR?: audit_log_entriesWhereInput[]
    NOT?: audit_log_entriesWhereInput | audit_log_entriesWhereInput[]
    instance_id?: UuidNullableFilter<"audit_log_entries"> | string | null
    id?: UuidFilter<"audit_log_entries"> | string
    payload?: JsonNullableFilter<"audit_log_entries">
    created_at?: DateTimeNullableFilter<"audit_log_entries"> | Date | string | null
    ip_address?: StringFilter<"audit_log_entries"> | string
  }

  export type audit_log_entriesOrderByWithRelationInput = {
    instance_id?: SortOrderInput | SortOrder
    id?: SortOrder
    payload?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    ip_address?: SortOrder
  }

  export type audit_log_entriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: audit_log_entriesWhereInput | audit_log_entriesWhereInput[]
    OR?: audit_log_entriesWhereInput[]
    NOT?: audit_log_entriesWhereInput | audit_log_entriesWhereInput[]
    instance_id?: UuidNullableFilter<"audit_log_entries"> | string | null
    payload?: JsonNullableFilter<"audit_log_entries">
    created_at?: DateTimeNullableFilter<"audit_log_entries"> | Date | string | null
    ip_address?: StringFilter<"audit_log_entries"> | string
  }, "id">

  export type audit_log_entriesOrderByWithAggregationInput = {
    instance_id?: SortOrderInput | SortOrder
    id?: SortOrder
    payload?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    ip_address?: SortOrder
    _count?: audit_log_entriesCountOrderByAggregateInput
    _max?: audit_log_entriesMaxOrderByAggregateInput
    _min?: audit_log_entriesMinOrderByAggregateInput
  }

  export type audit_log_entriesScalarWhereWithAggregatesInput = {
    AND?: audit_log_entriesScalarWhereWithAggregatesInput | audit_log_entriesScalarWhereWithAggregatesInput[]
    OR?: audit_log_entriesScalarWhereWithAggregatesInput[]
    NOT?: audit_log_entriesScalarWhereWithAggregatesInput | audit_log_entriesScalarWhereWithAggregatesInput[]
    instance_id?: UuidNullableWithAggregatesFilter<"audit_log_entries"> | string | null
    id?: UuidWithAggregatesFilter<"audit_log_entries"> | string
    payload?: JsonNullableWithAggregatesFilter<"audit_log_entries">
    created_at?: DateTimeNullableWithAggregatesFilter<"audit_log_entries"> | Date | string | null
    ip_address?: StringWithAggregatesFilter<"audit_log_entries"> | string
  }

  export type flow_stateWhereInput = {
    AND?: flow_stateWhereInput | flow_stateWhereInput[]
    OR?: flow_stateWhereInput[]
    NOT?: flow_stateWhereInput | flow_stateWhereInput[]
    id?: UuidFilter<"flow_state"> | string
    user_id?: UuidNullableFilter<"flow_state"> | string | null
    auth_code?: StringFilter<"flow_state"> | string
    code_challenge_method?: Enumcode_challenge_methodFilter<"flow_state"> | $Enums.code_challenge_method
    code_challenge?: StringFilter<"flow_state"> | string
    provider_type?: StringFilter<"flow_state"> | string
    provider_access_token?: StringNullableFilter<"flow_state"> | string | null
    provider_refresh_token?: StringNullableFilter<"flow_state"> | string | null
    created_at?: DateTimeNullableFilter<"flow_state"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"flow_state"> | Date | string | null
    authentication_method?: StringFilter<"flow_state"> | string
    auth_code_issued_at?: DateTimeNullableFilter<"flow_state"> | Date | string | null
    saml_relay_states?: Saml_relay_statesListRelationFilter
  }

  export type flow_stateOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    auth_code?: SortOrder
    code_challenge_method?: SortOrder
    code_challenge?: SortOrder
    provider_type?: SortOrder
    provider_access_token?: SortOrderInput | SortOrder
    provider_refresh_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    authentication_method?: SortOrder
    auth_code_issued_at?: SortOrderInput | SortOrder
    saml_relay_states?: saml_relay_statesOrderByRelationAggregateInput
  }

  export type flow_stateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: flow_stateWhereInput | flow_stateWhereInput[]
    OR?: flow_stateWhereInput[]
    NOT?: flow_stateWhereInput | flow_stateWhereInput[]
    user_id?: UuidNullableFilter<"flow_state"> | string | null
    auth_code?: StringFilter<"flow_state"> | string
    code_challenge_method?: Enumcode_challenge_methodFilter<"flow_state"> | $Enums.code_challenge_method
    code_challenge?: StringFilter<"flow_state"> | string
    provider_type?: StringFilter<"flow_state"> | string
    provider_access_token?: StringNullableFilter<"flow_state"> | string | null
    provider_refresh_token?: StringNullableFilter<"flow_state"> | string | null
    created_at?: DateTimeNullableFilter<"flow_state"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"flow_state"> | Date | string | null
    authentication_method?: StringFilter<"flow_state"> | string
    auth_code_issued_at?: DateTimeNullableFilter<"flow_state"> | Date | string | null
    saml_relay_states?: Saml_relay_statesListRelationFilter
  }, "id">

  export type flow_stateOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    auth_code?: SortOrder
    code_challenge_method?: SortOrder
    code_challenge?: SortOrder
    provider_type?: SortOrder
    provider_access_token?: SortOrderInput | SortOrder
    provider_refresh_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    authentication_method?: SortOrder
    auth_code_issued_at?: SortOrderInput | SortOrder
    _count?: flow_stateCountOrderByAggregateInput
    _max?: flow_stateMaxOrderByAggregateInput
    _min?: flow_stateMinOrderByAggregateInput
  }

  export type flow_stateScalarWhereWithAggregatesInput = {
    AND?: flow_stateScalarWhereWithAggregatesInput | flow_stateScalarWhereWithAggregatesInput[]
    OR?: flow_stateScalarWhereWithAggregatesInput[]
    NOT?: flow_stateScalarWhereWithAggregatesInput | flow_stateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"flow_state"> | string
    user_id?: UuidNullableWithAggregatesFilter<"flow_state"> | string | null
    auth_code?: StringWithAggregatesFilter<"flow_state"> | string
    code_challenge_method?: Enumcode_challenge_methodWithAggregatesFilter<"flow_state"> | $Enums.code_challenge_method
    code_challenge?: StringWithAggregatesFilter<"flow_state"> | string
    provider_type?: StringWithAggregatesFilter<"flow_state"> | string
    provider_access_token?: StringNullableWithAggregatesFilter<"flow_state"> | string | null
    provider_refresh_token?: StringNullableWithAggregatesFilter<"flow_state"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"flow_state"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"flow_state"> | Date | string | null
    authentication_method?: StringWithAggregatesFilter<"flow_state"> | string
    auth_code_issued_at?: DateTimeNullableWithAggregatesFilter<"flow_state"> | Date | string | null
  }

  export type identitiesWhereInput = {
    AND?: identitiesWhereInput | identitiesWhereInput[]
    OR?: identitiesWhereInput[]
    NOT?: identitiesWhereInput | identitiesWhereInput[]
    provider_id?: StringFilter<"identities"> | string
    user_id?: UuidFilter<"identities"> | string
    identity_data?: JsonFilter<"identities">
    provider?: StringFilter<"identities"> | string
    last_sign_in_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    created_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    email?: StringNullableFilter<"identities"> | string | null
    id?: UuidFilter<"identities"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type identitiesOrderByWithRelationInput = {
    provider_id?: SortOrder
    user_id?: SortOrder
    identity_data?: SortOrder
    provider?: SortOrder
    last_sign_in_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    id?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type identitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_id_provider?: identitiesProvider_idProviderCompoundUniqueInput
    AND?: identitiesWhereInput | identitiesWhereInput[]
    OR?: identitiesWhereInput[]
    NOT?: identitiesWhereInput | identitiesWhereInput[]
    provider_id?: StringFilter<"identities"> | string
    user_id?: UuidFilter<"identities"> | string
    identity_data?: JsonFilter<"identities">
    provider?: StringFilter<"identities"> | string
    last_sign_in_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    created_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    email?: StringNullableFilter<"identities"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "provider_id_provider">

  export type identitiesOrderByWithAggregationInput = {
    provider_id?: SortOrder
    user_id?: SortOrder
    identity_data?: SortOrder
    provider?: SortOrder
    last_sign_in_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: identitiesCountOrderByAggregateInput
    _max?: identitiesMaxOrderByAggregateInput
    _min?: identitiesMinOrderByAggregateInput
  }

  export type identitiesScalarWhereWithAggregatesInput = {
    AND?: identitiesScalarWhereWithAggregatesInput | identitiesScalarWhereWithAggregatesInput[]
    OR?: identitiesScalarWhereWithAggregatesInput[]
    NOT?: identitiesScalarWhereWithAggregatesInput | identitiesScalarWhereWithAggregatesInput[]
    provider_id?: StringWithAggregatesFilter<"identities"> | string
    user_id?: UuidWithAggregatesFilter<"identities"> | string
    identity_data?: JsonWithAggregatesFilter<"identities">
    provider?: StringWithAggregatesFilter<"identities"> | string
    last_sign_in_at?: DateTimeNullableWithAggregatesFilter<"identities"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"identities"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"identities"> | Date | string | null
    email?: StringNullableWithAggregatesFilter<"identities"> | string | null
    id?: UuidWithAggregatesFilter<"identities"> | string
  }

  export type instancesWhereInput = {
    AND?: instancesWhereInput | instancesWhereInput[]
    OR?: instancesWhereInput[]
    NOT?: instancesWhereInput | instancesWhereInput[]
    id?: UuidFilter<"instances"> | string
    uuid?: UuidNullableFilter<"instances"> | string | null
    raw_base_config?: StringNullableFilter<"instances"> | string | null
    created_at?: DateTimeNullableFilter<"instances"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"instances"> | Date | string | null
  }

  export type instancesOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    raw_base_config?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type instancesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: instancesWhereInput | instancesWhereInput[]
    OR?: instancesWhereInput[]
    NOT?: instancesWhereInput | instancesWhereInput[]
    uuid?: UuidNullableFilter<"instances"> | string | null
    raw_base_config?: StringNullableFilter<"instances"> | string | null
    created_at?: DateTimeNullableFilter<"instances"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"instances"> | Date | string | null
  }, "id">

  export type instancesOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    raw_base_config?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: instancesCountOrderByAggregateInput
    _max?: instancesMaxOrderByAggregateInput
    _min?: instancesMinOrderByAggregateInput
  }

  export type instancesScalarWhereWithAggregatesInput = {
    AND?: instancesScalarWhereWithAggregatesInput | instancesScalarWhereWithAggregatesInput[]
    OR?: instancesScalarWhereWithAggregatesInput[]
    NOT?: instancesScalarWhereWithAggregatesInput | instancesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"instances"> | string
    uuid?: UuidNullableWithAggregatesFilter<"instances"> | string | null
    raw_base_config?: StringNullableWithAggregatesFilter<"instances"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"instances"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"instances"> | Date | string | null
  }

  export type mfa_amr_claimsWhereInput = {
    AND?: mfa_amr_claimsWhereInput | mfa_amr_claimsWhereInput[]
    OR?: mfa_amr_claimsWhereInput[]
    NOT?: mfa_amr_claimsWhereInput | mfa_amr_claimsWhereInput[]
    session_id?: UuidFilter<"mfa_amr_claims"> | string
    created_at?: DateTimeFilter<"mfa_amr_claims"> | Date | string
    updated_at?: DateTimeFilter<"mfa_amr_claims"> | Date | string
    authentication_method?: StringFilter<"mfa_amr_claims"> | string
    id?: UuidFilter<"mfa_amr_claims"> | string
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
  }

  export type mfa_amr_claimsOrderByWithRelationInput = {
    session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    id?: SortOrder
    sessions?: sessionsOrderByWithRelationInput
  }

  export type mfa_amr_claimsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    session_id_authentication_method?: mfa_amr_claimsSession_idAuthentication_methodCompoundUniqueInput
    AND?: mfa_amr_claimsWhereInput | mfa_amr_claimsWhereInput[]
    OR?: mfa_amr_claimsWhereInput[]
    NOT?: mfa_amr_claimsWhereInput | mfa_amr_claimsWhereInput[]
    session_id?: UuidFilter<"mfa_amr_claims"> | string
    created_at?: DateTimeFilter<"mfa_amr_claims"> | Date | string
    updated_at?: DateTimeFilter<"mfa_amr_claims"> | Date | string
    authentication_method?: StringFilter<"mfa_amr_claims"> | string
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
  }, "id" | "session_id_authentication_method">

  export type mfa_amr_claimsOrderByWithAggregationInput = {
    session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    id?: SortOrder
    _count?: mfa_amr_claimsCountOrderByAggregateInput
    _max?: mfa_amr_claimsMaxOrderByAggregateInput
    _min?: mfa_amr_claimsMinOrderByAggregateInput
  }

  export type mfa_amr_claimsScalarWhereWithAggregatesInput = {
    AND?: mfa_amr_claimsScalarWhereWithAggregatesInput | mfa_amr_claimsScalarWhereWithAggregatesInput[]
    OR?: mfa_amr_claimsScalarWhereWithAggregatesInput[]
    NOT?: mfa_amr_claimsScalarWhereWithAggregatesInput | mfa_amr_claimsScalarWhereWithAggregatesInput[]
    session_id?: UuidWithAggregatesFilter<"mfa_amr_claims"> | string
    created_at?: DateTimeWithAggregatesFilter<"mfa_amr_claims"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"mfa_amr_claims"> | Date | string
    authentication_method?: StringWithAggregatesFilter<"mfa_amr_claims"> | string
    id?: UuidWithAggregatesFilter<"mfa_amr_claims"> | string
  }

  export type mfa_challengesWhereInput = {
    AND?: mfa_challengesWhereInput | mfa_challengesWhereInput[]
    OR?: mfa_challengesWhereInput[]
    NOT?: mfa_challengesWhereInput | mfa_challengesWhereInput[]
    id?: UuidFilter<"mfa_challenges"> | string
    factor_id?: UuidFilter<"mfa_challenges"> | string
    created_at?: DateTimeFilter<"mfa_challenges"> | Date | string
    verified_at?: DateTimeNullableFilter<"mfa_challenges"> | Date | string | null
    ip_address?: StringFilter<"mfa_challenges"> | string
    otp_code?: StringNullableFilter<"mfa_challenges"> | string | null
    web_authn_session_data?: JsonNullableFilter<"mfa_challenges">
    mfa_factors?: XOR<Mfa_factorsScalarRelationFilter, mfa_factorsWhereInput>
  }

  export type mfa_challengesOrderByWithRelationInput = {
    id?: SortOrder
    factor_id?: SortOrder
    created_at?: SortOrder
    verified_at?: SortOrderInput | SortOrder
    ip_address?: SortOrder
    otp_code?: SortOrderInput | SortOrder
    web_authn_session_data?: SortOrderInput | SortOrder
    mfa_factors?: mfa_factorsOrderByWithRelationInput
  }

  export type mfa_challengesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: mfa_challengesWhereInput | mfa_challengesWhereInput[]
    OR?: mfa_challengesWhereInput[]
    NOT?: mfa_challengesWhereInput | mfa_challengesWhereInput[]
    factor_id?: UuidFilter<"mfa_challenges"> | string
    created_at?: DateTimeFilter<"mfa_challenges"> | Date | string
    verified_at?: DateTimeNullableFilter<"mfa_challenges"> | Date | string | null
    ip_address?: StringFilter<"mfa_challenges"> | string
    otp_code?: StringNullableFilter<"mfa_challenges"> | string | null
    web_authn_session_data?: JsonNullableFilter<"mfa_challenges">
    mfa_factors?: XOR<Mfa_factorsScalarRelationFilter, mfa_factorsWhereInput>
  }, "id">

  export type mfa_challengesOrderByWithAggregationInput = {
    id?: SortOrder
    factor_id?: SortOrder
    created_at?: SortOrder
    verified_at?: SortOrderInput | SortOrder
    ip_address?: SortOrder
    otp_code?: SortOrderInput | SortOrder
    web_authn_session_data?: SortOrderInput | SortOrder
    _count?: mfa_challengesCountOrderByAggregateInput
    _max?: mfa_challengesMaxOrderByAggregateInput
    _min?: mfa_challengesMinOrderByAggregateInput
  }

  export type mfa_challengesScalarWhereWithAggregatesInput = {
    AND?: mfa_challengesScalarWhereWithAggregatesInput | mfa_challengesScalarWhereWithAggregatesInput[]
    OR?: mfa_challengesScalarWhereWithAggregatesInput[]
    NOT?: mfa_challengesScalarWhereWithAggregatesInput | mfa_challengesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"mfa_challenges"> | string
    factor_id?: UuidWithAggregatesFilter<"mfa_challenges"> | string
    created_at?: DateTimeWithAggregatesFilter<"mfa_challenges"> | Date | string
    verified_at?: DateTimeNullableWithAggregatesFilter<"mfa_challenges"> | Date | string | null
    ip_address?: StringWithAggregatesFilter<"mfa_challenges"> | string
    otp_code?: StringNullableWithAggregatesFilter<"mfa_challenges"> | string | null
    web_authn_session_data?: JsonNullableWithAggregatesFilter<"mfa_challenges">
  }

  export type mfa_factorsWhereInput = {
    AND?: mfa_factorsWhereInput | mfa_factorsWhereInput[]
    OR?: mfa_factorsWhereInput[]
    NOT?: mfa_factorsWhereInput | mfa_factorsWhereInput[]
    id?: UuidFilter<"mfa_factors"> | string
    user_id?: UuidFilter<"mfa_factors"> | string
    friendly_name?: StringNullableFilter<"mfa_factors"> | string | null
    factor_type?: Enumfactor_typeFilter<"mfa_factors"> | $Enums.factor_type
    status?: Enumfactor_statusFilter<"mfa_factors"> | $Enums.factor_status
    created_at?: DateTimeFilter<"mfa_factors"> | Date | string
    updated_at?: DateTimeFilter<"mfa_factors"> | Date | string
    secret?: StringNullableFilter<"mfa_factors"> | string | null
    phone?: StringNullableFilter<"mfa_factors"> | string | null
    last_challenged_at?: DateTimeNullableFilter<"mfa_factors"> | Date | string | null
    web_authn_credential?: JsonNullableFilter<"mfa_factors">
    web_authn_aaguid?: UuidNullableFilter<"mfa_factors"> | string | null
    mfa_challenges?: Mfa_challengesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type mfa_factorsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    friendly_name?: SortOrderInput | SortOrder
    factor_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secret?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    last_challenged_at?: SortOrderInput | SortOrder
    web_authn_credential?: SortOrderInput | SortOrder
    web_authn_aaguid?: SortOrderInput | SortOrder
    mfa_challenges?: mfa_challengesOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type mfa_factorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    last_challenged_at?: Date | string
    user_id_phone?: mfa_factorsUser_idPhoneCompoundUniqueInput
    AND?: mfa_factorsWhereInput | mfa_factorsWhereInput[]
    OR?: mfa_factorsWhereInput[]
    NOT?: mfa_factorsWhereInput | mfa_factorsWhereInput[]
    user_id?: UuidFilter<"mfa_factors"> | string
    friendly_name?: StringNullableFilter<"mfa_factors"> | string | null
    factor_type?: Enumfactor_typeFilter<"mfa_factors"> | $Enums.factor_type
    status?: Enumfactor_statusFilter<"mfa_factors"> | $Enums.factor_status
    created_at?: DateTimeFilter<"mfa_factors"> | Date | string
    updated_at?: DateTimeFilter<"mfa_factors"> | Date | string
    secret?: StringNullableFilter<"mfa_factors"> | string | null
    phone?: StringNullableFilter<"mfa_factors"> | string | null
    web_authn_credential?: JsonNullableFilter<"mfa_factors">
    web_authn_aaguid?: UuidNullableFilter<"mfa_factors"> | string | null
    mfa_challenges?: Mfa_challengesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "last_challenged_at" | "user_id_phone">

  export type mfa_factorsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    friendly_name?: SortOrderInput | SortOrder
    factor_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secret?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    last_challenged_at?: SortOrderInput | SortOrder
    web_authn_credential?: SortOrderInput | SortOrder
    web_authn_aaguid?: SortOrderInput | SortOrder
    _count?: mfa_factorsCountOrderByAggregateInput
    _max?: mfa_factorsMaxOrderByAggregateInput
    _min?: mfa_factorsMinOrderByAggregateInput
  }

  export type mfa_factorsScalarWhereWithAggregatesInput = {
    AND?: mfa_factorsScalarWhereWithAggregatesInput | mfa_factorsScalarWhereWithAggregatesInput[]
    OR?: mfa_factorsScalarWhereWithAggregatesInput[]
    NOT?: mfa_factorsScalarWhereWithAggregatesInput | mfa_factorsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"mfa_factors"> | string
    user_id?: UuidWithAggregatesFilter<"mfa_factors"> | string
    friendly_name?: StringNullableWithAggregatesFilter<"mfa_factors"> | string | null
    factor_type?: Enumfactor_typeWithAggregatesFilter<"mfa_factors"> | $Enums.factor_type
    status?: Enumfactor_statusWithAggregatesFilter<"mfa_factors"> | $Enums.factor_status
    created_at?: DateTimeWithAggregatesFilter<"mfa_factors"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"mfa_factors"> | Date | string
    secret?: StringNullableWithAggregatesFilter<"mfa_factors"> | string | null
    phone?: StringNullableWithAggregatesFilter<"mfa_factors"> | string | null
    last_challenged_at?: DateTimeNullableWithAggregatesFilter<"mfa_factors"> | Date | string | null
    web_authn_credential?: JsonNullableWithAggregatesFilter<"mfa_factors">
    web_authn_aaguid?: UuidNullableWithAggregatesFilter<"mfa_factors"> | string | null
  }

  export type one_time_tokensWhereInput = {
    AND?: one_time_tokensWhereInput | one_time_tokensWhereInput[]
    OR?: one_time_tokensWhereInput[]
    NOT?: one_time_tokensWhereInput | one_time_tokensWhereInput[]
    id?: UuidFilter<"one_time_tokens"> | string
    user_id?: UuidFilter<"one_time_tokens"> | string
    token_type?: Enumone_time_token_typeFilter<"one_time_tokens"> | $Enums.one_time_token_type
    token_hash?: StringFilter<"one_time_tokens"> | string
    relates_to?: StringFilter<"one_time_tokens"> | string
    created_at?: DateTimeFilter<"one_time_tokens"> | Date | string
    updated_at?: DateTimeFilter<"one_time_tokens"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type one_time_tokensOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_type?: SortOrder
    token_hash?: SortOrder
    relates_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type one_time_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_token_type?: one_time_tokensUser_idToken_typeCompoundUniqueInput
    AND?: one_time_tokensWhereInput | one_time_tokensWhereInput[]
    OR?: one_time_tokensWhereInput[]
    NOT?: one_time_tokensWhereInput | one_time_tokensWhereInput[]
    user_id?: UuidFilter<"one_time_tokens"> | string
    token_type?: Enumone_time_token_typeFilter<"one_time_tokens"> | $Enums.one_time_token_type
    token_hash?: StringFilter<"one_time_tokens"> | string
    relates_to?: StringFilter<"one_time_tokens"> | string
    created_at?: DateTimeFilter<"one_time_tokens"> | Date | string
    updated_at?: DateTimeFilter<"one_time_tokens"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "user_id_token_type">

  export type one_time_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_type?: SortOrder
    token_hash?: SortOrder
    relates_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: one_time_tokensCountOrderByAggregateInput
    _max?: one_time_tokensMaxOrderByAggregateInput
    _min?: one_time_tokensMinOrderByAggregateInput
  }

  export type one_time_tokensScalarWhereWithAggregatesInput = {
    AND?: one_time_tokensScalarWhereWithAggregatesInput | one_time_tokensScalarWhereWithAggregatesInput[]
    OR?: one_time_tokensScalarWhereWithAggregatesInput[]
    NOT?: one_time_tokensScalarWhereWithAggregatesInput | one_time_tokensScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"one_time_tokens"> | string
    user_id?: UuidWithAggregatesFilter<"one_time_tokens"> | string
    token_type?: Enumone_time_token_typeWithAggregatesFilter<"one_time_tokens"> | $Enums.one_time_token_type
    token_hash?: StringWithAggregatesFilter<"one_time_tokens"> | string
    relates_to?: StringWithAggregatesFilter<"one_time_tokens"> | string
    created_at?: DateTimeWithAggregatesFilter<"one_time_tokens"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"one_time_tokens"> | Date | string
  }

  export type refresh_tokensWhereInput = {
    AND?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    OR?: refresh_tokensWhereInput[]
    NOT?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    instance_id?: UuidNullableFilter<"refresh_tokens"> | string | null
    id?: BigIntFilter<"refresh_tokens"> | bigint | number
    token?: StringNullableFilter<"refresh_tokens"> | string | null
    user_id?: StringNullableFilter<"refresh_tokens"> | string | null
    revoked?: BoolNullableFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    parent?: StringNullableFilter<"refresh_tokens"> | string | null
    session_id?: UuidNullableFilter<"refresh_tokens"> | string | null
    sessions?: XOR<SessionsNullableScalarRelationFilter, sessionsWhereInput> | null
  }

  export type refresh_tokensOrderByWithRelationInput = {
    instance_id?: SortOrderInput | SortOrder
    id?: SortOrder
    token?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    revoked?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    parent?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    sessions?: sessionsOrderByWithRelationInput
  }

  export type refresh_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    token?: string
    AND?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    OR?: refresh_tokensWhereInput[]
    NOT?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    instance_id?: UuidNullableFilter<"refresh_tokens"> | string | null
    user_id?: StringNullableFilter<"refresh_tokens"> | string | null
    revoked?: BoolNullableFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    parent?: StringNullableFilter<"refresh_tokens"> | string | null
    session_id?: UuidNullableFilter<"refresh_tokens"> | string | null
    sessions?: XOR<SessionsNullableScalarRelationFilter, sessionsWhereInput> | null
  }, "id" | "token">

  export type refresh_tokensOrderByWithAggregationInput = {
    instance_id?: SortOrderInput | SortOrder
    id?: SortOrder
    token?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    revoked?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    parent?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    _count?: refresh_tokensCountOrderByAggregateInput
    _avg?: refresh_tokensAvgOrderByAggregateInput
    _max?: refresh_tokensMaxOrderByAggregateInput
    _min?: refresh_tokensMinOrderByAggregateInput
    _sum?: refresh_tokensSumOrderByAggregateInput
  }

  export type refresh_tokensScalarWhereWithAggregatesInput = {
    AND?: refresh_tokensScalarWhereWithAggregatesInput | refresh_tokensScalarWhereWithAggregatesInput[]
    OR?: refresh_tokensScalarWhereWithAggregatesInput[]
    NOT?: refresh_tokensScalarWhereWithAggregatesInput | refresh_tokensScalarWhereWithAggregatesInput[]
    instance_id?: UuidNullableWithAggregatesFilter<"refresh_tokens"> | string | null
    id?: BigIntWithAggregatesFilter<"refresh_tokens"> | bigint | number
    token?: StringNullableWithAggregatesFilter<"refresh_tokens"> | string | null
    user_id?: StringNullableWithAggregatesFilter<"refresh_tokens"> | string | null
    revoked?: BoolNullableWithAggregatesFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"refresh_tokens"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"refresh_tokens"> | Date | string | null
    parent?: StringNullableWithAggregatesFilter<"refresh_tokens"> | string | null
    session_id?: UuidNullableWithAggregatesFilter<"refresh_tokens"> | string | null
  }

  export type saml_providersWhereInput = {
    AND?: saml_providersWhereInput | saml_providersWhereInput[]
    OR?: saml_providersWhereInput[]
    NOT?: saml_providersWhereInput | saml_providersWhereInput[]
    id?: UuidFilter<"saml_providers"> | string
    sso_provider_id?: UuidFilter<"saml_providers"> | string
    entity_id?: StringFilter<"saml_providers"> | string
    metadata_xml?: StringFilter<"saml_providers"> | string
    metadata_url?: StringNullableFilter<"saml_providers"> | string | null
    attribute_mapping?: JsonNullableFilter<"saml_providers">
    created_at?: DateTimeNullableFilter<"saml_providers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saml_providers"> | Date | string | null
    name_id_format?: StringNullableFilter<"saml_providers"> | string | null
    sso_providers?: XOR<Sso_providersScalarRelationFilter, sso_providersWhereInput>
  }

  export type saml_providersOrderByWithRelationInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    entity_id?: SortOrder
    metadata_xml?: SortOrder
    metadata_url?: SortOrderInput | SortOrder
    attribute_mapping?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    name_id_format?: SortOrderInput | SortOrder
    sso_providers?: sso_providersOrderByWithRelationInput
  }

  export type saml_providersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entity_id?: string
    AND?: saml_providersWhereInput | saml_providersWhereInput[]
    OR?: saml_providersWhereInput[]
    NOT?: saml_providersWhereInput | saml_providersWhereInput[]
    sso_provider_id?: UuidFilter<"saml_providers"> | string
    metadata_xml?: StringFilter<"saml_providers"> | string
    metadata_url?: StringNullableFilter<"saml_providers"> | string | null
    attribute_mapping?: JsonNullableFilter<"saml_providers">
    created_at?: DateTimeNullableFilter<"saml_providers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saml_providers"> | Date | string | null
    name_id_format?: StringNullableFilter<"saml_providers"> | string | null
    sso_providers?: XOR<Sso_providersScalarRelationFilter, sso_providersWhereInput>
  }, "id" | "entity_id">

  export type saml_providersOrderByWithAggregationInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    entity_id?: SortOrder
    metadata_xml?: SortOrder
    metadata_url?: SortOrderInput | SortOrder
    attribute_mapping?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    name_id_format?: SortOrderInput | SortOrder
    _count?: saml_providersCountOrderByAggregateInput
    _max?: saml_providersMaxOrderByAggregateInput
    _min?: saml_providersMinOrderByAggregateInput
  }

  export type saml_providersScalarWhereWithAggregatesInput = {
    AND?: saml_providersScalarWhereWithAggregatesInput | saml_providersScalarWhereWithAggregatesInput[]
    OR?: saml_providersScalarWhereWithAggregatesInput[]
    NOT?: saml_providersScalarWhereWithAggregatesInput | saml_providersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"saml_providers"> | string
    sso_provider_id?: UuidWithAggregatesFilter<"saml_providers"> | string
    entity_id?: StringWithAggregatesFilter<"saml_providers"> | string
    metadata_xml?: StringWithAggregatesFilter<"saml_providers"> | string
    metadata_url?: StringNullableWithAggregatesFilter<"saml_providers"> | string | null
    attribute_mapping?: JsonNullableWithAggregatesFilter<"saml_providers">
    created_at?: DateTimeNullableWithAggregatesFilter<"saml_providers"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"saml_providers"> | Date | string | null
    name_id_format?: StringNullableWithAggregatesFilter<"saml_providers"> | string | null
  }

  export type saml_relay_statesWhereInput = {
    AND?: saml_relay_statesWhereInput | saml_relay_statesWhereInput[]
    OR?: saml_relay_statesWhereInput[]
    NOT?: saml_relay_statesWhereInput | saml_relay_statesWhereInput[]
    id?: UuidFilter<"saml_relay_states"> | string
    sso_provider_id?: UuidFilter<"saml_relay_states"> | string
    request_id?: StringFilter<"saml_relay_states"> | string
    for_email?: StringNullableFilter<"saml_relay_states"> | string | null
    redirect_to?: StringNullableFilter<"saml_relay_states"> | string | null
    created_at?: DateTimeNullableFilter<"saml_relay_states"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saml_relay_states"> | Date | string | null
    flow_state_id?: UuidNullableFilter<"saml_relay_states"> | string | null
    flow_state?: XOR<Flow_stateNullableScalarRelationFilter, flow_stateWhereInput> | null
    sso_providers?: XOR<Sso_providersScalarRelationFilter, sso_providersWhereInput>
  }

  export type saml_relay_statesOrderByWithRelationInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    request_id?: SortOrder
    for_email?: SortOrderInput | SortOrder
    redirect_to?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    flow_state_id?: SortOrderInput | SortOrder
    flow_state?: flow_stateOrderByWithRelationInput
    sso_providers?: sso_providersOrderByWithRelationInput
  }

  export type saml_relay_statesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: saml_relay_statesWhereInput | saml_relay_statesWhereInput[]
    OR?: saml_relay_statesWhereInput[]
    NOT?: saml_relay_statesWhereInput | saml_relay_statesWhereInput[]
    sso_provider_id?: UuidFilter<"saml_relay_states"> | string
    request_id?: StringFilter<"saml_relay_states"> | string
    for_email?: StringNullableFilter<"saml_relay_states"> | string | null
    redirect_to?: StringNullableFilter<"saml_relay_states"> | string | null
    created_at?: DateTimeNullableFilter<"saml_relay_states"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saml_relay_states"> | Date | string | null
    flow_state_id?: UuidNullableFilter<"saml_relay_states"> | string | null
    flow_state?: XOR<Flow_stateNullableScalarRelationFilter, flow_stateWhereInput> | null
    sso_providers?: XOR<Sso_providersScalarRelationFilter, sso_providersWhereInput>
  }, "id">

  export type saml_relay_statesOrderByWithAggregationInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    request_id?: SortOrder
    for_email?: SortOrderInput | SortOrder
    redirect_to?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    flow_state_id?: SortOrderInput | SortOrder
    _count?: saml_relay_statesCountOrderByAggregateInput
    _max?: saml_relay_statesMaxOrderByAggregateInput
    _min?: saml_relay_statesMinOrderByAggregateInput
  }

  export type saml_relay_statesScalarWhereWithAggregatesInput = {
    AND?: saml_relay_statesScalarWhereWithAggregatesInput | saml_relay_statesScalarWhereWithAggregatesInput[]
    OR?: saml_relay_statesScalarWhereWithAggregatesInput[]
    NOT?: saml_relay_statesScalarWhereWithAggregatesInput | saml_relay_statesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"saml_relay_states"> | string
    sso_provider_id?: UuidWithAggregatesFilter<"saml_relay_states"> | string
    request_id?: StringWithAggregatesFilter<"saml_relay_states"> | string
    for_email?: StringNullableWithAggregatesFilter<"saml_relay_states"> | string | null
    redirect_to?: StringNullableWithAggregatesFilter<"saml_relay_states"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"saml_relay_states"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"saml_relay_states"> | Date | string | null
    flow_state_id?: UuidNullableWithAggregatesFilter<"saml_relay_states"> | string | null
  }

  export type schema_migrationsWhereInput = {
    AND?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    OR?: schema_migrationsWhereInput[]
    NOT?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    version?: StringFilter<"schema_migrations"> | string
  }

  export type schema_migrationsOrderByWithRelationInput = {
    version?: SortOrder
  }

  export type schema_migrationsWhereUniqueInput = Prisma.AtLeast<{
    version?: string
    AND?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    OR?: schema_migrationsWhereInput[]
    NOT?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
  }, "version">

  export type schema_migrationsOrderByWithAggregationInput = {
    version?: SortOrder
    _count?: schema_migrationsCountOrderByAggregateInput
    _max?: schema_migrationsMaxOrderByAggregateInput
    _min?: schema_migrationsMinOrderByAggregateInput
  }

  export type schema_migrationsScalarWhereWithAggregatesInput = {
    AND?: schema_migrationsScalarWhereWithAggregatesInput | schema_migrationsScalarWhereWithAggregatesInput[]
    OR?: schema_migrationsScalarWhereWithAggregatesInput[]
    NOT?: schema_migrationsScalarWhereWithAggregatesInput | schema_migrationsScalarWhereWithAggregatesInput[]
    version?: StringWithAggregatesFilter<"schema_migrations"> | string
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: UuidFilter<"sessions"> | string
    user_id?: UuidFilter<"sessions"> | string
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    factor_id?: UuidNullableFilter<"sessions"> | string | null
    aal?: Enumaal_levelNullableFilter<"sessions"> | $Enums.aal_level | null
    not_after?: DateTimeNullableFilter<"sessions"> | Date | string | null
    refreshed_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    user_agent?: StringNullableFilter<"sessions"> | string | null
    ip?: StringNullableFilter<"sessions"> | string | null
    tag?: StringNullableFilter<"sessions"> | string | null
    mfa_amr_claims?: Mfa_amr_claimsListRelationFilter
    refresh_tokens?: Refresh_tokensListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    factor_id?: SortOrderInput | SortOrder
    aal?: SortOrderInput | SortOrder
    not_after?: SortOrderInput | SortOrder
    refreshed_at?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    mfa_amr_claims?: mfa_amr_claimsOrderByRelationAggregateInput
    refresh_tokens?: refresh_tokensOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user_id?: UuidFilter<"sessions"> | string
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    factor_id?: UuidNullableFilter<"sessions"> | string | null
    aal?: Enumaal_levelNullableFilter<"sessions"> | $Enums.aal_level | null
    not_after?: DateTimeNullableFilter<"sessions"> | Date | string | null
    refreshed_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    user_agent?: StringNullableFilter<"sessions"> | string | null
    ip?: StringNullableFilter<"sessions"> | string | null
    tag?: StringNullableFilter<"sessions"> | string | null
    mfa_amr_claims?: Mfa_amr_claimsListRelationFilter
    refresh_tokens?: Refresh_tokensListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    factor_id?: SortOrderInput | SortOrder
    aal?: SortOrderInput | SortOrder
    not_after?: SortOrderInput | SortOrder
    refreshed_at?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"sessions"> | string
    user_id?: UuidWithAggregatesFilter<"sessions"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    factor_id?: UuidNullableWithAggregatesFilter<"sessions"> | string | null
    aal?: Enumaal_levelNullableWithAggregatesFilter<"sessions"> | $Enums.aal_level | null
    not_after?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    refreshed_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    user_agent?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    ip?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    tag?: StringNullableWithAggregatesFilter<"sessions"> | string | null
  }

  export type sso_domainsWhereInput = {
    AND?: sso_domainsWhereInput | sso_domainsWhereInput[]
    OR?: sso_domainsWhereInput[]
    NOT?: sso_domainsWhereInput | sso_domainsWhereInput[]
    id?: UuidFilter<"sso_domains"> | string
    sso_provider_id?: UuidFilter<"sso_domains"> | string
    domain?: StringFilter<"sso_domains"> | string
    created_at?: DateTimeNullableFilter<"sso_domains"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sso_domains"> | Date | string | null
    sso_providers?: XOR<Sso_providersScalarRelationFilter, sso_providersWhereInput>
  }

  export type sso_domainsOrderByWithRelationInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    domain?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    sso_providers?: sso_providersOrderByWithRelationInput
  }

  export type sso_domainsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sso_domainsWhereInput | sso_domainsWhereInput[]
    OR?: sso_domainsWhereInput[]
    NOT?: sso_domainsWhereInput | sso_domainsWhereInput[]
    sso_provider_id?: UuidFilter<"sso_domains"> | string
    domain?: StringFilter<"sso_domains"> | string
    created_at?: DateTimeNullableFilter<"sso_domains"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sso_domains"> | Date | string | null
    sso_providers?: XOR<Sso_providersScalarRelationFilter, sso_providersWhereInput>
  }, "id">

  export type sso_domainsOrderByWithAggregationInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    domain?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: sso_domainsCountOrderByAggregateInput
    _max?: sso_domainsMaxOrderByAggregateInput
    _min?: sso_domainsMinOrderByAggregateInput
  }

  export type sso_domainsScalarWhereWithAggregatesInput = {
    AND?: sso_domainsScalarWhereWithAggregatesInput | sso_domainsScalarWhereWithAggregatesInput[]
    OR?: sso_domainsScalarWhereWithAggregatesInput[]
    NOT?: sso_domainsScalarWhereWithAggregatesInput | sso_domainsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"sso_domains"> | string
    sso_provider_id?: UuidWithAggregatesFilter<"sso_domains"> | string
    domain?: StringWithAggregatesFilter<"sso_domains"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"sso_domains"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"sso_domains"> | Date | string | null
  }

  export type sso_providersWhereInput = {
    AND?: sso_providersWhereInput | sso_providersWhereInput[]
    OR?: sso_providersWhereInput[]
    NOT?: sso_providersWhereInput | sso_providersWhereInput[]
    id?: UuidFilter<"sso_providers"> | string
    resource_id?: StringNullableFilter<"sso_providers"> | string | null
    created_at?: DateTimeNullableFilter<"sso_providers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sso_providers"> | Date | string | null
    saml_providers?: Saml_providersListRelationFilter
    saml_relay_states?: Saml_relay_statesListRelationFilter
    sso_domains?: Sso_domainsListRelationFilter
  }

  export type sso_providersOrderByWithRelationInput = {
    id?: SortOrder
    resource_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    saml_providers?: saml_providersOrderByRelationAggregateInput
    saml_relay_states?: saml_relay_statesOrderByRelationAggregateInput
    sso_domains?: sso_domainsOrderByRelationAggregateInput
  }

  export type sso_providersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sso_providersWhereInput | sso_providersWhereInput[]
    OR?: sso_providersWhereInput[]
    NOT?: sso_providersWhereInput | sso_providersWhereInput[]
    resource_id?: StringNullableFilter<"sso_providers"> | string | null
    created_at?: DateTimeNullableFilter<"sso_providers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sso_providers"> | Date | string | null
    saml_providers?: Saml_providersListRelationFilter
    saml_relay_states?: Saml_relay_statesListRelationFilter
    sso_domains?: Sso_domainsListRelationFilter
  }, "id">

  export type sso_providersOrderByWithAggregationInput = {
    id?: SortOrder
    resource_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: sso_providersCountOrderByAggregateInput
    _max?: sso_providersMaxOrderByAggregateInput
    _min?: sso_providersMinOrderByAggregateInput
  }

  export type sso_providersScalarWhereWithAggregatesInput = {
    AND?: sso_providersScalarWhereWithAggregatesInput | sso_providersScalarWhereWithAggregatesInput[]
    OR?: sso_providersScalarWhereWithAggregatesInput[]
    NOT?: sso_providersScalarWhereWithAggregatesInput | sso_providersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"sso_providers"> | string
    resource_id?: StringNullableWithAggregatesFilter<"sso_providers"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"sso_providers"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"sso_providers"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    instance_id?: UuidNullableFilter<"users"> | string | null
    id?: UuidFilter<"users"> | string
    aud?: StringNullableFilter<"users"> | string | null
    role?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    encrypted_password?: StringNullableFilter<"users"> | string | null
    email_confirmed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    invited_at?: DateTimeNullableFilter<"users"> | Date | string | null
    confirmation_token?: StringNullableFilter<"users"> | string | null
    confirmation_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    recovery_token?: StringNullableFilter<"users"> | string | null
    recovery_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    email_change_token_new?: StringNullableFilter<"users"> | string | null
    email_change?: StringNullableFilter<"users"> | string | null
    email_change_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    last_sign_in_at?: DateTimeNullableFilter<"users"> | Date | string | null
    raw_app_meta_data?: JsonNullableFilter<"users">
    raw_user_meta_data?: JsonNullableFilter<"users">
    is_super_admin?: BoolNullableFilter<"users"> | boolean | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    phone?: StringNullableFilter<"users"> | string | null
    phone_confirmed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    phone_change?: StringNullableFilter<"users"> | string | null
    phone_change_token?: StringNullableFilter<"users"> | string | null
    phone_change_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    confirmed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    email_change_token_current?: StringNullableFilter<"users"> | string | null
    email_change_confirm_status?: IntNullableFilter<"users"> | number | null
    banned_until?: DateTimeNullableFilter<"users"> | Date | string | null
    reauthentication_token?: StringNullableFilter<"users"> | string | null
    reauthentication_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_sso_user?: BoolFilter<"users"> | boolean
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_anonymous?: BoolFilter<"users"> | boolean
    identities?: IdentitiesListRelationFilter
    mfa_factors?: Mfa_factorsListRelationFilter
    one_time_tokens?: One_time_tokensListRelationFilter
    sessions?: SessionsListRelationFilter
    profilesTable?: XOR<ProfilesTableNullableScalarRelationFilter, profilesTableWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    instance_id?: SortOrderInput | SortOrder
    id?: SortOrder
    aud?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    encrypted_password?: SortOrderInput | SortOrder
    email_confirmed_at?: SortOrderInput | SortOrder
    invited_at?: SortOrderInput | SortOrder
    confirmation_token?: SortOrderInput | SortOrder
    confirmation_sent_at?: SortOrderInput | SortOrder
    recovery_token?: SortOrderInput | SortOrder
    recovery_sent_at?: SortOrderInput | SortOrder
    email_change_token_new?: SortOrderInput | SortOrder
    email_change?: SortOrderInput | SortOrder
    email_change_sent_at?: SortOrderInput | SortOrder
    last_sign_in_at?: SortOrderInput | SortOrder
    raw_app_meta_data?: SortOrderInput | SortOrder
    raw_user_meta_data?: SortOrderInput | SortOrder
    is_super_admin?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phone_confirmed_at?: SortOrderInput | SortOrder
    phone_change?: SortOrderInput | SortOrder
    phone_change_token?: SortOrderInput | SortOrder
    phone_change_sent_at?: SortOrderInput | SortOrder
    confirmed_at?: SortOrderInput | SortOrder
    email_change_token_current?: SortOrderInput | SortOrder
    email_change_confirm_status?: SortOrderInput | SortOrder
    banned_until?: SortOrderInput | SortOrder
    reauthentication_token?: SortOrderInput | SortOrder
    reauthentication_sent_at?: SortOrderInput | SortOrder
    is_sso_user?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_anonymous?: SortOrder
    identities?: identitiesOrderByRelationAggregateInput
    mfa_factors?: mfa_factorsOrderByRelationAggregateInput
    one_time_tokens?: one_time_tokensOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
    profilesTable?: profilesTableOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    instance_id?: UuidNullableFilter<"users"> | string | null
    aud?: StringNullableFilter<"users"> | string | null
    role?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    encrypted_password?: StringNullableFilter<"users"> | string | null
    email_confirmed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    invited_at?: DateTimeNullableFilter<"users"> | Date | string | null
    confirmation_token?: StringNullableFilter<"users"> | string | null
    confirmation_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    recovery_token?: StringNullableFilter<"users"> | string | null
    recovery_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    email_change_token_new?: StringNullableFilter<"users"> | string | null
    email_change?: StringNullableFilter<"users"> | string | null
    email_change_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    last_sign_in_at?: DateTimeNullableFilter<"users"> | Date | string | null
    raw_app_meta_data?: JsonNullableFilter<"users">
    raw_user_meta_data?: JsonNullableFilter<"users">
    is_super_admin?: BoolNullableFilter<"users"> | boolean | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    phone_confirmed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    phone_change?: StringNullableFilter<"users"> | string | null
    phone_change_token?: StringNullableFilter<"users"> | string | null
    phone_change_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    confirmed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    email_change_token_current?: StringNullableFilter<"users"> | string | null
    email_change_confirm_status?: IntNullableFilter<"users"> | number | null
    banned_until?: DateTimeNullableFilter<"users"> | Date | string | null
    reauthentication_token?: StringNullableFilter<"users"> | string | null
    reauthentication_sent_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_sso_user?: BoolFilter<"users"> | boolean
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_anonymous?: BoolFilter<"users"> | boolean
    identities?: IdentitiesListRelationFilter
    mfa_factors?: Mfa_factorsListRelationFilter
    one_time_tokens?: One_time_tokensListRelationFilter
    sessions?: SessionsListRelationFilter
    profilesTable?: XOR<ProfilesTableNullableScalarRelationFilter, profilesTableWhereInput> | null
  }, "id" | "phone">

  export type usersOrderByWithAggregationInput = {
    instance_id?: SortOrderInput | SortOrder
    id?: SortOrder
    aud?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    encrypted_password?: SortOrderInput | SortOrder
    email_confirmed_at?: SortOrderInput | SortOrder
    invited_at?: SortOrderInput | SortOrder
    confirmation_token?: SortOrderInput | SortOrder
    confirmation_sent_at?: SortOrderInput | SortOrder
    recovery_token?: SortOrderInput | SortOrder
    recovery_sent_at?: SortOrderInput | SortOrder
    email_change_token_new?: SortOrderInput | SortOrder
    email_change?: SortOrderInput | SortOrder
    email_change_sent_at?: SortOrderInput | SortOrder
    last_sign_in_at?: SortOrderInput | SortOrder
    raw_app_meta_data?: SortOrderInput | SortOrder
    raw_user_meta_data?: SortOrderInput | SortOrder
    is_super_admin?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phone_confirmed_at?: SortOrderInput | SortOrder
    phone_change?: SortOrderInput | SortOrder
    phone_change_token?: SortOrderInput | SortOrder
    phone_change_sent_at?: SortOrderInput | SortOrder
    confirmed_at?: SortOrderInput | SortOrder
    email_change_token_current?: SortOrderInput | SortOrder
    email_change_confirm_status?: SortOrderInput | SortOrder
    banned_until?: SortOrderInput | SortOrder
    reauthentication_token?: SortOrderInput | SortOrder
    reauthentication_sent_at?: SortOrderInput | SortOrder
    is_sso_user?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_anonymous?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    instance_id?: UuidNullableWithAggregatesFilter<"users"> | string | null
    id?: UuidWithAggregatesFilter<"users"> | string
    aud?: StringNullableWithAggregatesFilter<"users"> | string | null
    role?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    encrypted_password?: StringNullableWithAggregatesFilter<"users"> | string | null
    email_confirmed_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    invited_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    confirmation_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    confirmation_sent_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    recovery_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    recovery_sent_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    email_change_token_new?: StringNullableWithAggregatesFilter<"users"> | string | null
    email_change?: StringNullableWithAggregatesFilter<"users"> | string | null
    email_change_sent_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    last_sign_in_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    raw_app_meta_data?: JsonNullableWithAggregatesFilter<"users">
    raw_user_meta_data?: JsonNullableWithAggregatesFilter<"users">
    is_super_admin?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone_confirmed_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    phone_change?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone_change_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone_change_sent_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    confirmed_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    email_change_token_current?: StringNullableWithAggregatesFilter<"users"> | string | null
    email_change_confirm_status?: IntNullableWithAggregatesFilter<"users"> | number | null
    banned_until?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    reauthentication_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    reauthentication_sent_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    is_sso_user?: BoolWithAggregatesFilter<"users"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    is_anonymous?: BoolWithAggregatesFilter<"users"> | boolean
  }

  export type cropStakeholdersTableWhereInput = {
    AND?: cropStakeholdersTableWhereInput | cropStakeholdersTableWhereInput[]
    OR?: cropStakeholdersTableWhereInput[]
    NOT?: cropStakeholdersTableWhereInput | cropStakeholdersTableWhereInput[]
    cropStakeholderId?: UuidFilter<"cropStakeholdersTable"> | string
    cropId?: UuidFilter<"cropStakeholdersTable"> | string
    organizationId?: UuidFilter<"cropStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"cropStakeholdersTable"> | string
    cropTable?: XOR<CropTableScalarRelationFilter, cropTableWhereInput>
    organizationsTable?: XOR<OrganizationsTableScalarRelationFilter, organizationsTableWhereInput>
    stakeholderTypesTable?: XOR<StakeholderTypesTableScalarRelationFilter, stakeholderTypesTableWhereInput>
  }

  export type cropStakeholdersTableOrderByWithRelationInput = {
    cropStakeholderId?: SortOrder
    cropId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    cropTable?: cropTableOrderByWithRelationInput
    organizationsTable?: organizationsTableOrderByWithRelationInput
    stakeholderTypesTable?: stakeholderTypesTableOrderByWithRelationInput
  }

  export type cropStakeholdersTableWhereUniqueInput = Prisma.AtLeast<{
    cropStakeholderId?: string
    cropId_organizationId_stakeholderTypeId?: cropStakeholdersTableCropIdOrganizationIdStakeholderTypeIdCompoundUniqueInput
    AND?: cropStakeholdersTableWhereInput | cropStakeholdersTableWhereInput[]
    OR?: cropStakeholdersTableWhereInput[]
    NOT?: cropStakeholdersTableWhereInput | cropStakeholdersTableWhereInput[]
    cropId?: UuidFilter<"cropStakeholdersTable"> | string
    organizationId?: UuidFilter<"cropStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"cropStakeholdersTable"> | string
    cropTable?: XOR<CropTableScalarRelationFilter, cropTableWhereInput>
    organizationsTable?: XOR<OrganizationsTableScalarRelationFilter, organizationsTableWhereInput>
    stakeholderTypesTable?: XOR<StakeholderTypesTableScalarRelationFilter, stakeholderTypesTableWhereInput>
  }, "cropStakeholderId" | "cropId_organizationId_stakeholderTypeId">

  export type cropStakeholdersTableOrderByWithAggregationInput = {
    cropStakeholderId?: SortOrder
    cropId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    _count?: cropStakeholdersTableCountOrderByAggregateInput
    _max?: cropStakeholdersTableMaxOrderByAggregateInput
    _min?: cropStakeholdersTableMinOrderByAggregateInput
  }

  export type cropStakeholdersTableScalarWhereWithAggregatesInput = {
    AND?: cropStakeholdersTableScalarWhereWithAggregatesInput | cropStakeholdersTableScalarWhereWithAggregatesInput[]
    OR?: cropStakeholdersTableScalarWhereWithAggregatesInput[]
    NOT?: cropStakeholdersTableScalarWhereWithAggregatesInput | cropStakeholdersTableScalarWhereWithAggregatesInput[]
    cropStakeholderId?: UuidWithAggregatesFilter<"cropStakeholdersTable"> | string
    cropId?: UuidWithAggregatesFilter<"cropStakeholdersTable"> | string
    organizationId?: UuidWithAggregatesFilter<"cropStakeholdersTable"> | string
    stakeholderTypeId?: UuidWithAggregatesFilter<"cropStakeholdersTable"> | string
  }

  export type cropTableWhereInput = {
    AND?: cropTableWhereInput | cropTableWhereInput[]
    OR?: cropTableWhereInput[]
    NOT?: cropTableWhereInput | cropTableWhereInput[]
    cropId?: UuidFilter<"cropTable"> | string
    cropName?: StringFilter<"cropTable"> | string
    speciesId?: UuidNullableFilter<"cropTable"> | string | null
    seedInfo?: StringNullableFilter<"cropTable"> | string | null
    cropStock?: StringNullableFilter<"cropTable"> | string | null
    createdAt?: DateTimeNullableFilter<"cropTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"cropTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"cropTable"> | string | null
    deleted?: BoolNullableFilter<"cropTable"> | boolean | null
    projectId?: UuidNullableFilter<"cropTable"> | string | null
    organizationId?: UuidNullableFilter<"cropTable"> | string | null
    cropNotes?: StringNullableFilter<"cropTable"> | string | null
    csvobjId?: UuidNullableFilter<"cropTable"> | string | null
    speciesTemp?: StringNullableFilter<"cropTable"> | string | null
    cropStakeholdersTable?: CropStakeholdersTableListRelationFilter
    csvObjTable?: XOR<CsvObjTableNullableScalarRelationFilter, csvObjTableWhereInput> | null
    organizationsTable?: XOR<OrganizationsTableNullableScalarRelationFilter, organizationsTableWhereInput> | null
    projectsTable?: XOR<ProjectsTableNullableScalarRelationFilter, projectsTableWhereInput> | null
    speciesTable?: XOR<SpeciesTableNullableScalarRelationFilter, speciesTableWhereInput> | null
    plantingTable?: PlantingTableListRelationFilter
  }

  export type cropTableOrderByWithRelationInput = {
    cropId?: SortOrder
    cropName?: SortOrder
    speciesId?: SortOrderInput | SortOrder
    seedInfo?: SortOrderInput | SortOrder
    cropStock?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    cropNotes?: SortOrderInput | SortOrder
    csvobjId?: SortOrderInput | SortOrder
    speciesTemp?: SortOrderInput | SortOrder
    cropStakeholdersTable?: cropStakeholdersTableOrderByRelationAggregateInput
    csvObjTable?: csvObjTableOrderByWithRelationInput
    organizationsTable?: organizationsTableOrderByWithRelationInput
    projectsTable?: projectsTableOrderByWithRelationInput
    speciesTable?: speciesTableOrderByWithRelationInput
    plantingTable?: plantingTableOrderByRelationAggregateInput
  }

  export type cropTableWhereUniqueInput = Prisma.AtLeast<{
    cropId?: string
    projectId_cropName?: cropTableProjectIdCropNameCompoundUniqueInput
    AND?: cropTableWhereInput | cropTableWhereInput[]
    OR?: cropTableWhereInput[]
    NOT?: cropTableWhereInput | cropTableWhereInput[]
    cropName?: StringFilter<"cropTable"> | string
    speciesId?: UuidNullableFilter<"cropTable"> | string | null
    seedInfo?: StringNullableFilter<"cropTable"> | string | null
    cropStock?: StringNullableFilter<"cropTable"> | string | null
    createdAt?: DateTimeNullableFilter<"cropTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"cropTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"cropTable"> | string | null
    deleted?: BoolNullableFilter<"cropTable"> | boolean | null
    projectId?: UuidNullableFilter<"cropTable"> | string | null
    organizationId?: UuidNullableFilter<"cropTable"> | string | null
    cropNotes?: StringNullableFilter<"cropTable"> | string | null
    csvobjId?: UuidNullableFilter<"cropTable"> | string | null
    speciesTemp?: StringNullableFilter<"cropTable"> | string | null
    cropStakeholdersTable?: CropStakeholdersTableListRelationFilter
    csvObjTable?: XOR<CsvObjTableNullableScalarRelationFilter, csvObjTableWhereInput> | null
    organizationsTable?: XOR<OrganizationsTableNullableScalarRelationFilter, organizationsTableWhereInput> | null
    projectsTable?: XOR<ProjectsTableNullableScalarRelationFilter, projectsTableWhereInput> | null
    speciesTable?: XOR<SpeciesTableNullableScalarRelationFilter, speciesTableWhereInput> | null
    plantingTable?: PlantingTableListRelationFilter
  }, "cropId" | "projectId_cropName">

  export type cropTableOrderByWithAggregationInput = {
    cropId?: SortOrder
    cropName?: SortOrder
    speciesId?: SortOrderInput | SortOrder
    seedInfo?: SortOrderInput | SortOrder
    cropStock?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    cropNotes?: SortOrderInput | SortOrder
    csvobjId?: SortOrderInput | SortOrder
    speciesTemp?: SortOrderInput | SortOrder
    _count?: cropTableCountOrderByAggregateInput
    _max?: cropTableMaxOrderByAggregateInput
    _min?: cropTableMinOrderByAggregateInput
  }

  export type cropTableScalarWhereWithAggregatesInput = {
    AND?: cropTableScalarWhereWithAggregatesInput | cropTableScalarWhereWithAggregatesInput[]
    OR?: cropTableScalarWhereWithAggregatesInput[]
    NOT?: cropTableScalarWhereWithAggregatesInput | cropTableScalarWhereWithAggregatesInput[]
    cropId?: UuidWithAggregatesFilter<"cropTable"> | string
    cropName?: StringWithAggregatesFilter<"cropTable"> | string
    speciesId?: UuidNullableWithAggregatesFilter<"cropTable"> | string | null
    seedInfo?: StringNullableWithAggregatesFilter<"cropTable"> | string | null
    cropStock?: StringNullableWithAggregatesFilter<"cropTable"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"cropTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"cropTable"> | Date | string | null
    editedBy?: UuidNullableWithAggregatesFilter<"cropTable"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"cropTable"> | boolean | null
    projectId?: UuidNullableWithAggregatesFilter<"cropTable"> | string | null
    organizationId?: UuidNullableWithAggregatesFilter<"cropTable"> | string | null
    cropNotes?: StringNullableWithAggregatesFilter<"cropTable"> | string | null
    csvobjId?: UuidNullableWithAggregatesFilter<"cropTable"> | string | null
    speciesTemp?: StringNullableWithAggregatesFilter<"cropTable"> | string | null
  }

  export type csvObjTableWhereInput = {
    AND?: csvObjTableWhereInput | csvObjTableWhereInput[]
    OR?: csvObjTableWhereInput[]
    NOT?: csvObjTableWhereInput | csvObjTableWhereInput[]
    csvobjId?: UuidFilter<"csvObjTable"> | string
    jsonData?: JsonFilter<"csvObjTable">
    createdAt?: DateTimeNullableFilter<"csvObjTable"> | Date | string | null
    cropTable?: CropTableListRelationFilter
    landTable?: LandTableListRelationFilter
    metadataTable?: MetadataTableListRelationFilter
    projectsTable?: ProjectsTableListRelationFilter
  }

  export type csvObjTableOrderByWithRelationInput = {
    csvobjId?: SortOrder
    jsonData?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    cropTable?: cropTableOrderByRelationAggregateInput
    landTable?: landTableOrderByRelationAggregateInput
    metadataTable?: metadataTableOrderByRelationAggregateInput
    projectsTable?: projectsTableOrderByRelationAggregateInput
  }

  export type csvObjTableWhereUniqueInput = Prisma.AtLeast<{
    csvobjId?: string
    AND?: csvObjTableWhereInput | csvObjTableWhereInput[]
    OR?: csvObjTableWhereInput[]
    NOT?: csvObjTableWhereInput | csvObjTableWhereInput[]
    jsonData?: JsonFilter<"csvObjTable">
    createdAt?: DateTimeNullableFilter<"csvObjTable"> | Date | string | null
    cropTable?: CropTableListRelationFilter
    landTable?: LandTableListRelationFilter
    metadataTable?: MetadataTableListRelationFilter
    projectsTable?: ProjectsTableListRelationFilter
  }, "csvobjId">

  export type csvObjTableOrderByWithAggregationInput = {
    csvobjId?: SortOrder
    jsonData?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: csvObjTableCountOrderByAggregateInput
    _max?: csvObjTableMaxOrderByAggregateInput
    _min?: csvObjTableMinOrderByAggregateInput
  }

  export type csvObjTableScalarWhereWithAggregatesInput = {
    AND?: csvObjTableScalarWhereWithAggregatesInput | csvObjTableScalarWhereWithAggregatesInput[]
    OR?: csvObjTableScalarWhereWithAggregatesInput[]
    NOT?: csvObjTableScalarWhereWithAggregatesInput | csvObjTableScalarWhereWithAggregatesInput[]
    csvobjId?: UuidWithAggregatesFilter<"csvObjTable"> | string
    jsonData?: JsonWithAggregatesFilter<"csvObjTable">
    createdAt?: DateTimeNullableWithAggregatesFilter<"csvObjTable"> | Date | string | null
  }

  export type landStakeholdersTableWhereInput = {
    AND?: landStakeholdersTableWhereInput | landStakeholdersTableWhereInput[]
    OR?: landStakeholdersTableWhereInput[]
    NOT?: landStakeholdersTableWhereInput | landStakeholdersTableWhereInput[]
    landStakeholderId?: UuidFilter<"landStakeholdersTable"> | string
    landId?: UuidFilter<"landStakeholdersTable"> | string
    organizationId?: UuidFilter<"landStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"landStakeholdersTable"> | string
    landTable?: XOR<LandTableScalarRelationFilter, landTableWhereInput>
    organizationsTable?: XOR<OrganizationsTableScalarRelationFilter, organizationsTableWhereInput>
    stakeholderTypesTable?: XOR<StakeholderTypesTableScalarRelationFilter, stakeholderTypesTableWhereInput>
  }

  export type landStakeholdersTableOrderByWithRelationInput = {
    landStakeholderId?: SortOrder
    landId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    landTable?: landTableOrderByWithRelationInput
    organizationsTable?: organizationsTableOrderByWithRelationInput
    stakeholderTypesTable?: stakeholderTypesTableOrderByWithRelationInput
  }

  export type landStakeholdersTableWhereUniqueInput = Prisma.AtLeast<{
    landStakeholderId?: string
    landId_organizationId_stakeholderTypeId?: landStakeholdersTableLandIdOrganizationIdStakeholderTypeIdCompoundUniqueInput
    AND?: landStakeholdersTableWhereInput | landStakeholdersTableWhereInput[]
    OR?: landStakeholdersTableWhereInput[]
    NOT?: landStakeholdersTableWhereInput | landStakeholdersTableWhereInput[]
    landId?: UuidFilter<"landStakeholdersTable"> | string
    organizationId?: UuidFilter<"landStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"landStakeholdersTable"> | string
    landTable?: XOR<LandTableScalarRelationFilter, landTableWhereInput>
    organizationsTable?: XOR<OrganizationsTableScalarRelationFilter, organizationsTableWhereInput>
    stakeholderTypesTable?: XOR<StakeholderTypesTableScalarRelationFilter, stakeholderTypesTableWhereInput>
  }, "landStakeholderId" | "landId_organizationId_stakeholderTypeId">

  export type landStakeholdersTableOrderByWithAggregationInput = {
    landStakeholderId?: SortOrder
    landId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    _count?: landStakeholdersTableCountOrderByAggregateInput
    _max?: landStakeholdersTableMaxOrderByAggregateInput
    _min?: landStakeholdersTableMinOrderByAggregateInput
  }

  export type landStakeholdersTableScalarWhereWithAggregatesInput = {
    AND?: landStakeholdersTableScalarWhereWithAggregatesInput | landStakeholdersTableScalarWhereWithAggregatesInput[]
    OR?: landStakeholdersTableScalarWhereWithAggregatesInput[]
    NOT?: landStakeholdersTableScalarWhereWithAggregatesInput | landStakeholdersTableScalarWhereWithAggregatesInput[]
    landStakeholderId?: UuidWithAggregatesFilter<"landStakeholdersTable"> | string
    landId?: UuidWithAggregatesFilter<"landStakeholdersTable"> | string
    organizationId?: UuidWithAggregatesFilter<"landStakeholdersTable"> | string
    stakeholderTypeId?: UuidWithAggregatesFilter<"landStakeholdersTable"> | string
  }

  export type landTableWhereInput = {
    AND?: landTableWhereInput | landTableWhereInput[]
    OR?: landTableWhereInput[]
    NOT?: landTableWhereInput | landTableWhereInput[]
    landId?: UuidFilter<"landTable"> | string
    landName?: StringFilter<"landTable"> | string
    projectId?: UuidNullableFilter<"landTable"> | string | null
    hectares?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLat?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLon?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    landNotes?: StringNullableFilter<"landTable"> | string | null
    createdAt?: DateTimeNullableFilter<"landTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"landTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"landTable"> | string | null
    deleted?: BoolNullableFilter<"landTable"> | boolean | null
    preparation?: EnumPreparationNullableFilter<"landTable"> | $Enums.Preparation | null
    csvobjId?: UuidNullableFilter<"landTable"> | string | null
    polygon?: JsonNullableFilter<"landTable">
    landStakeholdersTable?: LandStakeholdersTableListRelationFilter
    csvObjTable?: XOR<CsvObjTableNullableScalarRelationFilter, csvObjTableWhereInput> | null
    projectsTable?: XOR<ProjectsTableNullableScalarRelationFilter, projectsTableWhereInput> | null
    plantingTable?: PlantingTableListRelationFilter
  }

  export type landTableOrderByWithRelationInput = {
    landId?: SortOrder
    landName?: SortOrder
    projectId?: SortOrderInput | SortOrder
    hectares?: SortOrderInput | SortOrder
    gpsLat?: SortOrderInput | SortOrder
    gpsLon?: SortOrderInput | SortOrder
    landNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    preparation?: SortOrderInput | SortOrder
    csvobjId?: SortOrderInput | SortOrder
    polygon?: SortOrderInput | SortOrder
    landStakeholdersTable?: landStakeholdersTableOrderByRelationAggregateInput
    csvObjTable?: csvObjTableOrderByWithRelationInput
    projectsTable?: projectsTableOrderByWithRelationInput
    plantingTable?: plantingTableOrderByRelationAggregateInput
  }

  export type landTableWhereUniqueInput = Prisma.AtLeast<{
    landId?: string
    projectId_landName?: landTableProjectIdLandNameCompoundUniqueInput
    AND?: landTableWhereInput | landTableWhereInput[]
    OR?: landTableWhereInput[]
    NOT?: landTableWhereInput | landTableWhereInput[]
    landName?: StringFilter<"landTable"> | string
    projectId?: UuidNullableFilter<"landTable"> | string | null
    hectares?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLat?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLon?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    landNotes?: StringNullableFilter<"landTable"> | string | null
    createdAt?: DateTimeNullableFilter<"landTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"landTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"landTable"> | string | null
    deleted?: BoolNullableFilter<"landTable"> | boolean | null
    preparation?: EnumPreparationNullableFilter<"landTable"> | $Enums.Preparation | null
    csvobjId?: UuidNullableFilter<"landTable"> | string | null
    polygon?: JsonNullableFilter<"landTable">
    landStakeholdersTable?: LandStakeholdersTableListRelationFilter
    csvObjTable?: XOR<CsvObjTableNullableScalarRelationFilter, csvObjTableWhereInput> | null
    projectsTable?: XOR<ProjectsTableNullableScalarRelationFilter, projectsTableWhereInput> | null
    plantingTable?: PlantingTableListRelationFilter
  }, "landId" | "projectId_landName">

  export type landTableOrderByWithAggregationInput = {
    landId?: SortOrder
    landName?: SortOrder
    projectId?: SortOrderInput | SortOrder
    hectares?: SortOrderInput | SortOrder
    gpsLat?: SortOrderInput | SortOrder
    gpsLon?: SortOrderInput | SortOrder
    landNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    preparation?: SortOrderInput | SortOrder
    csvobjId?: SortOrderInput | SortOrder
    polygon?: SortOrderInput | SortOrder
    _count?: landTableCountOrderByAggregateInput
    _avg?: landTableAvgOrderByAggregateInput
    _max?: landTableMaxOrderByAggregateInput
    _min?: landTableMinOrderByAggregateInput
    _sum?: landTableSumOrderByAggregateInput
  }

  export type landTableScalarWhereWithAggregatesInput = {
    AND?: landTableScalarWhereWithAggregatesInput | landTableScalarWhereWithAggregatesInput[]
    OR?: landTableScalarWhereWithAggregatesInput[]
    NOT?: landTableScalarWhereWithAggregatesInput | landTableScalarWhereWithAggregatesInput[]
    landId?: UuidWithAggregatesFilter<"landTable"> | string
    landName?: StringWithAggregatesFilter<"landTable"> | string
    projectId?: UuidNullableWithAggregatesFilter<"landTable"> | string | null
    hectares?: DecimalNullableWithAggregatesFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLat?: DecimalNullableWithAggregatesFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLon?: DecimalNullableWithAggregatesFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    landNotes?: StringNullableWithAggregatesFilter<"landTable"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"landTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"landTable"> | Date | string | null
    editedBy?: UuidNullableWithAggregatesFilter<"landTable"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"landTable"> | boolean | null
    preparation?: EnumPreparationNullableWithAggregatesFilter<"landTable"> | $Enums.Preparation | null
    csvobjId?: UuidNullableWithAggregatesFilter<"landTable"> | string | null
    polygon?: JsonNullableWithAggregatesFilter<"landTable">
  }

  export type metadataTableWhereInput = {
    AND?: metadataTableWhereInput | metadataTableWhereInput[]
    OR?: metadataTableWhereInput[]
    NOT?: metadataTableWhereInput | metadataTableWhereInput[]
    metadataId?: UuidFilter<"metadataTable"> | string
    csvobjId?: UuidFilter<"metadataTable"> | string
    csvKey?: StringFilter<"metadataTable"> | string
    dbKey?: StringFilter<"metadataTable"> | string
    createdAt?: DateTimeNullableFilter<"metadataTable"> | Date | string | null
    csvObjTable?: XOR<CsvObjTableScalarRelationFilter, csvObjTableWhereInput>
  }

  export type metadataTableOrderByWithRelationInput = {
    metadataId?: SortOrder
    csvobjId?: SortOrder
    csvKey?: SortOrder
    dbKey?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    csvObjTable?: csvObjTableOrderByWithRelationInput
  }

  export type metadataTableWhereUniqueInput = Prisma.AtLeast<{
    metadataId?: string
    AND?: metadataTableWhereInput | metadataTableWhereInput[]
    OR?: metadataTableWhereInput[]
    NOT?: metadataTableWhereInput | metadataTableWhereInput[]
    csvobjId?: UuidFilter<"metadataTable"> | string
    csvKey?: StringFilter<"metadataTable"> | string
    dbKey?: StringFilter<"metadataTable"> | string
    createdAt?: DateTimeNullableFilter<"metadataTable"> | Date | string | null
    csvObjTable?: XOR<CsvObjTableScalarRelationFilter, csvObjTableWhereInput>
  }, "metadataId">

  export type metadataTableOrderByWithAggregationInput = {
    metadataId?: SortOrder
    csvobjId?: SortOrder
    csvKey?: SortOrder
    dbKey?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: metadataTableCountOrderByAggregateInput
    _max?: metadataTableMaxOrderByAggregateInput
    _min?: metadataTableMinOrderByAggregateInput
  }

  export type metadataTableScalarWhereWithAggregatesInput = {
    AND?: metadataTableScalarWhereWithAggregatesInput | metadataTableScalarWhereWithAggregatesInput[]
    OR?: metadataTableScalarWhereWithAggregatesInput[]
    NOT?: metadataTableScalarWhereWithAggregatesInput | metadataTableScalarWhereWithAggregatesInput[]
    metadataId?: UuidWithAggregatesFilter<"metadataTable"> | string
    csvobjId?: UuidWithAggregatesFilter<"metadataTable"> | string
    csvKey?: StringWithAggregatesFilter<"metadataTable"> | string
    dbKey?: StringWithAggregatesFilter<"metadataTable"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"metadataTable"> | Date | string | null
  }

  export type nurseryTableWhereInput = {
    AND?: nurseryTableWhereInput | nurseryTableWhereInput[]
    OR?: nurseryTableWhereInput[]
    NOT?: nurseryTableWhereInput | nurseryTableWhereInput[]
    nurseryId?: UuidFilter<"nurseryTable"> | string
    gpsLat?: FloatFilter<"nurseryTable"> | number
    gpsLon?: FloatFilter<"nurseryTable"> | number
    capacity?: IntFilter<"nurseryTable"> | number
    nurseryNotes?: StringNullableFilter<"nurseryTable"> | string | null
    tradeName?: StringFilter<"nurseryTable"> | string
    createdAt?: DateTimeNullableFilter<"nurseryTable"> | Date | string | null
    createdBy?: UuidFilter<"nurseryTable"> | string
    lastEditedAt?: DateTimeNullableFilter<"nurseryTable"> | Date | string | null
  }

  export type nurseryTableOrderByWithRelationInput = {
    nurseryId?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    capacity?: SortOrder
    nurseryNotes?: SortOrderInput | SortOrder
    tradeName?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
  }

  export type nurseryTableWhereUniqueInput = Prisma.AtLeast<{
    nurseryId?: string
    AND?: nurseryTableWhereInput | nurseryTableWhereInput[]
    OR?: nurseryTableWhereInput[]
    NOT?: nurseryTableWhereInput | nurseryTableWhereInput[]
    gpsLat?: FloatFilter<"nurseryTable"> | number
    gpsLon?: FloatFilter<"nurseryTable"> | number
    capacity?: IntFilter<"nurseryTable"> | number
    nurseryNotes?: StringNullableFilter<"nurseryTable"> | string | null
    tradeName?: StringFilter<"nurseryTable"> | string
    createdAt?: DateTimeNullableFilter<"nurseryTable"> | Date | string | null
    createdBy?: UuidFilter<"nurseryTable"> | string
    lastEditedAt?: DateTimeNullableFilter<"nurseryTable"> | Date | string | null
  }, "nurseryId">

  export type nurseryTableOrderByWithAggregationInput = {
    nurseryId?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    capacity?: SortOrder
    nurseryNotes?: SortOrderInput | SortOrder
    tradeName?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    _count?: nurseryTableCountOrderByAggregateInput
    _avg?: nurseryTableAvgOrderByAggregateInput
    _max?: nurseryTableMaxOrderByAggregateInput
    _min?: nurseryTableMinOrderByAggregateInput
    _sum?: nurseryTableSumOrderByAggregateInput
  }

  export type nurseryTableScalarWhereWithAggregatesInput = {
    AND?: nurseryTableScalarWhereWithAggregatesInput | nurseryTableScalarWhereWithAggregatesInput[]
    OR?: nurseryTableScalarWhereWithAggregatesInput[]
    NOT?: nurseryTableScalarWhereWithAggregatesInput | nurseryTableScalarWhereWithAggregatesInput[]
    nurseryId?: UuidWithAggregatesFilter<"nurseryTable"> | string
    gpsLat?: FloatWithAggregatesFilter<"nurseryTable"> | number
    gpsLon?: FloatWithAggregatesFilter<"nurseryTable"> | number
    capacity?: IntWithAggregatesFilter<"nurseryTable"> | number
    nurseryNotes?: StringNullableWithAggregatesFilter<"nurseryTable"> | string | null
    tradeName?: StringWithAggregatesFilter<"nurseryTable"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"nurseryTable"> | Date | string | null
    createdBy?: UuidWithAggregatesFilter<"nurseryTable"> | string
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"nurseryTable"> | Date | string | null
  }

  export type organizationsTableWhereInput = {
    AND?: organizationsTableWhereInput | organizationsTableWhereInput[]
    OR?: organizationsTableWhereInput[]
    NOT?: organizationsTableWhereInput | organizationsTableWhereInput[]
    organizationId?: UuidFilter<"organizationsTable"> | string
    organizationName?: StringFilter<"organizationsTable"> | string
    contactName?: StringNullableFilter<"organizationsTable"> | string | null
    contactEmail?: StringNullableFilter<"organizationsTable"> | string | null
    contactPhone?: StringNullableFilter<"organizationsTable"> | string | null
    address?: StringNullableFilter<"organizationsTable"> | string | null
    website?: StringNullableFilter<"organizationsTable"> | string | null
    organizationNotes?: StringNullableFilter<"organizationsTable"> | string | null
    createdAt?: DateTimeNullableFilter<"organizationsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"organizationsTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"organizationsTable"> | string | null
    deleted?: BoolNullableFilter<"organizationsTable"> | boolean | null
    gpsLat?: FloatNullableFilter<"organizationsTable"> | number | null
    gpsLon?: FloatNullableFilter<"organizationsTable"> | number | null
    stakeholderTypeId?: UuidNullableFilter<"organizationsTable"> | string | null
    cropStakeholdersTable?: CropStakeholdersTableListRelationFilter
    cropTable?: CropTableListRelationFilter
    landStakeholdersTable?: LandStakeholdersTableListRelationFilter
    stakeholderTypesTable?: XOR<StakeholderTypesTableNullableScalarRelationFilter, stakeholderTypesTableWhereInput> | null
    profilesTable?: ProfilesTableListRelationFilter
    projectStakeholdersTable?: ProjectStakeholdersTableListRelationFilter
  }

  export type organizationsTableOrderByWithRelationInput = {
    organizationId?: SortOrder
    organizationName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    organizationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    gpsLat?: SortOrderInput | SortOrder
    gpsLon?: SortOrderInput | SortOrder
    stakeholderTypeId?: SortOrderInput | SortOrder
    cropStakeholdersTable?: cropStakeholdersTableOrderByRelationAggregateInput
    cropTable?: cropTableOrderByRelationAggregateInput
    landStakeholdersTable?: landStakeholdersTableOrderByRelationAggregateInput
    stakeholderTypesTable?: stakeholderTypesTableOrderByWithRelationInput
    profilesTable?: profilesTableOrderByRelationAggregateInput
    projectStakeholdersTable?: projectStakeholdersTableOrderByRelationAggregateInput
  }

  export type organizationsTableWhereUniqueInput = Prisma.AtLeast<{
    organizationId?: string
    organizationName?: string
    AND?: organizationsTableWhereInput | organizationsTableWhereInput[]
    OR?: organizationsTableWhereInput[]
    NOT?: organizationsTableWhereInput | organizationsTableWhereInput[]
    contactName?: StringNullableFilter<"organizationsTable"> | string | null
    contactEmail?: StringNullableFilter<"organizationsTable"> | string | null
    contactPhone?: StringNullableFilter<"organizationsTable"> | string | null
    address?: StringNullableFilter<"organizationsTable"> | string | null
    website?: StringNullableFilter<"organizationsTable"> | string | null
    organizationNotes?: StringNullableFilter<"organizationsTable"> | string | null
    createdAt?: DateTimeNullableFilter<"organizationsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"organizationsTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"organizationsTable"> | string | null
    deleted?: BoolNullableFilter<"organizationsTable"> | boolean | null
    gpsLat?: FloatNullableFilter<"organizationsTable"> | number | null
    gpsLon?: FloatNullableFilter<"organizationsTable"> | number | null
    stakeholderTypeId?: UuidNullableFilter<"organizationsTable"> | string | null
    cropStakeholdersTable?: CropStakeholdersTableListRelationFilter
    cropTable?: CropTableListRelationFilter
    landStakeholdersTable?: LandStakeholdersTableListRelationFilter
    stakeholderTypesTable?: XOR<StakeholderTypesTableNullableScalarRelationFilter, stakeholderTypesTableWhereInput> | null
    profilesTable?: ProfilesTableListRelationFilter
    projectStakeholdersTable?: ProjectStakeholdersTableListRelationFilter
  }, "organizationId" | "organizationName">

  export type organizationsTableOrderByWithAggregationInput = {
    organizationId?: SortOrder
    organizationName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    organizationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    gpsLat?: SortOrderInput | SortOrder
    gpsLon?: SortOrderInput | SortOrder
    stakeholderTypeId?: SortOrderInput | SortOrder
    _count?: organizationsTableCountOrderByAggregateInput
    _avg?: organizationsTableAvgOrderByAggregateInput
    _max?: organizationsTableMaxOrderByAggregateInput
    _min?: organizationsTableMinOrderByAggregateInput
    _sum?: organizationsTableSumOrderByAggregateInput
  }

  export type organizationsTableScalarWhereWithAggregatesInput = {
    AND?: organizationsTableScalarWhereWithAggregatesInput | organizationsTableScalarWhereWithAggregatesInput[]
    OR?: organizationsTableScalarWhereWithAggregatesInput[]
    NOT?: organizationsTableScalarWhereWithAggregatesInput | organizationsTableScalarWhereWithAggregatesInput[]
    organizationId?: UuidWithAggregatesFilter<"organizationsTable"> | string
    organizationName?: StringWithAggregatesFilter<"organizationsTable"> | string
    contactName?: StringNullableWithAggregatesFilter<"organizationsTable"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"organizationsTable"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"organizationsTable"> | string | null
    address?: StringNullableWithAggregatesFilter<"organizationsTable"> | string | null
    website?: StringNullableWithAggregatesFilter<"organizationsTable"> | string | null
    organizationNotes?: StringNullableWithAggregatesFilter<"organizationsTable"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"organizationsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"organizationsTable"> | Date | string | null
    editedBy?: UuidNullableWithAggregatesFilter<"organizationsTable"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"organizationsTable"> | boolean | null
    gpsLat?: FloatNullableWithAggregatesFilter<"organizationsTable"> | number | null
    gpsLon?: FloatNullableWithAggregatesFilter<"organizationsTable"> | number | null
    stakeholderTypeId?: UuidNullableWithAggregatesFilter<"organizationsTable"> | string | null
  }

  export type plantingTableWhereInput = {
    AND?: plantingTableWhereInput | plantingTableWhereInput[]
    OR?: plantingTableWhereInput[]
    NOT?: plantingTableWhereInput | plantingTableWhereInput[]
    plantingId?: UuidFilter<"plantingTable"> | string
    landId?: UuidNullableFilter<"plantingTable"> | string | null
    planted?: IntNullableFilter<"plantingTable"> | number | null
    plantingDate?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    deleted?: BoolNullableFilter<"plantingTable"> | boolean | null
    cropId?: UuidNullableFilter<"plantingTable"> | string | null
    plantingNotes?: StringNullableFilter<"plantingTable"> | string | null
    cropTable?: XOR<CropTableNullableScalarRelationFilter, cropTableWhereInput> | null
    landTable?: XOR<LandTableNullableScalarRelationFilter, landTableWhereInput> | null
  }

  export type plantingTableOrderByWithRelationInput = {
    plantingId?: SortOrder
    landId?: SortOrderInput | SortOrder
    planted?: SortOrderInput | SortOrder
    plantingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    cropId?: SortOrderInput | SortOrder
    plantingNotes?: SortOrderInput | SortOrder
    cropTable?: cropTableOrderByWithRelationInput
    landTable?: landTableOrderByWithRelationInput
  }

  export type plantingTableWhereUniqueInput = Prisma.AtLeast<{
    plantingId?: string
    landId_cropId?: plantingTableLandIdCropIdCompoundUniqueInput
    AND?: plantingTableWhereInput | plantingTableWhereInput[]
    OR?: plantingTableWhereInput[]
    NOT?: plantingTableWhereInput | plantingTableWhereInput[]
    landId?: UuidNullableFilter<"plantingTable"> | string | null
    planted?: IntNullableFilter<"plantingTable"> | number | null
    plantingDate?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    deleted?: BoolNullableFilter<"plantingTable"> | boolean | null
    cropId?: UuidNullableFilter<"plantingTable"> | string | null
    plantingNotes?: StringNullableFilter<"plantingTable"> | string | null
    cropTable?: XOR<CropTableNullableScalarRelationFilter, cropTableWhereInput> | null
    landTable?: XOR<LandTableNullableScalarRelationFilter, landTableWhereInput> | null
  }, "plantingId" | "landId_cropId">

  export type plantingTableOrderByWithAggregationInput = {
    plantingId?: SortOrder
    landId?: SortOrderInput | SortOrder
    planted?: SortOrderInput | SortOrder
    plantingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    cropId?: SortOrderInput | SortOrder
    plantingNotes?: SortOrderInput | SortOrder
    _count?: plantingTableCountOrderByAggregateInput
    _avg?: plantingTableAvgOrderByAggregateInput
    _max?: plantingTableMaxOrderByAggregateInput
    _min?: plantingTableMinOrderByAggregateInput
    _sum?: plantingTableSumOrderByAggregateInput
  }

  export type plantingTableScalarWhereWithAggregatesInput = {
    AND?: plantingTableScalarWhereWithAggregatesInput | plantingTableScalarWhereWithAggregatesInput[]
    OR?: plantingTableScalarWhereWithAggregatesInput[]
    NOT?: plantingTableScalarWhereWithAggregatesInput | plantingTableScalarWhereWithAggregatesInput[]
    plantingId?: UuidWithAggregatesFilter<"plantingTable"> | string
    landId?: UuidNullableWithAggregatesFilter<"plantingTable"> | string | null
    planted?: IntNullableWithAggregatesFilter<"plantingTable"> | number | null
    plantingDate?: DateTimeNullableWithAggregatesFilter<"plantingTable"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"plantingTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"plantingTable"> | Date | string | null
    deleted?: BoolNullableWithAggregatesFilter<"plantingTable"> | boolean | null
    cropId?: UuidNullableWithAggregatesFilter<"plantingTable"> | string | null
    plantingNotes?: StringNullableWithAggregatesFilter<"plantingTable"> | string | null
  }

  export type profilesTableWhereInput = {
    AND?: profilesTableWhereInput | profilesTableWhereInput[]
    OR?: profilesTableWhereInput[]
    NOT?: profilesTableWhereInput | profilesTableWhereInput[]
    id?: UuidFilter<"profilesTable"> | string
    user_id?: UuidFilter<"profilesTable"> | string
    firstname?: StringFilter<"profilesTable"> | string
    lastname?: StringFilter<"profilesTable"> | string
    phonenumber?: StringNullableFilter<"profilesTable"> | string | null
    isactive?: BoolNullableFilter<"profilesTable"> | boolean | null
    isverified?: BoolNullableFilter<"profilesTable"> | boolean | null
    role?: Enumuser_roleNullableFilter<"profilesTable"> | $Enums.user_role | null
    permissions?: JsonNullableFilter<"profilesTable">
    createdat?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    lastlogin?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    twofactorenabled?: BoolNullableFilter<"profilesTable"> | boolean | null
    twofactorsecret?: StringNullableFilter<"profilesTable"> | string | null
    organizationid?: UuidNullableFilter<"profilesTable"> | string | null
    locale?: StringNullableFilter<"profilesTable"> | string | null
    timezone?: StringNullableFilter<"profilesTable"> | string | null
    organizationsTable?: XOR<OrganizationsTableNullableScalarRelationFilter, organizationsTableWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type profilesTableOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrderInput | SortOrder
    isactive?: SortOrderInput | SortOrder
    isverified?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    lastlogin?: SortOrderInput | SortOrder
    twofactorenabled?: SortOrderInput | SortOrder
    twofactorsecret?: SortOrderInput | SortOrder
    organizationid?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    organizationsTable?: organizationsTableOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type profilesTableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: profilesTableWhereInput | profilesTableWhereInput[]
    OR?: profilesTableWhereInput[]
    NOT?: profilesTableWhereInput | profilesTableWhereInput[]
    firstname?: StringFilter<"profilesTable"> | string
    lastname?: StringFilter<"profilesTable"> | string
    phonenumber?: StringNullableFilter<"profilesTable"> | string | null
    isactive?: BoolNullableFilter<"profilesTable"> | boolean | null
    isverified?: BoolNullableFilter<"profilesTable"> | boolean | null
    role?: Enumuser_roleNullableFilter<"profilesTable"> | $Enums.user_role | null
    permissions?: JsonNullableFilter<"profilesTable">
    createdat?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    lastlogin?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    twofactorenabled?: BoolNullableFilter<"profilesTable"> | boolean | null
    twofactorsecret?: StringNullableFilter<"profilesTable"> | string | null
    organizationid?: UuidNullableFilter<"profilesTable"> | string | null
    locale?: StringNullableFilter<"profilesTable"> | string | null
    timezone?: StringNullableFilter<"profilesTable"> | string | null
    organizationsTable?: XOR<OrganizationsTableNullableScalarRelationFilter, organizationsTableWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "user_id">

  export type profilesTableOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrderInput | SortOrder
    isactive?: SortOrderInput | SortOrder
    isverified?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    lastlogin?: SortOrderInput | SortOrder
    twofactorenabled?: SortOrderInput | SortOrder
    twofactorsecret?: SortOrderInput | SortOrder
    organizationid?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    _count?: profilesTableCountOrderByAggregateInput
    _max?: profilesTableMaxOrderByAggregateInput
    _min?: profilesTableMinOrderByAggregateInput
  }

  export type profilesTableScalarWhereWithAggregatesInput = {
    AND?: profilesTableScalarWhereWithAggregatesInput | profilesTableScalarWhereWithAggregatesInput[]
    OR?: profilesTableScalarWhereWithAggregatesInput[]
    NOT?: profilesTableScalarWhereWithAggregatesInput | profilesTableScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"profilesTable"> | string
    user_id?: UuidWithAggregatesFilter<"profilesTable"> | string
    firstname?: StringWithAggregatesFilter<"profilesTable"> | string
    lastname?: StringWithAggregatesFilter<"profilesTable"> | string
    phonenumber?: StringNullableWithAggregatesFilter<"profilesTable"> | string | null
    isactive?: BoolNullableWithAggregatesFilter<"profilesTable"> | boolean | null
    isverified?: BoolNullableWithAggregatesFilter<"profilesTable"> | boolean | null
    role?: Enumuser_roleNullableWithAggregatesFilter<"profilesTable"> | $Enums.user_role | null
    permissions?: JsonNullableWithAggregatesFilter<"profilesTable">
    createdat?: DateTimeNullableWithAggregatesFilter<"profilesTable"> | Date | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"profilesTable"> | Date | string | null
    lastlogin?: DateTimeNullableWithAggregatesFilter<"profilesTable"> | Date | string | null
    twofactorenabled?: BoolNullableWithAggregatesFilter<"profilesTable"> | boolean | null
    twofactorsecret?: StringNullableWithAggregatesFilter<"profilesTable"> | string | null
    organizationid?: UuidNullableWithAggregatesFilter<"profilesTable"> | string | null
    locale?: StringNullableWithAggregatesFilter<"profilesTable"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"profilesTable"> | string | null
  }

  export type projectStakeholdersTableWhereInput = {
    AND?: projectStakeholdersTableWhereInput | projectStakeholdersTableWhereInput[]
    OR?: projectStakeholdersTableWhereInput[]
    NOT?: projectStakeholdersTableWhereInput | projectStakeholdersTableWhereInput[]
    stakeholderId?: UuidFilter<"projectStakeholdersTable"> | string
    organizationId?: UuidFilter<"projectStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"projectStakeholdersTable"> | string
    projectId?: UuidFilter<"projectStakeholdersTable"> | string
    organizationsTable?: XOR<OrganizationsTableScalarRelationFilter, organizationsTableWhereInput>
    projectsTable?: XOR<ProjectsTableScalarRelationFilter, projectsTableWhereInput>
    stakeholderTypesTable?: XOR<StakeholderTypesTableScalarRelationFilter, stakeholderTypesTableWhereInput>
  }

  export type projectStakeholdersTableOrderByWithRelationInput = {
    stakeholderId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    projectId?: SortOrder
    organizationsTable?: organizationsTableOrderByWithRelationInput
    projectsTable?: projectsTableOrderByWithRelationInput
    stakeholderTypesTable?: stakeholderTypesTableOrderByWithRelationInput
  }

  export type projectStakeholdersTableWhereUniqueInput = Prisma.AtLeast<{
    stakeholderId?: string
    organizationId_stakeholderTypeId_projectId?: projectStakeholdersTableOrganizationIdStakeholderTypeIdProjectIdCompoundUniqueInput
    AND?: projectStakeholdersTableWhereInput | projectStakeholdersTableWhereInput[]
    OR?: projectStakeholdersTableWhereInput[]
    NOT?: projectStakeholdersTableWhereInput | projectStakeholdersTableWhereInput[]
    organizationId?: UuidFilter<"projectStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"projectStakeholdersTable"> | string
    projectId?: UuidFilter<"projectStakeholdersTable"> | string
    organizationsTable?: XOR<OrganizationsTableScalarRelationFilter, organizationsTableWhereInput>
    projectsTable?: XOR<ProjectsTableScalarRelationFilter, projectsTableWhereInput>
    stakeholderTypesTable?: XOR<StakeholderTypesTableScalarRelationFilter, stakeholderTypesTableWhereInput>
  }, "stakeholderId" | "organizationId_stakeholderTypeId_projectId">

  export type projectStakeholdersTableOrderByWithAggregationInput = {
    stakeholderId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    projectId?: SortOrder
    _count?: projectStakeholdersTableCountOrderByAggregateInput
    _max?: projectStakeholdersTableMaxOrderByAggregateInput
    _min?: projectStakeholdersTableMinOrderByAggregateInput
  }

  export type projectStakeholdersTableScalarWhereWithAggregatesInput = {
    AND?: projectStakeholdersTableScalarWhereWithAggregatesInput | projectStakeholdersTableScalarWhereWithAggregatesInput[]
    OR?: projectStakeholdersTableScalarWhereWithAggregatesInput[]
    NOT?: projectStakeholdersTableScalarWhereWithAggregatesInput | projectStakeholdersTableScalarWhereWithAggregatesInput[]
    stakeholderId?: UuidWithAggregatesFilter<"projectStakeholdersTable"> | string
    organizationId?: UuidWithAggregatesFilter<"projectStakeholdersTable"> | string
    stakeholderTypeId?: UuidWithAggregatesFilter<"projectStakeholdersTable"> | string
    projectId?: UuidWithAggregatesFilter<"projectStakeholdersTable"> | string
  }

  export type projectsTableWhereInput = {
    AND?: projectsTableWhereInput | projectsTableWhereInput[]
    OR?: projectsTableWhereInput[]
    NOT?: projectsTableWhereInput | projectsTableWhereInput[]
    projectId?: UuidFilter<"projectsTable"> | string
    projectName?: StringFilter<"projectsTable"> | string
    projectNotes?: StringNullableFilter<"projectsTable"> | string | null
    createdAt?: DateTimeNullableFilter<"projectsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"projectsTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"projectsTable"> | string | null
    deleted?: BoolNullableFilter<"projectsTable"> | boolean | null
    csvobjId?: UuidNullableFilter<"projectsTable"> | string | null
    source?: StringNullableFilter<"projectsTable"> | string | null
    cropTable?: CropTableListRelationFilter
    landTable?: LandTableListRelationFilter
    projectStakeholdersTable?: ProjectStakeholdersTableListRelationFilter
    csvObjTable?: XOR<CsvObjTableNullableScalarRelationFilter, csvObjTableWhereInput> | null
  }

  export type projectsTableOrderByWithRelationInput = {
    projectId?: SortOrder
    projectName?: SortOrder
    projectNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    csvobjId?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    cropTable?: cropTableOrderByRelationAggregateInput
    landTable?: landTableOrderByRelationAggregateInput
    projectStakeholdersTable?: projectStakeholdersTableOrderByRelationAggregateInput
    csvObjTable?: csvObjTableOrderByWithRelationInput
  }

  export type projectsTableWhereUniqueInput = Prisma.AtLeast<{
    projectId?: string
    projectName?: string
    AND?: projectsTableWhereInput | projectsTableWhereInput[]
    OR?: projectsTableWhereInput[]
    NOT?: projectsTableWhereInput | projectsTableWhereInput[]
    projectNotes?: StringNullableFilter<"projectsTable"> | string | null
    createdAt?: DateTimeNullableFilter<"projectsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"projectsTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"projectsTable"> | string | null
    deleted?: BoolNullableFilter<"projectsTable"> | boolean | null
    csvobjId?: UuidNullableFilter<"projectsTable"> | string | null
    source?: StringNullableFilter<"projectsTable"> | string | null
    cropTable?: CropTableListRelationFilter
    landTable?: LandTableListRelationFilter
    projectStakeholdersTable?: ProjectStakeholdersTableListRelationFilter
    csvObjTable?: XOR<CsvObjTableNullableScalarRelationFilter, csvObjTableWhereInput> | null
  }, "projectId" | "projectName">

  export type projectsTableOrderByWithAggregationInput = {
    projectId?: SortOrder
    projectName?: SortOrder
    projectNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    csvobjId?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    _count?: projectsTableCountOrderByAggregateInput
    _max?: projectsTableMaxOrderByAggregateInput
    _min?: projectsTableMinOrderByAggregateInput
  }

  export type projectsTableScalarWhereWithAggregatesInput = {
    AND?: projectsTableScalarWhereWithAggregatesInput | projectsTableScalarWhereWithAggregatesInput[]
    OR?: projectsTableScalarWhereWithAggregatesInput[]
    NOT?: projectsTableScalarWhereWithAggregatesInput | projectsTableScalarWhereWithAggregatesInput[]
    projectId?: UuidWithAggregatesFilter<"projectsTable"> | string
    projectName?: StringWithAggregatesFilter<"projectsTable"> | string
    projectNotes?: StringNullableWithAggregatesFilter<"projectsTable"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"projectsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"projectsTable"> | Date | string | null
    editedBy?: UuidNullableWithAggregatesFilter<"projectsTable"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"projectsTable"> | boolean | null
    csvobjId?: UuidNullableWithAggregatesFilter<"projectsTable"> | string | null
    source?: StringNullableWithAggregatesFilter<"projectsTable"> | string | null
  }

  export type speciesTableWhereInput = {
    AND?: speciesTableWhereInput | speciesTableWhereInput[]
    OR?: speciesTableWhereInput[]
    NOT?: speciesTableWhereInput | speciesTableWhereInput[]
    speciesId?: UuidFilter<"speciesTable"> | string
    commonName?: StringFilter<"speciesTable"> | string
    scientificName?: StringNullableFilter<"speciesTable"> | string | null
    type?: StringNullableFilter<"speciesTable"> | string | null
    family?: StringNullableFilter<"speciesTable"> | string | null
    reference?: StringNullableFilter<"speciesTable"> | string | null
    createdAt?: DateTimeNullableFilter<"speciesTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"speciesTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"speciesTable"> | string | null
    deleted?: BoolNullableFilter<"speciesTable"> | boolean | null
    cropTable?: CropTableListRelationFilter
  }

  export type speciesTableOrderByWithRelationInput = {
    speciesId?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    family?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    cropTable?: cropTableOrderByRelationAggregateInput
  }

  export type speciesTableWhereUniqueInput = Prisma.AtLeast<{
    speciesId?: string
    commonName?: string
    AND?: speciesTableWhereInput | speciesTableWhereInput[]
    OR?: speciesTableWhereInput[]
    NOT?: speciesTableWhereInput | speciesTableWhereInput[]
    scientificName?: StringNullableFilter<"speciesTable"> | string | null
    type?: StringNullableFilter<"speciesTable"> | string | null
    family?: StringNullableFilter<"speciesTable"> | string | null
    reference?: StringNullableFilter<"speciesTable"> | string | null
    createdAt?: DateTimeNullableFilter<"speciesTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"speciesTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"speciesTable"> | string | null
    deleted?: BoolNullableFilter<"speciesTable"> | boolean | null
    cropTable?: CropTableListRelationFilter
  }, "speciesId" | "commonName">

  export type speciesTableOrderByWithAggregationInput = {
    speciesId?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    family?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    editedBy?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    _count?: speciesTableCountOrderByAggregateInput
    _max?: speciesTableMaxOrderByAggregateInput
    _min?: speciesTableMinOrderByAggregateInput
  }

  export type speciesTableScalarWhereWithAggregatesInput = {
    AND?: speciesTableScalarWhereWithAggregatesInput | speciesTableScalarWhereWithAggregatesInput[]
    OR?: speciesTableScalarWhereWithAggregatesInput[]
    NOT?: speciesTableScalarWhereWithAggregatesInput | speciesTableScalarWhereWithAggregatesInput[]
    speciesId?: UuidWithAggregatesFilter<"speciesTable"> | string
    commonName?: StringWithAggregatesFilter<"speciesTable"> | string
    scientificName?: StringNullableWithAggregatesFilter<"speciesTable"> | string | null
    type?: StringNullableWithAggregatesFilter<"speciesTable"> | string | null
    family?: StringNullableWithAggregatesFilter<"speciesTable"> | string | null
    reference?: StringNullableWithAggregatesFilter<"speciesTable"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"speciesTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"speciesTable"> | Date | string | null
    editedBy?: UuidNullableWithAggregatesFilter<"speciesTable"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"speciesTable"> | boolean | null
  }

  export type stakeholderTypesTableWhereInput = {
    AND?: stakeholderTypesTableWhereInput | stakeholderTypesTableWhereInput[]
    OR?: stakeholderTypesTableWhereInput[]
    NOT?: stakeholderTypesTableWhereInput | stakeholderTypesTableWhereInput[]
    stakeholderType?: StringFilter<"stakeholderTypesTable"> | string
    createdAt?: DateTimeNullableFilter<"stakeholderTypesTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"stakeholderTypesTable"> | Date | string | null
    deleted?: BoolNullableFilter<"stakeholderTypesTable"> | boolean | null
    stakeholderTypeId?: UuidFilter<"stakeholderTypesTable"> | string
    cropStakeholdersTable?: CropStakeholdersTableListRelationFilter
    landStakeholdersTable?: LandStakeholdersTableListRelationFilter
    organizationsTable?: OrganizationsTableListRelationFilter
    projectStakeholdersTable?: ProjectStakeholdersTableListRelationFilter
  }

  export type stakeholderTypesTableOrderByWithRelationInput = {
    stakeholderType?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    stakeholderTypeId?: SortOrder
    cropStakeholdersTable?: cropStakeholdersTableOrderByRelationAggregateInput
    landStakeholdersTable?: landStakeholdersTableOrderByRelationAggregateInput
    organizationsTable?: organizationsTableOrderByRelationAggregateInput
    projectStakeholdersTable?: projectStakeholdersTableOrderByRelationAggregateInput
  }

  export type stakeholderTypesTableWhereUniqueInput = Prisma.AtLeast<{
    stakeholderTypeId?: string
    AND?: stakeholderTypesTableWhereInput | stakeholderTypesTableWhereInput[]
    OR?: stakeholderTypesTableWhereInput[]
    NOT?: stakeholderTypesTableWhereInput | stakeholderTypesTableWhereInput[]
    stakeholderType?: StringFilter<"stakeholderTypesTable"> | string
    createdAt?: DateTimeNullableFilter<"stakeholderTypesTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"stakeholderTypesTable"> | Date | string | null
    deleted?: BoolNullableFilter<"stakeholderTypesTable"> | boolean | null
    cropStakeholdersTable?: CropStakeholdersTableListRelationFilter
    landStakeholdersTable?: LandStakeholdersTableListRelationFilter
    organizationsTable?: OrganizationsTableListRelationFilter
    projectStakeholdersTable?: ProjectStakeholdersTableListRelationFilter
  }, "stakeholderTypeId">

  export type stakeholderTypesTableOrderByWithAggregationInput = {
    stakeholderType?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    deleted?: SortOrderInput | SortOrder
    stakeholderTypeId?: SortOrder
    _count?: stakeholderTypesTableCountOrderByAggregateInput
    _max?: stakeholderTypesTableMaxOrderByAggregateInput
    _min?: stakeholderTypesTableMinOrderByAggregateInput
  }

  export type stakeholderTypesTableScalarWhereWithAggregatesInput = {
    AND?: stakeholderTypesTableScalarWhereWithAggregatesInput | stakeholderTypesTableScalarWhereWithAggregatesInput[]
    OR?: stakeholderTypesTableScalarWhereWithAggregatesInput[]
    NOT?: stakeholderTypesTableScalarWhereWithAggregatesInput | stakeholderTypesTableScalarWhereWithAggregatesInput[]
    stakeholderType?: StringWithAggregatesFilter<"stakeholderTypesTable"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"stakeholderTypesTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"stakeholderTypesTable"> | Date | string | null
    deleted?: BoolNullableWithAggregatesFilter<"stakeholderTypesTable"> | boolean | null
    stakeholderTypeId?: UuidWithAggregatesFilter<"stakeholderTypesTable"> | string
  }

  export type audit_log_entriesCreateInput = {
    instance_id?: string | null
    id: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    ip_address?: string
  }

  export type audit_log_entriesUncheckedCreateInput = {
    instance_id?: string | null
    id: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    ip_address?: string
  }

  export type audit_log_entriesUpdateInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
  }

  export type audit_log_entriesUncheckedUpdateInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
  }

  export type audit_log_entriesCreateManyInput = {
    instance_id?: string | null
    id: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    ip_address?: string
  }

  export type audit_log_entriesUpdateManyMutationInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
  }

  export type audit_log_entriesUncheckedUpdateManyInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
  }

  export type flow_stateCreateInput = {
    id: string
    user_id?: string | null
    auth_code: string
    code_challenge_method: $Enums.code_challenge_method
    code_challenge: string
    provider_type: string
    provider_access_token?: string | null
    provider_refresh_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    authentication_method: string
    auth_code_issued_at?: Date | string | null
    saml_relay_states?: saml_relay_statesCreateNestedManyWithoutFlow_stateInput
  }

  export type flow_stateUncheckedCreateInput = {
    id: string
    user_id?: string | null
    auth_code: string
    code_challenge_method: $Enums.code_challenge_method
    code_challenge: string
    provider_type: string
    provider_access_token?: string | null
    provider_refresh_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    authentication_method: string
    auth_code_issued_at?: Date | string | null
    saml_relay_states?: saml_relay_statesUncheckedCreateNestedManyWithoutFlow_stateInput
  }

  export type flow_stateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    auth_code?: StringFieldUpdateOperationsInput | string
    code_challenge_method?: Enumcode_challenge_methodFieldUpdateOperationsInput | $Enums.code_challenge_method
    code_challenge?: StringFieldUpdateOperationsInput | string
    provider_type?: StringFieldUpdateOperationsInput | string
    provider_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    provider_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authentication_method?: StringFieldUpdateOperationsInput | string
    auth_code_issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_relay_states?: saml_relay_statesUpdateManyWithoutFlow_stateNestedInput
  }

  export type flow_stateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    auth_code?: StringFieldUpdateOperationsInput | string
    code_challenge_method?: Enumcode_challenge_methodFieldUpdateOperationsInput | $Enums.code_challenge_method
    code_challenge?: StringFieldUpdateOperationsInput | string
    provider_type?: StringFieldUpdateOperationsInput | string
    provider_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    provider_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authentication_method?: StringFieldUpdateOperationsInput | string
    auth_code_issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_relay_states?: saml_relay_statesUncheckedUpdateManyWithoutFlow_stateNestedInput
  }

  export type flow_stateCreateManyInput = {
    id: string
    user_id?: string | null
    auth_code: string
    code_challenge_method: $Enums.code_challenge_method
    code_challenge: string
    provider_type: string
    provider_access_token?: string | null
    provider_refresh_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    authentication_method: string
    auth_code_issued_at?: Date | string | null
  }

  export type flow_stateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    auth_code?: StringFieldUpdateOperationsInput | string
    code_challenge_method?: Enumcode_challenge_methodFieldUpdateOperationsInput | $Enums.code_challenge_method
    code_challenge?: StringFieldUpdateOperationsInput | string
    provider_type?: StringFieldUpdateOperationsInput | string
    provider_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    provider_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authentication_method?: StringFieldUpdateOperationsInput | string
    auth_code_issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type flow_stateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    auth_code?: StringFieldUpdateOperationsInput | string
    code_challenge_method?: Enumcode_challenge_methodFieldUpdateOperationsInput | $Enums.code_challenge_method
    code_challenge?: StringFieldUpdateOperationsInput | string
    provider_type?: StringFieldUpdateOperationsInput | string
    provider_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    provider_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authentication_method?: StringFieldUpdateOperationsInput | string
    auth_code_issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type identitiesCreateInput = {
    provider_id: string
    identity_data: JsonNullValueInput | InputJsonValue
    provider: string
    last_sign_in_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    email?: string | null
    id?: string
    users: usersCreateNestedOneWithoutIdentitiesInput
  }

  export type identitiesUncheckedCreateInput = {
    provider_id: string
    user_id: string
    identity_data: JsonNullValueInput | InputJsonValue
    provider: string
    last_sign_in_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    email?: string | null
    id?: string
  }

  export type identitiesUpdateInput = {
    provider_id?: StringFieldUpdateOperationsInput | string
    identity_data?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutIdentitiesNestedInput
  }

  export type identitiesUncheckedUpdateInput = {
    provider_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    identity_data?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type identitiesCreateManyInput = {
    provider_id: string
    user_id: string
    identity_data: JsonNullValueInput | InputJsonValue
    provider: string
    last_sign_in_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    email?: string | null
    id?: string
  }

  export type identitiesUpdateManyMutationInput = {
    provider_id?: StringFieldUpdateOperationsInput | string
    identity_data?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type identitiesUncheckedUpdateManyInput = {
    provider_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    identity_data?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type instancesCreateInput = {
    id: string
    uuid?: string | null
    raw_base_config?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type instancesUncheckedCreateInput = {
    id: string
    uuid?: string | null
    raw_base_config?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type instancesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    raw_base_config?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type instancesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    raw_base_config?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type instancesCreateManyInput = {
    id: string
    uuid?: string | null
    raw_base_config?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type instancesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    raw_base_config?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type instancesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    raw_base_config?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mfa_amr_claimsCreateInput = {
    created_at: Date | string
    updated_at: Date | string
    authentication_method: string
    id: string
    sessions: sessionsCreateNestedOneWithoutMfa_amr_claimsInput
  }

  export type mfa_amr_claimsUncheckedCreateInput = {
    session_id: string
    created_at: Date | string
    updated_at: Date | string
    authentication_method: string
    id: string
  }

  export type mfa_amr_claimsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authentication_method?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    sessions?: sessionsUpdateOneRequiredWithoutMfa_amr_claimsNestedInput
  }

  export type mfa_amr_claimsUncheckedUpdateInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authentication_method?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type mfa_amr_claimsCreateManyInput = {
    session_id: string
    created_at: Date | string
    updated_at: Date | string
    authentication_method: string
    id: string
  }

  export type mfa_amr_claimsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authentication_method?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type mfa_amr_claimsUncheckedUpdateManyInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authentication_method?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type mfa_challengesCreateInput = {
    id: string
    created_at: Date | string
    verified_at?: Date | string | null
    ip_address: string
    otp_code?: string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
    mfa_factors: mfa_factorsCreateNestedOneWithoutMfa_challengesInput
  }

  export type mfa_challengesUncheckedCreateInput = {
    id: string
    factor_id: string
    created_at: Date | string
    verified_at?: Date | string | null
    ip_address: string
    otp_code?: string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
    otp_code?: NullableStringFieldUpdateOperationsInput | string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
    mfa_factors?: mfa_factorsUpdateOneRequiredWithoutMfa_challengesNestedInput
  }

  export type mfa_challengesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    factor_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
    otp_code?: NullableStringFieldUpdateOperationsInput | string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesCreateManyInput = {
    id: string
    factor_id: string
    created_at: Date | string
    verified_at?: Date | string | null
    ip_address: string
    otp_code?: string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
    otp_code?: NullableStringFieldUpdateOperationsInput | string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    factor_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
    otp_code?: NullableStringFieldUpdateOperationsInput | string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_factorsCreateInput = {
    id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
    mfa_challenges?: mfa_challengesCreateNestedManyWithoutMfa_factorsInput
    users: usersCreateNestedOneWithoutMfa_factorsInput
  }

  export type mfa_factorsUncheckedCreateInput = {
    id: string
    user_id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
    mfa_challenges?: mfa_challengesUncheckedCreateNestedManyWithoutMfa_factorsInput
  }

  export type mfa_factorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_challenges?: mfa_challengesUpdateManyWithoutMfa_factorsNestedInput
    users?: usersUpdateOneRequiredWithoutMfa_factorsNestedInput
  }

  export type mfa_factorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_challenges?: mfa_challengesUncheckedUpdateManyWithoutMfa_factorsNestedInput
  }

  export type mfa_factorsCreateManyInput = {
    id: string
    user_id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
  }

  export type mfa_factorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mfa_factorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type one_time_tokensCreateInput = {
    id: string
    token_type: $Enums.one_time_token_type
    token_hash: string
    relates_to: string
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutOne_time_tokensInput
  }

  export type one_time_tokensUncheckedCreateInput = {
    id: string
    user_id: string
    token_type: $Enums.one_time_token_type
    token_hash: string
    relates_to: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type one_time_tokensUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token_type?: Enumone_time_token_typeFieldUpdateOperationsInput | $Enums.one_time_token_type
    token_hash?: StringFieldUpdateOperationsInput | string
    relates_to?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutOne_time_tokensNestedInput
  }

  export type one_time_tokensUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    token_type?: Enumone_time_token_typeFieldUpdateOperationsInput | $Enums.one_time_token_type
    token_hash?: StringFieldUpdateOperationsInput | string
    relates_to?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type one_time_tokensCreateManyInput = {
    id: string
    user_id: string
    token_type: $Enums.one_time_token_type
    token_hash: string
    relates_to: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type one_time_tokensUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token_type?: Enumone_time_token_typeFieldUpdateOperationsInput | $Enums.one_time_token_type
    token_hash?: StringFieldUpdateOperationsInput | string
    relates_to?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type one_time_tokensUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    token_type?: Enumone_time_token_typeFieldUpdateOperationsInput | $Enums.one_time_token_type
    token_hash?: StringFieldUpdateOperationsInput | string
    relates_to?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensCreateInput = {
    instance_id?: string | null
    id?: bigint | number
    token?: string | null
    user_id?: string | null
    revoked?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parent?: string | null
    sessions?: sessionsCreateNestedOneWithoutRefresh_tokensInput
  }

  export type refresh_tokensUncheckedCreateInput = {
    instance_id?: string | null
    id?: bigint | number
    token?: string | null
    user_id?: string | null
    revoked?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parent?: string | null
    session_id?: string | null
  }

  export type refresh_tokensUpdateInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: sessionsUpdateOneWithoutRefresh_tokensNestedInput
  }

  export type refresh_tokensUncheckedUpdateInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refresh_tokensCreateManyInput = {
    instance_id?: string | null
    id?: bigint | number
    token?: string | null
    user_id?: string | null
    revoked?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parent?: string | null
    session_id?: string | null
  }

  export type refresh_tokensUpdateManyMutationInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refresh_tokensUncheckedUpdateManyInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_providersCreateInput = {
    id: string
    entity_id: string
    metadata_xml: string
    metadata_url?: string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name_id_format?: string | null
    sso_providers: sso_providersCreateNestedOneWithoutSaml_providersInput
  }

  export type saml_providersUncheckedCreateInput = {
    id: string
    sso_provider_id: string
    entity_id: string
    metadata_xml: string
    metadata_url?: string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name_id_format?: string | null
  }

  export type saml_providersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    metadata_xml?: StringFieldUpdateOperationsInput | string
    metadata_url?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name_id_format?: NullableStringFieldUpdateOperationsInput | string | null
    sso_providers?: sso_providersUpdateOneRequiredWithoutSaml_providersNestedInput
  }

  export type saml_providersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    metadata_xml?: StringFieldUpdateOperationsInput | string
    metadata_url?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name_id_format?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_providersCreateManyInput = {
    id: string
    sso_provider_id: string
    entity_id: string
    metadata_xml: string
    metadata_url?: string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name_id_format?: string | null
  }

  export type saml_providersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    metadata_xml?: StringFieldUpdateOperationsInput | string
    metadata_url?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name_id_format?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_providersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    metadata_xml?: StringFieldUpdateOperationsInput | string
    metadata_url?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name_id_format?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_relay_statesCreateInput = {
    id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    flow_state?: flow_stateCreateNestedOneWithoutSaml_relay_statesInput
    sso_providers: sso_providersCreateNestedOneWithoutSaml_relay_statesInput
  }

  export type saml_relay_statesUncheckedCreateInput = {
    id: string
    sso_provider_id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    flow_state_id?: string | null
  }

  export type saml_relay_statesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow_state?: flow_stateUpdateOneWithoutSaml_relay_statesNestedInput
    sso_providers?: sso_providersUpdateOneRequiredWithoutSaml_relay_statesNestedInput
  }

  export type saml_relay_statesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow_state_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_relay_statesCreateManyInput = {
    id: string
    sso_provider_id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    flow_state_id?: string | null
  }

  export type saml_relay_statesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type saml_relay_statesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow_state_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type schema_migrationsCreateInput = {
    version: string
  }

  export type schema_migrationsUncheckedCreateInput = {
    version: string
  }

  export type schema_migrationsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsCreateManyInput = {
    version: string
  }

  export type schema_migrationsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsCreateInput = {
    id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    mfa_amr_claims?: mfa_amr_claimsCreateNestedManyWithoutSessionsInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutSessionsInput
    users: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    id: string
    user_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    mfa_amr_claims?: mfa_amr_claimsUncheckedCreateNestedManyWithoutSessionsInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_amr_claims?: mfa_amr_claimsUpdateManyWithoutSessionsNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutSessionsNestedInput
    users?: usersUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_amr_claims?: mfa_amr_claimsUncheckedUpdateManyWithoutSessionsNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsCreateManyInput = {
    id: string
    user_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
  }

  export type sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sso_domainsCreateInput = {
    id: string
    domain: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    sso_providers: sso_providersCreateNestedOneWithoutSso_domainsInput
  }

  export type sso_domainsUncheckedCreateInput = {
    id: string
    sso_provider_id: string
    domain: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sso_domainsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sso_providers?: sso_providersUpdateOneRequiredWithoutSso_domainsNestedInput
  }

  export type sso_domainsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sso_domainsCreateManyInput = {
    id: string
    sso_provider_id: string
    domain: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sso_domainsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sso_domainsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sso_providersCreateInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_providers?: saml_providersCreateNestedManyWithoutSso_providersInput
    saml_relay_states?: saml_relay_statesCreateNestedManyWithoutSso_providersInput
    sso_domains?: sso_domainsCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersUncheckedCreateInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_providers?: saml_providersUncheckedCreateNestedManyWithoutSso_providersInput
    saml_relay_states?: saml_relay_statesUncheckedCreateNestedManyWithoutSso_providersInput
    sso_domains?: sso_domainsUncheckedCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_providers?: saml_providersUpdateManyWithoutSso_providersNestedInput
    saml_relay_states?: saml_relay_statesUpdateManyWithoutSso_providersNestedInput
    sso_domains?: sso_domainsUpdateManyWithoutSso_providersNestedInput
  }

  export type sso_providersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_providers?: saml_providersUncheckedUpdateManyWithoutSso_providersNestedInput
    saml_relay_states?: saml_relay_statesUncheckedUpdateManyWithoutSso_providersNestedInput
    sso_domains?: sso_domainsUncheckedUpdateManyWithoutSso_providersNestedInput
  }

  export type sso_providersCreateManyInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sso_providersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sso_providersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesUncheckedCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsUncheckedCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersUpdateInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUncheckedUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUncheckedUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
  }

  export type usersUpdateManyMutationInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cropStakeholdersTableCreateInput = {
    cropStakeholderId?: string
    cropTable: cropTableCreateNestedOneWithoutCropStakeholdersTableInput
    organizationsTable: organizationsTableCreateNestedOneWithoutCropStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutCropStakeholdersTableInput
  }

  export type cropStakeholdersTableUncheckedCreateInput = {
    cropStakeholderId?: string
    cropId: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type cropStakeholdersTableUpdateInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropTable?: cropTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
  }

  export type cropStakeholdersTableUncheckedUpdateInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type cropStakeholdersTableCreateManyInput = {
    cropStakeholderId?: string
    cropId: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type cropStakeholdersTableUpdateManyMutationInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
  }

  export type cropStakeholdersTableUncheckedUpdateManyInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type cropTableCreateInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropNotes?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutCropTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutCropTableInput
    organizationsTable?: organizationsTableCreateNestedOneWithoutCropTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutCropTableInput
    speciesTable?: speciesTableCreateNestedOneWithoutCropTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutCropTableInput
  }

  export type cropTableUncheckedCreateInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutCropTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutCropTableInput
  }

  export type cropTableUpdateInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutCropTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutCropTableNestedInput
    organizationsTable?: organizationsTableUpdateOneWithoutCropTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutCropTableNestedInput
    speciesTable?: speciesTableUpdateOneWithoutCropTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutCropTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableCreateManyInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
  }

  export type cropTableUpdateManyMutationInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cropTableUncheckedUpdateManyInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type csvObjTableCreateInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableCreateNestedManyWithoutCsvObjTableInput
    landTable?: landTableCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableUncheckedCreateInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    landTable?: landTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableUncheckedCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableUpdateInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUpdateManyWithoutCsvObjTableNestedInput
    landTable?: landTableUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUpdateManyWithoutCsvObjTableNestedInput
  }

  export type csvObjTableUncheckedUpdateInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    landTable?: landTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
  }

  export type csvObjTableCreateManyInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type csvObjTableUpdateManyMutationInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type csvObjTableUncheckedUpdateManyInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type landStakeholdersTableCreateInput = {
    landStakeholderId?: string
    landTable: landTableCreateNestedOneWithoutLandStakeholdersTableInput
    organizationsTable: organizationsTableCreateNestedOneWithoutLandStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutLandStakeholdersTableInput
  }

  export type landStakeholdersTableUncheckedCreateInput = {
    landStakeholderId?: string
    landId: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type landStakeholdersTableUpdateInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landTable?: landTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
  }

  export type landStakeholdersTableUncheckedUpdateInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type landStakeholdersTableCreateManyInput = {
    landStakeholderId?: string
    landId: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type landStakeholdersTableUpdateManyMutationInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
  }

  export type landStakeholdersTableUncheckedUpdateManyInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type landTableCreateInput = {
    landId?: string
    landName: string
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutLandTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutLandTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutLandTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutLandTableInput
  }

  export type landTableUncheckedCreateInput = {
    landId?: string
    landName: string
    projectId?: string | null
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    csvobjId?: string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutLandTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutLandTableInput
  }

  export type landTableUpdateInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutLandTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutLandTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutLandTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutLandTableNestedInput
  }

  export type landTableUncheckedUpdateInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutLandTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutLandTableNestedInput
  }

  export type landTableCreateManyInput = {
    landId?: string
    landName: string
    projectId?: string | null
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    csvobjId?: string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
  }

  export type landTableUpdateManyMutationInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
  }

  export type landTableUncheckedUpdateManyInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
  }

  export type metadataTableCreateInput = {
    metadataId?: string
    csvKey: string
    dbKey: string
    createdAt?: Date | string | null
    csvObjTable: csvObjTableCreateNestedOneWithoutMetadataTableInput
  }

  export type metadataTableUncheckedCreateInput = {
    metadataId?: string
    csvobjId: string
    csvKey: string
    dbKey: string
    createdAt?: Date | string | null
  }

  export type metadataTableUpdateInput = {
    metadataId?: StringFieldUpdateOperationsInput | string
    csvKey?: StringFieldUpdateOperationsInput | string
    dbKey?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    csvObjTable?: csvObjTableUpdateOneRequiredWithoutMetadataTableNestedInput
  }

  export type metadataTableUncheckedUpdateInput = {
    metadataId?: StringFieldUpdateOperationsInput | string
    csvobjId?: StringFieldUpdateOperationsInput | string
    csvKey?: StringFieldUpdateOperationsInput | string
    dbKey?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metadataTableCreateManyInput = {
    metadataId?: string
    csvobjId: string
    csvKey: string
    dbKey: string
    createdAt?: Date | string | null
  }

  export type metadataTableUpdateManyMutationInput = {
    metadataId?: StringFieldUpdateOperationsInput | string
    csvKey?: StringFieldUpdateOperationsInput | string
    dbKey?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metadataTableUncheckedUpdateManyInput = {
    metadataId?: StringFieldUpdateOperationsInput | string
    csvobjId?: StringFieldUpdateOperationsInput | string
    csvKey?: StringFieldUpdateOperationsInput | string
    dbKey?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nurseryTableCreateInput = {
    nurseryId?: string
    gpsLat: number
    gpsLon: number
    capacity: number
    nurseryNotes?: string | null
    tradeName: string
    createdAt?: Date | string | null
    createdBy: string
    lastEditedAt?: Date | string | null
  }

  export type nurseryTableUncheckedCreateInput = {
    nurseryId?: string
    gpsLat: number
    gpsLon: number
    capacity: number
    nurseryNotes?: string | null
    tradeName: string
    createdAt?: Date | string | null
    createdBy: string
    lastEditedAt?: Date | string | null
  }

  export type nurseryTableUpdateInput = {
    nurseryId?: StringFieldUpdateOperationsInput | string
    gpsLat?: FloatFieldUpdateOperationsInput | number
    gpsLon?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    nurseryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nurseryTableUncheckedUpdateInput = {
    nurseryId?: StringFieldUpdateOperationsInput | string
    gpsLat?: FloatFieldUpdateOperationsInput | number
    gpsLon?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    nurseryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nurseryTableCreateManyInput = {
    nurseryId?: string
    gpsLat: number
    gpsLon: number
    capacity: number
    nurseryNotes?: string | null
    tradeName: string
    createdAt?: Date | string | null
    createdBy: string
    lastEditedAt?: Date | string | null
  }

  export type nurseryTableUpdateManyMutationInput = {
    nurseryId?: StringFieldUpdateOperationsInput | string
    gpsLat?: FloatFieldUpdateOperationsInput | number
    gpsLon?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    nurseryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type nurseryTableUncheckedUpdateManyInput = {
    nurseryId?: StringFieldUpdateOperationsInput | string
    gpsLat?: FloatFieldUpdateOperationsInput | number
    gpsLon?: FloatFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    nurseryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type organizationsTableCreateInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    stakeholderTypesTable?: stakeholderTypesTableCreateNestedOneWithoutOrganizationsTableInput
    profilesTable?: profilesTableCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUncheckedCreateInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    stakeholderTypeId?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    profilesTable?: profilesTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    stakeholderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableCreateManyInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    stakeholderTypeId?: string | null
  }

  export type organizationsTableUpdateManyMutationInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type organizationsTableUncheckedUpdateManyInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    stakeholderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plantingTableCreateInput = {
    plantingId?: string
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    plantingNotes?: string | null
    cropTable?: cropTableCreateNestedOneWithoutPlantingTableInput
    landTable?: landTableCreateNestedOneWithoutPlantingTableInput
  }

  export type plantingTableUncheckedCreateInput = {
    plantingId?: string
    landId?: string | null
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    cropId?: string | null
    plantingNotes?: string | null
  }

  export type plantingTableUpdateInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUpdateOneWithoutPlantingTableNestedInput
    landTable?: landTableUpdateOneWithoutPlantingTableNestedInput
  }

  export type plantingTableUncheckedUpdateInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    landId?: NullableStringFieldUpdateOperationsInput | string | null
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plantingTableCreateManyInput = {
    plantingId?: string
    landId?: string | null
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    cropId?: string | null
    plantingNotes?: string | null
  }

  export type plantingTableUpdateManyMutationInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plantingTableUncheckedUpdateManyInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    landId?: NullableStringFieldUpdateOperationsInput | string | null
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profilesTableCreateInput = {
    id?: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    locale?: string | null
    timezone?: string | null
    organizationsTable?: organizationsTableCreateNestedOneWithoutProfilesTableInput
    users: usersCreateNestedOneWithoutProfilesTableInput
  }

  export type profilesTableUncheckedCreateInput = {
    id?: string
    user_id: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    organizationid?: string | null
    locale?: string | null
    timezone?: string | null
  }

  export type profilesTableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    organizationsTable?: organizationsTableUpdateOneWithoutProfilesTableNestedInput
    users?: usersUpdateOneRequiredWithoutProfilesTableNestedInput
  }

  export type profilesTableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    organizationid?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profilesTableCreateManyInput = {
    id?: string
    user_id: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    organizationid?: string | null
    locale?: string | null
    timezone?: string | null
  }

  export type profilesTableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profilesTableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    organizationid?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type projectStakeholdersTableCreateInput = {
    stakeholderId?: string
    organizationsTable: organizationsTableCreateNestedOneWithoutProjectStakeholdersTableInput
    projectsTable: projectsTableCreateNestedOneWithoutProjectStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutProjectStakeholdersTableInput
  }

  export type projectStakeholdersTableUncheckedCreateInput = {
    stakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
    projectId: string
  }

  export type projectStakeholdersTableUpdateInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
    projectsTable?: projectsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
  }

  export type projectStakeholdersTableUncheckedUpdateInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type projectStakeholdersTableCreateManyInput = {
    stakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
    projectId: string
  }

  export type projectStakeholdersTableUpdateManyMutationInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
  }

  export type projectStakeholdersTableUncheckedUpdateManyInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type projectsTableCreateInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    source?: string | null
    cropTable?: cropTableCreateNestedManyWithoutProjectsTableInput
    landTable?: landTableCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutProjectsTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutProjectsTableInput
  }

  export type projectsTableUncheckedCreateInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    csvobjId?: string | null
    source?: string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutProjectsTableInput
    landTable?: landTableUncheckedCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutProjectsTableInput
  }

  export type projectsTableUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUpdateManyWithoutProjectsTableNestedInput
    landTable?: landTableUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutProjectsTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutProjectsTableNestedInput
  }

  export type projectsTableUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutProjectsTableNestedInput
    landTable?: landTableUncheckedUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutProjectsTableNestedInput
  }

  export type projectsTableCreateManyInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    csvobjId?: string | null
    source?: string | null
  }

  export type projectsTableUpdateManyMutationInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type projectsTableUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type speciesTableCreateInput = {
    speciesId: string
    commonName: string
    scientificName?: string | null
    type?: string | null
    family?: string | null
    reference?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropTable?: cropTableCreateNestedManyWithoutSpeciesTableInput
  }

  export type speciesTableUncheckedCreateInput = {
    speciesId: string
    commonName: string
    scientificName?: string | null
    type?: string | null
    family?: string | null
    reference?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutSpeciesTableInput
  }

  export type speciesTableUpdateInput = {
    speciesId?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    family?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropTable?: cropTableUpdateManyWithoutSpeciesTableNestedInput
  }

  export type speciesTableUncheckedUpdateInput = {
    speciesId?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    family?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropTable?: cropTableUncheckedUpdateManyWithoutSpeciesTableNestedInput
  }

  export type speciesTableCreateManyInput = {
    speciesId: string
    commonName: string
    scientificName?: string | null
    type?: string | null
    family?: string | null
    reference?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
  }

  export type speciesTableUpdateManyMutationInput = {
    speciesId?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    family?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type speciesTableUncheckedUpdateManyInput = {
    speciesId?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    family?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type stakeholderTypesTableCreateInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableUncheckedCreateInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableUpdateInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type stakeholderTypesTableUncheckedUpdateInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type stakeholderTypesTableCreateManyInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
  }

  export type stakeholderTypesTableUpdateManyMutationInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type stakeholderTypesTableUncheckedUpdateManyInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type audit_log_entriesCountOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    payload?: SortOrder
    created_at?: SortOrder
    ip_address?: SortOrder
  }

  export type audit_log_entriesMaxOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    ip_address?: SortOrder
  }

  export type audit_log_entriesMinOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    ip_address?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Enumcode_challenge_methodFilter<$PrismaModel = never> = {
    equals?: $Enums.code_challenge_method | Enumcode_challenge_methodFieldRefInput<$PrismaModel>
    in?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    notIn?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    not?: NestedEnumcode_challenge_methodFilter<$PrismaModel> | $Enums.code_challenge_method
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Saml_relay_statesListRelationFilter = {
    every?: saml_relay_statesWhereInput
    some?: saml_relay_statesWhereInput
    none?: saml_relay_statesWhereInput
  }

  export type saml_relay_statesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type flow_stateCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    auth_code?: SortOrder
    code_challenge_method?: SortOrder
    code_challenge?: SortOrder
    provider_type?: SortOrder
    provider_access_token?: SortOrder
    provider_refresh_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    auth_code_issued_at?: SortOrder
  }

  export type flow_stateMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    auth_code?: SortOrder
    code_challenge_method?: SortOrder
    code_challenge?: SortOrder
    provider_type?: SortOrder
    provider_access_token?: SortOrder
    provider_refresh_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    auth_code_issued_at?: SortOrder
  }

  export type flow_stateMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    auth_code?: SortOrder
    code_challenge_method?: SortOrder
    code_challenge?: SortOrder
    provider_type?: SortOrder
    provider_access_token?: SortOrder
    provider_refresh_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    auth_code_issued_at?: SortOrder
  }

  export type Enumcode_challenge_methodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.code_challenge_method | Enumcode_challenge_methodFieldRefInput<$PrismaModel>
    in?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    notIn?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    not?: NestedEnumcode_challenge_methodWithAggregatesFilter<$PrismaModel> | $Enums.code_challenge_method
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcode_challenge_methodFilter<$PrismaModel>
    _max?: NestedEnumcode_challenge_methodFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type identitiesProvider_idProviderCompoundUniqueInput = {
    provider_id: string
    provider: string
  }

  export type identitiesCountOrderByAggregateInput = {
    provider_id?: SortOrder
    user_id?: SortOrder
    identity_data?: SortOrder
    provider?: SortOrder
    last_sign_in_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    id?: SortOrder
  }

  export type identitiesMaxOrderByAggregateInput = {
    provider_id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    last_sign_in_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    id?: SortOrder
  }

  export type identitiesMinOrderByAggregateInput = {
    provider_id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    last_sign_in_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type instancesCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    raw_base_config?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type instancesMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    raw_base_config?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type instancesMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    raw_base_config?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionsScalarRelationFilter = {
    is?: sessionsWhereInput
    isNot?: sessionsWhereInput
  }

  export type mfa_amr_claimsSession_idAuthentication_methodCompoundUniqueInput = {
    session_id: string
    authentication_method: string
  }

  export type mfa_amr_claimsCountOrderByAggregateInput = {
    session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    id?: SortOrder
  }

  export type mfa_amr_claimsMaxOrderByAggregateInput = {
    session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    id?: SortOrder
  }

  export type mfa_amr_claimsMinOrderByAggregateInput = {
    session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    authentication_method?: SortOrder
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Mfa_factorsScalarRelationFilter = {
    is?: mfa_factorsWhereInput
    isNot?: mfa_factorsWhereInput
  }

  export type mfa_challengesCountOrderByAggregateInput = {
    id?: SortOrder
    factor_id?: SortOrder
    created_at?: SortOrder
    verified_at?: SortOrder
    ip_address?: SortOrder
    otp_code?: SortOrder
    web_authn_session_data?: SortOrder
  }

  export type mfa_challengesMaxOrderByAggregateInput = {
    id?: SortOrder
    factor_id?: SortOrder
    created_at?: SortOrder
    verified_at?: SortOrder
    ip_address?: SortOrder
    otp_code?: SortOrder
  }

  export type mfa_challengesMinOrderByAggregateInput = {
    id?: SortOrder
    factor_id?: SortOrder
    created_at?: SortOrder
    verified_at?: SortOrder
    ip_address?: SortOrder
    otp_code?: SortOrder
  }

  export type Enumfactor_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_type | Enumfactor_typeFieldRefInput<$PrismaModel>
    in?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_typeFilter<$PrismaModel> | $Enums.factor_type
  }

  export type Enumfactor_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_status | Enumfactor_statusFieldRefInput<$PrismaModel>
    in?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_statusFilter<$PrismaModel> | $Enums.factor_status
  }

  export type Mfa_challengesListRelationFilter = {
    every?: mfa_challengesWhereInput
    some?: mfa_challengesWhereInput
    none?: mfa_challengesWhereInput
  }

  export type mfa_challengesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mfa_factorsUser_idPhoneCompoundUniqueInput = {
    user_id: string
    phone: string
  }

  export type mfa_factorsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    friendly_name?: SortOrder
    factor_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secret?: SortOrder
    phone?: SortOrder
    last_challenged_at?: SortOrder
    web_authn_credential?: SortOrder
    web_authn_aaguid?: SortOrder
  }

  export type mfa_factorsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    friendly_name?: SortOrder
    factor_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secret?: SortOrder
    phone?: SortOrder
    last_challenged_at?: SortOrder
    web_authn_aaguid?: SortOrder
  }

  export type mfa_factorsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    friendly_name?: SortOrder
    factor_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secret?: SortOrder
    phone?: SortOrder
    last_challenged_at?: SortOrder
    web_authn_aaguid?: SortOrder
  }

  export type Enumfactor_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_type | Enumfactor_typeFieldRefInput<$PrismaModel>
    in?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_typeWithAggregatesFilter<$PrismaModel> | $Enums.factor_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfactor_typeFilter<$PrismaModel>
    _max?: NestedEnumfactor_typeFilter<$PrismaModel>
  }

  export type Enumfactor_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_status | Enumfactor_statusFieldRefInput<$PrismaModel>
    in?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_statusWithAggregatesFilter<$PrismaModel> | $Enums.factor_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfactor_statusFilter<$PrismaModel>
    _max?: NestedEnumfactor_statusFilter<$PrismaModel>
  }

  export type Enumone_time_token_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.one_time_token_type | Enumone_time_token_typeFieldRefInput<$PrismaModel>
    in?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumone_time_token_typeFilter<$PrismaModel> | $Enums.one_time_token_type
  }

  export type one_time_tokensUser_idToken_typeCompoundUniqueInput = {
    user_id: string
    token_type: $Enums.one_time_token_type
  }

  export type one_time_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_type?: SortOrder
    token_hash?: SortOrder
    relates_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type one_time_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_type?: SortOrder
    token_hash?: SortOrder
    relates_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type one_time_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_type?: SortOrder
    token_hash?: SortOrder
    relates_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Enumone_time_token_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.one_time_token_type | Enumone_time_token_typeFieldRefInput<$PrismaModel>
    in?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumone_time_token_typeWithAggregatesFilter<$PrismaModel> | $Enums.one_time_token_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumone_time_token_typeFilter<$PrismaModel>
    _max?: NestedEnumone_time_token_typeFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SessionsNullableScalarRelationFilter = {
    is?: sessionsWhereInput | null
    isNot?: sessionsWhereInput | null
  }

  export type refresh_tokensCountOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    revoked?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent?: SortOrder
    session_id?: SortOrder
  }

  export type refresh_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type refresh_tokensMaxOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    revoked?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent?: SortOrder
    session_id?: SortOrder
  }

  export type refresh_tokensMinOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    revoked?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent?: SortOrder
    session_id?: SortOrder
  }

  export type refresh_tokensSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Sso_providersScalarRelationFilter = {
    is?: sso_providersWhereInput
    isNot?: sso_providersWhereInput
  }

  export type saml_providersCountOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    entity_id?: SortOrder
    metadata_xml?: SortOrder
    metadata_url?: SortOrder
    attribute_mapping?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name_id_format?: SortOrder
  }

  export type saml_providersMaxOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    entity_id?: SortOrder
    metadata_xml?: SortOrder
    metadata_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name_id_format?: SortOrder
  }

  export type saml_providersMinOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    entity_id?: SortOrder
    metadata_xml?: SortOrder
    metadata_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name_id_format?: SortOrder
  }

  export type Flow_stateNullableScalarRelationFilter = {
    is?: flow_stateWhereInput | null
    isNot?: flow_stateWhereInput | null
  }

  export type saml_relay_statesCountOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    request_id?: SortOrder
    for_email?: SortOrder
    redirect_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    flow_state_id?: SortOrder
  }

  export type saml_relay_statesMaxOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    request_id?: SortOrder
    for_email?: SortOrder
    redirect_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    flow_state_id?: SortOrder
  }

  export type saml_relay_statesMinOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    request_id?: SortOrder
    for_email?: SortOrder
    redirect_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    flow_state_id?: SortOrder
  }

  export type schema_migrationsCountOrderByAggregateInput = {
    version?: SortOrder
  }

  export type schema_migrationsMaxOrderByAggregateInput = {
    version?: SortOrder
  }

  export type schema_migrationsMinOrderByAggregateInput = {
    version?: SortOrder
  }

  export type Enumaal_levelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.aal_level | Enumaal_levelFieldRefInput<$PrismaModel> | null
    in?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumaal_levelNullableFilter<$PrismaModel> | $Enums.aal_level | null
  }

  export type Mfa_amr_claimsListRelationFilter = {
    every?: mfa_amr_claimsWhereInput
    some?: mfa_amr_claimsWhereInput
    none?: mfa_amr_claimsWhereInput
  }

  export type Refresh_tokensListRelationFilter = {
    every?: refresh_tokensWhereInput
    some?: refresh_tokensWhereInput
    none?: refresh_tokensWhereInput
  }

  export type mfa_amr_claimsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refresh_tokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    factor_id?: SortOrder
    aal?: SortOrder
    not_after?: SortOrder
    refreshed_at?: SortOrder
    user_agent?: SortOrder
    ip?: SortOrder
    tag?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    factor_id?: SortOrder
    aal?: SortOrder
    not_after?: SortOrder
    refreshed_at?: SortOrder
    user_agent?: SortOrder
    ip?: SortOrder
    tag?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    factor_id?: SortOrder
    aal?: SortOrder
    not_after?: SortOrder
    refreshed_at?: SortOrder
    user_agent?: SortOrder
    ip?: SortOrder
    tag?: SortOrder
  }

  export type Enumaal_levelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.aal_level | Enumaal_levelFieldRefInput<$PrismaModel> | null
    in?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumaal_levelNullableWithAggregatesFilter<$PrismaModel> | $Enums.aal_level | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumaal_levelNullableFilter<$PrismaModel>
    _max?: NestedEnumaal_levelNullableFilter<$PrismaModel>
  }

  export type sso_domainsCountOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    domain?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sso_domainsMaxOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    domain?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sso_domainsMinOrderByAggregateInput = {
    id?: SortOrder
    sso_provider_id?: SortOrder
    domain?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Saml_providersListRelationFilter = {
    every?: saml_providersWhereInput
    some?: saml_providersWhereInput
    none?: saml_providersWhereInput
  }

  export type Sso_domainsListRelationFilter = {
    every?: sso_domainsWhereInput
    some?: sso_domainsWhereInput
    none?: sso_domainsWhereInput
  }

  export type saml_providersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sso_domainsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sso_providersCountOrderByAggregateInput = {
    id?: SortOrder
    resource_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sso_providersMaxOrderByAggregateInput = {
    id?: SortOrder
    resource_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sso_providersMinOrderByAggregateInput = {
    id?: SortOrder
    resource_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IdentitiesListRelationFilter = {
    every?: identitiesWhereInput
    some?: identitiesWhereInput
    none?: identitiesWhereInput
  }

  export type Mfa_factorsListRelationFilter = {
    every?: mfa_factorsWhereInput
    some?: mfa_factorsWhereInput
    none?: mfa_factorsWhereInput
  }

  export type One_time_tokensListRelationFilter = {
    every?: one_time_tokensWhereInput
    some?: one_time_tokensWhereInput
    none?: one_time_tokensWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type ProfilesTableNullableScalarRelationFilter = {
    is?: profilesTableWhereInput | null
    isNot?: profilesTableWhereInput | null
  }

  export type identitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mfa_factorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type one_time_tokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    aud?: SortOrder
    role?: SortOrder
    email?: SortOrder
    encrypted_password?: SortOrder
    email_confirmed_at?: SortOrder
    invited_at?: SortOrder
    confirmation_token?: SortOrder
    confirmation_sent_at?: SortOrder
    recovery_token?: SortOrder
    recovery_sent_at?: SortOrder
    email_change_token_new?: SortOrder
    email_change?: SortOrder
    email_change_sent_at?: SortOrder
    last_sign_in_at?: SortOrder
    raw_app_meta_data?: SortOrder
    raw_user_meta_data?: SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    phone_confirmed_at?: SortOrder
    phone_change?: SortOrder
    phone_change_token?: SortOrder
    phone_change_sent_at?: SortOrder
    confirmed_at?: SortOrder
    email_change_token_current?: SortOrder
    email_change_confirm_status?: SortOrder
    banned_until?: SortOrder
    reauthentication_token?: SortOrder
    reauthentication_sent_at?: SortOrder
    is_sso_user?: SortOrder
    deleted_at?: SortOrder
    is_anonymous?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    email_change_confirm_status?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    aud?: SortOrder
    role?: SortOrder
    email?: SortOrder
    encrypted_password?: SortOrder
    email_confirmed_at?: SortOrder
    invited_at?: SortOrder
    confirmation_token?: SortOrder
    confirmation_sent_at?: SortOrder
    recovery_token?: SortOrder
    recovery_sent_at?: SortOrder
    email_change_token_new?: SortOrder
    email_change?: SortOrder
    email_change_sent_at?: SortOrder
    last_sign_in_at?: SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    phone_confirmed_at?: SortOrder
    phone_change?: SortOrder
    phone_change_token?: SortOrder
    phone_change_sent_at?: SortOrder
    confirmed_at?: SortOrder
    email_change_token_current?: SortOrder
    email_change_confirm_status?: SortOrder
    banned_until?: SortOrder
    reauthentication_token?: SortOrder
    reauthentication_sent_at?: SortOrder
    is_sso_user?: SortOrder
    deleted_at?: SortOrder
    is_anonymous?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    instance_id?: SortOrder
    id?: SortOrder
    aud?: SortOrder
    role?: SortOrder
    email?: SortOrder
    encrypted_password?: SortOrder
    email_confirmed_at?: SortOrder
    invited_at?: SortOrder
    confirmation_token?: SortOrder
    confirmation_sent_at?: SortOrder
    recovery_token?: SortOrder
    recovery_sent_at?: SortOrder
    email_change_token_new?: SortOrder
    email_change?: SortOrder
    email_change_sent_at?: SortOrder
    last_sign_in_at?: SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    phone_confirmed_at?: SortOrder
    phone_change?: SortOrder
    phone_change_token?: SortOrder
    phone_change_sent_at?: SortOrder
    confirmed_at?: SortOrder
    email_change_token_current?: SortOrder
    email_change_confirm_status?: SortOrder
    banned_until?: SortOrder
    reauthentication_token?: SortOrder
    reauthentication_sent_at?: SortOrder
    is_sso_user?: SortOrder
    deleted_at?: SortOrder
    is_anonymous?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    email_change_confirm_status?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CropTableScalarRelationFilter = {
    is?: cropTableWhereInput
    isNot?: cropTableWhereInput
  }

  export type OrganizationsTableScalarRelationFilter = {
    is?: organizationsTableWhereInput
    isNot?: organizationsTableWhereInput
  }

  export type StakeholderTypesTableScalarRelationFilter = {
    is?: stakeholderTypesTableWhereInput
    isNot?: stakeholderTypesTableWhereInput
  }

  export type cropStakeholdersTableCropIdOrganizationIdStakeholderTypeIdCompoundUniqueInput = {
    cropId: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type cropStakeholdersTableCountOrderByAggregateInput = {
    cropStakeholderId?: SortOrder
    cropId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type cropStakeholdersTableMaxOrderByAggregateInput = {
    cropStakeholderId?: SortOrder
    cropId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type cropStakeholdersTableMinOrderByAggregateInput = {
    cropStakeholderId?: SortOrder
    cropId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type CropStakeholdersTableListRelationFilter = {
    every?: cropStakeholdersTableWhereInput
    some?: cropStakeholdersTableWhereInput
    none?: cropStakeholdersTableWhereInput
  }

  export type CsvObjTableNullableScalarRelationFilter = {
    is?: csvObjTableWhereInput | null
    isNot?: csvObjTableWhereInput | null
  }

  export type OrganizationsTableNullableScalarRelationFilter = {
    is?: organizationsTableWhereInput | null
    isNot?: organizationsTableWhereInput | null
  }

  export type ProjectsTableNullableScalarRelationFilter = {
    is?: projectsTableWhereInput | null
    isNot?: projectsTableWhereInput | null
  }

  export type SpeciesTableNullableScalarRelationFilter = {
    is?: speciesTableWhereInput | null
    isNot?: speciesTableWhereInput | null
  }

  export type PlantingTableListRelationFilter = {
    every?: plantingTableWhereInput
    some?: plantingTableWhereInput
    none?: plantingTableWhereInput
  }

  export type cropStakeholdersTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plantingTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cropTableProjectIdCropNameCompoundUniqueInput = {
    projectId: string
    cropName: string
  }

  export type cropTableCountOrderByAggregateInput = {
    cropId?: SortOrder
    cropName?: SortOrder
    speciesId?: SortOrder
    seedInfo?: SortOrder
    cropStock?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    cropNotes?: SortOrder
    csvobjId?: SortOrder
    speciesTemp?: SortOrder
  }

  export type cropTableMaxOrderByAggregateInput = {
    cropId?: SortOrder
    cropName?: SortOrder
    speciesId?: SortOrder
    seedInfo?: SortOrder
    cropStock?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    cropNotes?: SortOrder
    csvobjId?: SortOrder
    speciesTemp?: SortOrder
  }

  export type cropTableMinOrderByAggregateInput = {
    cropId?: SortOrder
    cropName?: SortOrder
    speciesId?: SortOrder
    seedInfo?: SortOrder
    cropStock?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    cropNotes?: SortOrder
    csvobjId?: SortOrder
    speciesTemp?: SortOrder
  }

  export type CropTableListRelationFilter = {
    every?: cropTableWhereInput
    some?: cropTableWhereInput
    none?: cropTableWhereInput
  }

  export type LandTableListRelationFilter = {
    every?: landTableWhereInput
    some?: landTableWhereInput
    none?: landTableWhereInput
  }

  export type MetadataTableListRelationFilter = {
    every?: metadataTableWhereInput
    some?: metadataTableWhereInput
    none?: metadataTableWhereInput
  }

  export type ProjectsTableListRelationFilter = {
    every?: projectsTableWhereInput
    some?: projectsTableWhereInput
    none?: projectsTableWhereInput
  }

  export type cropTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type landTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type metadataTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projectsTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type csvObjTableCountOrderByAggregateInput = {
    csvobjId?: SortOrder
    jsonData?: SortOrder
    createdAt?: SortOrder
  }

  export type csvObjTableMaxOrderByAggregateInput = {
    csvobjId?: SortOrder
    createdAt?: SortOrder
  }

  export type csvObjTableMinOrderByAggregateInput = {
    csvobjId?: SortOrder
    createdAt?: SortOrder
  }

  export type LandTableScalarRelationFilter = {
    is?: landTableWhereInput
    isNot?: landTableWhereInput
  }

  export type landStakeholdersTableLandIdOrganizationIdStakeholderTypeIdCompoundUniqueInput = {
    landId: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type landStakeholdersTableCountOrderByAggregateInput = {
    landStakeholderId?: SortOrder
    landId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type landStakeholdersTableMaxOrderByAggregateInput = {
    landStakeholderId?: SortOrder
    landId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type landStakeholdersTableMinOrderByAggregateInput = {
    landStakeholderId?: SortOrder
    landId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumPreparationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Preparation | EnumPreparationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPreparationNullableFilter<$PrismaModel> | $Enums.Preparation | null
  }

  export type LandStakeholdersTableListRelationFilter = {
    every?: landStakeholdersTableWhereInput
    some?: landStakeholdersTableWhereInput
    none?: landStakeholdersTableWhereInput
  }

  export type landStakeholdersTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type landTableProjectIdLandNameCompoundUniqueInput = {
    projectId: string
    landName: string
  }

  export type landTableCountOrderByAggregateInput = {
    landId?: SortOrder
    landName?: SortOrder
    projectId?: SortOrder
    hectares?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    landNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    preparation?: SortOrder
    csvobjId?: SortOrder
    polygon?: SortOrder
  }

  export type landTableAvgOrderByAggregateInput = {
    hectares?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
  }

  export type landTableMaxOrderByAggregateInput = {
    landId?: SortOrder
    landName?: SortOrder
    projectId?: SortOrder
    hectares?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    landNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    preparation?: SortOrder
    csvobjId?: SortOrder
  }

  export type landTableMinOrderByAggregateInput = {
    landId?: SortOrder
    landName?: SortOrder
    projectId?: SortOrder
    hectares?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    landNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    preparation?: SortOrder
    csvobjId?: SortOrder
  }

  export type landTableSumOrderByAggregateInput = {
    hectares?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumPreparationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Preparation | EnumPreparationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPreparationNullableWithAggregatesFilter<$PrismaModel> | $Enums.Preparation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPreparationNullableFilter<$PrismaModel>
    _max?: NestedEnumPreparationNullableFilter<$PrismaModel>
  }

  export type CsvObjTableScalarRelationFilter = {
    is?: csvObjTableWhereInput
    isNot?: csvObjTableWhereInput
  }

  export type metadataTableCountOrderByAggregateInput = {
    metadataId?: SortOrder
    csvobjId?: SortOrder
    csvKey?: SortOrder
    dbKey?: SortOrder
    createdAt?: SortOrder
  }

  export type metadataTableMaxOrderByAggregateInput = {
    metadataId?: SortOrder
    csvobjId?: SortOrder
    csvKey?: SortOrder
    dbKey?: SortOrder
    createdAt?: SortOrder
  }

  export type metadataTableMinOrderByAggregateInput = {
    metadataId?: SortOrder
    csvobjId?: SortOrder
    csvKey?: SortOrder
    dbKey?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type nurseryTableCountOrderByAggregateInput = {
    nurseryId?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    capacity?: SortOrder
    nurseryNotes?: SortOrder
    tradeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    lastEditedAt?: SortOrder
  }

  export type nurseryTableAvgOrderByAggregateInput = {
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    capacity?: SortOrder
  }

  export type nurseryTableMaxOrderByAggregateInput = {
    nurseryId?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    capacity?: SortOrder
    nurseryNotes?: SortOrder
    tradeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    lastEditedAt?: SortOrder
  }

  export type nurseryTableMinOrderByAggregateInput = {
    nurseryId?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    capacity?: SortOrder
    nurseryNotes?: SortOrder
    tradeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    lastEditedAt?: SortOrder
  }

  export type nurseryTableSumOrderByAggregateInput = {
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    capacity?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StakeholderTypesTableNullableScalarRelationFilter = {
    is?: stakeholderTypesTableWhereInput | null
    isNot?: stakeholderTypesTableWhereInput | null
  }

  export type ProfilesTableListRelationFilter = {
    every?: profilesTableWhereInput
    some?: profilesTableWhereInput
    none?: profilesTableWhereInput
  }

  export type ProjectStakeholdersTableListRelationFilter = {
    every?: projectStakeholdersTableWhereInput
    some?: projectStakeholdersTableWhereInput
    none?: projectStakeholdersTableWhereInput
  }

  export type profilesTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projectStakeholdersTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizationsTableCountOrderByAggregateInput = {
    organizationId?: SortOrder
    organizationName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    organizationNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type organizationsTableAvgOrderByAggregateInput = {
    gpsLat?: SortOrder
    gpsLon?: SortOrder
  }

  export type organizationsTableMaxOrderByAggregateInput = {
    organizationId?: SortOrder
    organizationName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    organizationNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type organizationsTableMinOrderByAggregateInput = {
    organizationId?: SortOrder
    organizationName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    organizationNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    gpsLat?: SortOrder
    gpsLon?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type organizationsTableSumOrderByAggregateInput = {
    gpsLat?: SortOrder
    gpsLon?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CropTableNullableScalarRelationFilter = {
    is?: cropTableWhereInput | null
    isNot?: cropTableWhereInput | null
  }

  export type LandTableNullableScalarRelationFilter = {
    is?: landTableWhereInput | null
    isNot?: landTableWhereInput | null
  }

  export type plantingTableLandIdCropIdCompoundUniqueInput = {
    landId: string
    cropId: string
  }

  export type plantingTableCountOrderByAggregateInput = {
    plantingId?: SortOrder
    landId?: SortOrder
    planted?: SortOrder
    plantingDate?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    deleted?: SortOrder
    cropId?: SortOrder
    plantingNotes?: SortOrder
  }

  export type plantingTableAvgOrderByAggregateInput = {
    planted?: SortOrder
  }

  export type plantingTableMaxOrderByAggregateInput = {
    plantingId?: SortOrder
    landId?: SortOrder
    planted?: SortOrder
    plantingDate?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    deleted?: SortOrder
    cropId?: SortOrder
    plantingNotes?: SortOrder
  }

  export type plantingTableMinOrderByAggregateInput = {
    plantingId?: SortOrder
    landId?: SortOrder
    planted?: SortOrder
    plantingDate?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    deleted?: SortOrder
    cropId?: SortOrder
    plantingNotes?: SortOrder
  }

  export type plantingTableSumOrderByAggregateInput = {
    planted?: SortOrder
  }

  export type Enumuser_roleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableFilter<$PrismaModel> | $Enums.user_role | null
  }

  export type profilesTableCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrder
    isactive?: SortOrder
    isverified?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    lastlogin?: SortOrder
    twofactorenabled?: SortOrder
    twofactorsecret?: SortOrder
    organizationid?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
  }

  export type profilesTableMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrder
    isactive?: SortOrder
    isverified?: SortOrder
    role?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    lastlogin?: SortOrder
    twofactorenabled?: SortOrder
    twofactorsecret?: SortOrder
    organizationid?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
  }

  export type profilesTableMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrder
    isactive?: SortOrder
    isverified?: SortOrder
    role?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    lastlogin?: SortOrder
    twofactorenabled?: SortOrder
    twofactorsecret?: SortOrder
    organizationid?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
  }

  export type Enumuser_roleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_roleNullableFilter<$PrismaModel>
  }

  export type ProjectsTableScalarRelationFilter = {
    is?: projectsTableWhereInput
    isNot?: projectsTableWhereInput
  }

  export type projectStakeholdersTableOrganizationIdStakeholderTypeIdProjectIdCompoundUniqueInput = {
    organizationId: string
    stakeholderTypeId: string
    projectId: string
  }

  export type projectStakeholdersTableCountOrderByAggregateInput = {
    stakeholderId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    projectId?: SortOrder
  }

  export type projectStakeholdersTableMaxOrderByAggregateInput = {
    stakeholderId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    projectId?: SortOrder
  }

  export type projectStakeholdersTableMinOrderByAggregateInput = {
    stakeholderId?: SortOrder
    organizationId?: SortOrder
    stakeholderTypeId?: SortOrder
    projectId?: SortOrder
  }

  export type projectsTableCountOrderByAggregateInput = {
    projectId?: SortOrder
    projectName?: SortOrder
    projectNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    csvobjId?: SortOrder
    source?: SortOrder
  }

  export type projectsTableMaxOrderByAggregateInput = {
    projectId?: SortOrder
    projectName?: SortOrder
    projectNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    csvobjId?: SortOrder
    source?: SortOrder
  }

  export type projectsTableMinOrderByAggregateInput = {
    projectId?: SortOrder
    projectName?: SortOrder
    projectNotes?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
    csvobjId?: SortOrder
    source?: SortOrder
  }

  export type speciesTableCountOrderByAggregateInput = {
    speciesId?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrder
    type?: SortOrder
    family?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
  }

  export type speciesTableMaxOrderByAggregateInput = {
    speciesId?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrder
    type?: SortOrder
    family?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
  }

  export type speciesTableMinOrderByAggregateInput = {
    speciesId?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrder
    type?: SortOrder
    family?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    editedBy?: SortOrder
    deleted?: SortOrder
  }

  export type OrganizationsTableListRelationFilter = {
    every?: organizationsTableWhereInput
    some?: organizationsTableWhereInput
    none?: organizationsTableWhereInput
  }

  export type organizationsTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type stakeholderTypesTableCountOrderByAggregateInput = {
    stakeholderType?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    deleted?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type stakeholderTypesTableMaxOrderByAggregateInput = {
    stakeholderType?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    deleted?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type stakeholderTypesTableMinOrderByAggregateInput = {
    stakeholderType?: SortOrder
    createdAt?: SortOrder
    lastEditedAt?: SortOrder
    deleted?: SortOrder
    stakeholderTypeId?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type saml_relay_statesCreateNestedManyWithoutFlow_stateInput = {
    create?: XOR<saml_relay_statesCreateWithoutFlow_stateInput, saml_relay_statesUncheckedCreateWithoutFlow_stateInput> | saml_relay_statesCreateWithoutFlow_stateInput[] | saml_relay_statesUncheckedCreateWithoutFlow_stateInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutFlow_stateInput | saml_relay_statesCreateOrConnectWithoutFlow_stateInput[]
    createMany?: saml_relay_statesCreateManyFlow_stateInputEnvelope
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
  }

  export type saml_relay_statesUncheckedCreateNestedManyWithoutFlow_stateInput = {
    create?: XOR<saml_relay_statesCreateWithoutFlow_stateInput, saml_relay_statesUncheckedCreateWithoutFlow_stateInput> | saml_relay_statesCreateWithoutFlow_stateInput[] | saml_relay_statesUncheckedCreateWithoutFlow_stateInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutFlow_stateInput | saml_relay_statesCreateOrConnectWithoutFlow_stateInput[]
    createMany?: saml_relay_statesCreateManyFlow_stateInputEnvelope
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
  }

  export type Enumcode_challenge_methodFieldUpdateOperationsInput = {
    set?: $Enums.code_challenge_method
  }

  export type saml_relay_statesUpdateManyWithoutFlow_stateNestedInput = {
    create?: XOR<saml_relay_statesCreateWithoutFlow_stateInput, saml_relay_statesUncheckedCreateWithoutFlow_stateInput> | saml_relay_statesCreateWithoutFlow_stateInput[] | saml_relay_statesUncheckedCreateWithoutFlow_stateInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutFlow_stateInput | saml_relay_statesCreateOrConnectWithoutFlow_stateInput[]
    upsert?: saml_relay_statesUpsertWithWhereUniqueWithoutFlow_stateInput | saml_relay_statesUpsertWithWhereUniqueWithoutFlow_stateInput[]
    createMany?: saml_relay_statesCreateManyFlow_stateInputEnvelope
    set?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    disconnect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    delete?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    update?: saml_relay_statesUpdateWithWhereUniqueWithoutFlow_stateInput | saml_relay_statesUpdateWithWhereUniqueWithoutFlow_stateInput[]
    updateMany?: saml_relay_statesUpdateManyWithWhereWithoutFlow_stateInput | saml_relay_statesUpdateManyWithWhereWithoutFlow_stateInput[]
    deleteMany?: saml_relay_statesScalarWhereInput | saml_relay_statesScalarWhereInput[]
  }

  export type saml_relay_statesUncheckedUpdateManyWithoutFlow_stateNestedInput = {
    create?: XOR<saml_relay_statesCreateWithoutFlow_stateInput, saml_relay_statesUncheckedCreateWithoutFlow_stateInput> | saml_relay_statesCreateWithoutFlow_stateInput[] | saml_relay_statesUncheckedCreateWithoutFlow_stateInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutFlow_stateInput | saml_relay_statesCreateOrConnectWithoutFlow_stateInput[]
    upsert?: saml_relay_statesUpsertWithWhereUniqueWithoutFlow_stateInput | saml_relay_statesUpsertWithWhereUniqueWithoutFlow_stateInput[]
    createMany?: saml_relay_statesCreateManyFlow_stateInputEnvelope
    set?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    disconnect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    delete?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    update?: saml_relay_statesUpdateWithWhereUniqueWithoutFlow_stateInput | saml_relay_statesUpdateWithWhereUniqueWithoutFlow_stateInput[]
    updateMany?: saml_relay_statesUpdateManyWithWhereWithoutFlow_stateInput | saml_relay_statesUpdateManyWithWhereWithoutFlow_stateInput[]
    deleteMany?: saml_relay_statesScalarWhereInput | saml_relay_statesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutIdentitiesInput = {
    create?: XOR<usersCreateWithoutIdentitiesInput, usersUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutIdentitiesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutIdentitiesNestedInput = {
    create?: XOR<usersCreateWithoutIdentitiesInput, usersUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutIdentitiesInput
    upsert?: usersUpsertWithoutIdentitiesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutIdentitiesInput, usersUpdateWithoutIdentitiesInput>, usersUncheckedUpdateWithoutIdentitiesInput>
  }

  export type sessionsCreateNestedOneWithoutMfa_amr_claimsInput = {
    create?: XOR<sessionsCreateWithoutMfa_amr_claimsInput, sessionsUncheckedCreateWithoutMfa_amr_claimsInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutMfa_amr_claimsInput
    connect?: sessionsWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type sessionsUpdateOneRequiredWithoutMfa_amr_claimsNestedInput = {
    create?: XOR<sessionsCreateWithoutMfa_amr_claimsInput, sessionsUncheckedCreateWithoutMfa_amr_claimsInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutMfa_amr_claimsInput
    upsert?: sessionsUpsertWithoutMfa_amr_claimsInput
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutMfa_amr_claimsInput, sessionsUpdateWithoutMfa_amr_claimsInput>, sessionsUncheckedUpdateWithoutMfa_amr_claimsInput>
  }

  export type mfa_factorsCreateNestedOneWithoutMfa_challengesInput = {
    create?: XOR<mfa_factorsCreateWithoutMfa_challengesInput, mfa_factorsUncheckedCreateWithoutMfa_challengesInput>
    connectOrCreate?: mfa_factorsCreateOrConnectWithoutMfa_challengesInput
    connect?: mfa_factorsWhereUniqueInput
  }

  export type mfa_factorsUpdateOneRequiredWithoutMfa_challengesNestedInput = {
    create?: XOR<mfa_factorsCreateWithoutMfa_challengesInput, mfa_factorsUncheckedCreateWithoutMfa_challengesInput>
    connectOrCreate?: mfa_factorsCreateOrConnectWithoutMfa_challengesInput
    upsert?: mfa_factorsUpsertWithoutMfa_challengesInput
    connect?: mfa_factorsWhereUniqueInput
    update?: XOR<XOR<mfa_factorsUpdateToOneWithWhereWithoutMfa_challengesInput, mfa_factorsUpdateWithoutMfa_challengesInput>, mfa_factorsUncheckedUpdateWithoutMfa_challengesInput>
  }

  export type mfa_challengesCreateNestedManyWithoutMfa_factorsInput = {
    create?: XOR<mfa_challengesCreateWithoutMfa_factorsInput, mfa_challengesUncheckedCreateWithoutMfa_factorsInput> | mfa_challengesCreateWithoutMfa_factorsInput[] | mfa_challengesUncheckedCreateWithoutMfa_factorsInput[]
    connectOrCreate?: mfa_challengesCreateOrConnectWithoutMfa_factorsInput | mfa_challengesCreateOrConnectWithoutMfa_factorsInput[]
    createMany?: mfa_challengesCreateManyMfa_factorsInputEnvelope
    connect?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutMfa_factorsInput = {
    create?: XOR<usersCreateWithoutMfa_factorsInput, usersUncheckedCreateWithoutMfa_factorsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMfa_factorsInput
    connect?: usersWhereUniqueInput
  }

  export type mfa_challengesUncheckedCreateNestedManyWithoutMfa_factorsInput = {
    create?: XOR<mfa_challengesCreateWithoutMfa_factorsInput, mfa_challengesUncheckedCreateWithoutMfa_factorsInput> | mfa_challengesCreateWithoutMfa_factorsInput[] | mfa_challengesUncheckedCreateWithoutMfa_factorsInput[]
    connectOrCreate?: mfa_challengesCreateOrConnectWithoutMfa_factorsInput | mfa_challengesCreateOrConnectWithoutMfa_factorsInput[]
    createMany?: mfa_challengesCreateManyMfa_factorsInputEnvelope
    connect?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
  }

  export type Enumfactor_typeFieldUpdateOperationsInput = {
    set?: $Enums.factor_type
  }

  export type Enumfactor_statusFieldUpdateOperationsInput = {
    set?: $Enums.factor_status
  }

  export type mfa_challengesUpdateManyWithoutMfa_factorsNestedInput = {
    create?: XOR<mfa_challengesCreateWithoutMfa_factorsInput, mfa_challengesUncheckedCreateWithoutMfa_factorsInput> | mfa_challengesCreateWithoutMfa_factorsInput[] | mfa_challengesUncheckedCreateWithoutMfa_factorsInput[]
    connectOrCreate?: mfa_challengesCreateOrConnectWithoutMfa_factorsInput | mfa_challengesCreateOrConnectWithoutMfa_factorsInput[]
    upsert?: mfa_challengesUpsertWithWhereUniqueWithoutMfa_factorsInput | mfa_challengesUpsertWithWhereUniqueWithoutMfa_factorsInput[]
    createMany?: mfa_challengesCreateManyMfa_factorsInputEnvelope
    set?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    disconnect?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    delete?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    connect?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    update?: mfa_challengesUpdateWithWhereUniqueWithoutMfa_factorsInput | mfa_challengesUpdateWithWhereUniqueWithoutMfa_factorsInput[]
    updateMany?: mfa_challengesUpdateManyWithWhereWithoutMfa_factorsInput | mfa_challengesUpdateManyWithWhereWithoutMfa_factorsInput[]
    deleteMany?: mfa_challengesScalarWhereInput | mfa_challengesScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutMfa_factorsNestedInput = {
    create?: XOR<usersCreateWithoutMfa_factorsInput, usersUncheckedCreateWithoutMfa_factorsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMfa_factorsInput
    upsert?: usersUpsertWithoutMfa_factorsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMfa_factorsInput, usersUpdateWithoutMfa_factorsInput>, usersUncheckedUpdateWithoutMfa_factorsInput>
  }

  export type mfa_challengesUncheckedUpdateManyWithoutMfa_factorsNestedInput = {
    create?: XOR<mfa_challengesCreateWithoutMfa_factorsInput, mfa_challengesUncheckedCreateWithoutMfa_factorsInput> | mfa_challengesCreateWithoutMfa_factorsInput[] | mfa_challengesUncheckedCreateWithoutMfa_factorsInput[]
    connectOrCreate?: mfa_challengesCreateOrConnectWithoutMfa_factorsInput | mfa_challengesCreateOrConnectWithoutMfa_factorsInput[]
    upsert?: mfa_challengesUpsertWithWhereUniqueWithoutMfa_factorsInput | mfa_challengesUpsertWithWhereUniqueWithoutMfa_factorsInput[]
    createMany?: mfa_challengesCreateManyMfa_factorsInputEnvelope
    set?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    disconnect?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    delete?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    connect?: mfa_challengesWhereUniqueInput | mfa_challengesWhereUniqueInput[]
    update?: mfa_challengesUpdateWithWhereUniqueWithoutMfa_factorsInput | mfa_challengesUpdateWithWhereUniqueWithoutMfa_factorsInput[]
    updateMany?: mfa_challengesUpdateManyWithWhereWithoutMfa_factorsInput | mfa_challengesUpdateManyWithWhereWithoutMfa_factorsInput[]
    deleteMany?: mfa_challengesScalarWhereInput | mfa_challengesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutOne_time_tokensInput = {
    create?: XOR<usersCreateWithoutOne_time_tokensInput, usersUncheckedCreateWithoutOne_time_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutOne_time_tokensInput
    connect?: usersWhereUniqueInput
  }

  export type Enumone_time_token_typeFieldUpdateOperationsInput = {
    set?: $Enums.one_time_token_type
  }

  export type usersUpdateOneRequiredWithoutOne_time_tokensNestedInput = {
    create?: XOR<usersCreateWithoutOne_time_tokensInput, usersUncheckedCreateWithoutOne_time_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutOne_time_tokensInput
    upsert?: usersUpsertWithoutOne_time_tokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOne_time_tokensInput, usersUpdateWithoutOne_time_tokensInput>, usersUncheckedUpdateWithoutOne_time_tokensInput>
  }

  export type sessionsCreateNestedOneWithoutRefresh_tokensInput = {
    create?: XOR<sessionsCreateWithoutRefresh_tokensInput, sessionsUncheckedCreateWithoutRefresh_tokensInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutRefresh_tokensInput
    connect?: sessionsWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type sessionsUpdateOneWithoutRefresh_tokensNestedInput = {
    create?: XOR<sessionsCreateWithoutRefresh_tokensInput, sessionsUncheckedCreateWithoutRefresh_tokensInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutRefresh_tokensInput
    upsert?: sessionsUpsertWithoutRefresh_tokensInput
    disconnect?: sessionsWhereInput | boolean
    delete?: sessionsWhereInput | boolean
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutRefresh_tokensInput, sessionsUpdateWithoutRefresh_tokensInput>, sessionsUncheckedUpdateWithoutRefresh_tokensInput>
  }

  export type sso_providersCreateNestedOneWithoutSaml_providersInput = {
    create?: XOR<sso_providersCreateWithoutSaml_providersInput, sso_providersUncheckedCreateWithoutSaml_providersInput>
    connectOrCreate?: sso_providersCreateOrConnectWithoutSaml_providersInput
    connect?: sso_providersWhereUniqueInput
  }

  export type sso_providersUpdateOneRequiredWithoutSaml_providersNestedInput = {
    create?: XOR<sso_providersCreateWithoutSaml_providersInput, sso_providersUncheckedCreateWithoutSaml_providersInput>
    connectOrCreate?: sso_providersCreateOrConnectWithoutSaml_providersInput
    upsert?: sso_providersUpsertWithoutSaml_providersInput
    connect?: sso_providersWhereUniqueInput
    update?: XOR<XOR<sso_providersUpdateToOneWithWhereWithoutSaml_providersInput, sso_providersUpdateWithoutSaml_providersInput>, sso_providersUncheckedUpdateWithoutSaml_providersInput>
  }

  export type flow_stateCreateNestedOneWithoutSaml_relay_statesInput = {
    create?: XOR<flow_stateCreateWithoutSaml_relay_statesInput, flow_stateUncheckedCreateWithoutSaml_relay_statesInput>
    connectOrCreate?: flow_stateCreateOrConnectWithoutSaml_relay_statesInput
    connect?: flow_stateWhereUniqueInput
  }

  export type sso_providersCreateNestedOneWithoutSaml_relay_statesInput = {
    create?: XOR<sso_providersCreateWithoutSaml_relay_statesInput, sso_providersUncheckedCreateWithoutSaml_relay_statesInput>
    connectOrCreate?: sso_providersCreateOrConnectWithoutSaml_relay_statesInput
    connect?: sso_providersWhereUniqueInput
  }

  export type flow_stateUpdateOneWithoutSaml_relay_statesNestedInput = {
    create?: XOR<flow_stateCreateWithoutSaml_relay_statesInput, flow_stateUncheckedCreateWithoutSaml_relay_statesInput>
    connectOrCreate?: flow_stateCreateOrConnectWithoutSaml_relay_statesInput
    upsert?: flow_stateUpsertWithoutSaml_relay_statesInput
    disconnect?: flow_stateWhereInput | boolean
    delete?: flow_stateWhereInput | boolean
    connect?: flow_stateWhereUniqueInput
    update?: XOR<XOR<flow_stateUpdateToOneWithWhereWithoutSaml_relay_statesInput, flow_stateUpdateWithoutSaml_relay_statesInput>, flow_stateUncheckedUpdateWithoutSaml_relay_statesInput>
  }

  export type sso_providersUpdateOneRequiredWithoutSaml_relay_statesNestedInput = {
    create?: XOR<sso_providersCreateWithoutSaml_relay_statesInput, sso_providersUncheckedCreateWithoutSaml_relay_statesInput>
    connectOrCreate?: sso_providersCreateOrConnectWithoutSaml_relay_statesInput
    upsert?: sso_providersUpsertWithoutSaml_relay_statesInput
    connect?: sso_providersWhereUniqueInput
    update?: XOR<XOR<sso_providersUpdateToOneWithWhereWithoutSaml_relay_statesInput, sso_providersUpdateWithoutSaml_relay_statesInput>, sso_providersUncheckedUpdateWithoutSaml_relay_statesInput>
  }

  export type mfa_amr_claimsCreateNestedManyWithoutSessionsInput = {
    create?: XOR<mfa_amr_claimsCreateWithoutSessionsInput, mfa_amr_claimsUncheckedCreateWithoutSessionsInput> | mfa_amr_claimsCreateWithoutSessionsInput[] | mfa_amr_claimsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: mfa_amr_claimsCreateOrConnectWithoutSessionsInput | mfa_amr_claimsCreateOrConnectWithoutSessionsInput[]
    createMany?: mfa_amr_claimsCreateManySessionsInputEnvelope
    connect?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
  }

  export type refresh_tokensCreateNestedManyWithoutSessionsInput = {
    create?: XOR<refresh_tokensCreateWithoutSessionsInput, refresh_tokensUncheckedCreateWithoutSessionsInput> | refresh_tokensCreateWithoutSessionsInput[] | refresh_tokensUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutSessionsInput | refresh_tokensCreateOrConnectWithoutSessionsInput[]
    createMany?: refresh_tokensCreateManySessionsInputEnvelope
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutSessionsInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    connect?: usersWhereUniqueInput
  }

  export type mfa_amr_claimsUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<mfa_amr_claimsCreateWithoutSessionsInput, mfa_amr_claimsUncheckedCreateWithoutSessionsInput> | mfa_amr_claimsCreateWithoutSessionsInput[] | mfa_amr_claimsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: mfa_amr_claimsCreateOrConnectWithoutSessionsInput | mfa_amr_claimsCreateOrConnectWithoutSessionsInput[]
    createMany?: mfa_amr_claimsCreateManySessionsInputEnvelope
    connect?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
  }

  export type refresh_tokensUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<refresh_tokensCreateWithoutSessionsInput, refresh_tokensUncheckedCreateWithoutSessionsInput> | refresh_tokensCreateWithoutSessionsInput[] | refresh_tokensUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutSessionsInput | refresh_tokensCreateOrConnectWithoutSessionsInput[]
    createMany?: refresh_tokensCreateManySessionsInputEnvelope
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
  }

  export type NullableEnumaal_levelFieldUpdateOperationsInput = {
    set?: $Enums.aal_level | null
  }

  export type mfa_amr_claimsUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<mfa_amr_claimsCreateWithoutSessionsInput, mfa_amr_claimsUncheckedCreateWithoutSessionsInput> | mfa_amr_claimsCreateWithoutSessionsInput[] | mfa_amr_claimsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: mfa_amr_claimsCreateOrConnectWithoutSessionsInput | mfa_amr_claimsCreateOrConnectWithoutSessionsInput[]
    upsert?: mfa_amr_claimsUpsertWithWhereUniqueWithoutSessionsInput | mfa_amr_claimsUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: mfa_amr_claimsCreateManySessionsInputEnvelope
    set?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    disconnect?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    delete?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    connect?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    update?: mfa_amr_claimsUpdateWithWhereUniqueWithoutSessionsInput | mfa_amr_claimsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: mfa_amr_claimsUpdateManyWithWhereWithoutSessionsInput | mfa_amr_claimsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: mfa_amr_claimsScalarWhereInput | mfa_amr_claimsScalarWhereInput[]
  }

  export type refresh_tokensUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<refresh_tokensCreateWithoutSessionsInput, refresh_tokensUncheckedCreateWithoutSessionsInput> | refresh_tokensCreateWithoutSessionsInput[] | refresh_tokensUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutSessionsInput | refresh_tokensCreateOrConnectWithoutSessionsInput[]
    upsert?: refresh_tokensUpsertWithWhereUniqueWithoutSessionsInput | refresh_tokensUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: refresh_tokensCreateManySessionsInputEnvelope
    set?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    disconnect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    delete?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    update?: refresh_tokensUpdateWithWhereUniqueWithoutSessionsInput | refresh_tokensUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: refresh_tokensUpdateManyWithWhereWithoutSessionsInput | refresh_tokensUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    upsert?: usersUpsertWithoutSessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSessionsInput, usersUpdateWithoutSessionsInput>, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type mfa_amr_claimsUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<mfa_amr_claimsCreateWithoutSessionsInput, mfa_amr_claimsUncheckedCreateWithoutSessionsInput> | mfa_amr_claimsCreateWithoutSessionsInput[] | mfa_amr_claimsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: mfa_amr_claimsCreateOrConnectWithoutSessionsInput | mfa_amr_claimsCreateOrConnectWithoutSessionsInput[]
    upsert?: mfa_amr_claimsUpsertWithWhereUniqueWithoutSessionsInput | mfa_amr_claimsUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: mfa_amr_claimsCreateManySessionsInputEnvelope
    set?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    disconnect?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    delete?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    connect?: mfa_amr_claimsWhereUniqueInput | mfa_amr_claimsWhereUniqueInput[]
    update?: mfa_amr_claimsUpdateWithWhereUniqueWithoutSessionsInput | mfa_amr_claimsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: mfa_amr_claimsUpdateManyWithWhereWithoutSessionsInput | mfa_amr_claimsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: mfa_amr_claimsScalarWhereInput | mfa_amr_claimsScalarWhereInput[]
  }

  export type refresh_tokensUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<refresh_tokensCreateWithoutSessionsInput, refresh_tokensUncheckedCreateWithoutSessionsInput> | refresh_tokensCreateWithoutSessionsInput[] | refresh_tokensUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutSessionsInput | refresh_tokensCreateOrConnectWithoutSessionsInput[]
    upsert?: refresh_tokensUpsertWithWhereUniqueWithoutSessionsInput | refresh_tokensUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: refresh_tokensCreateManySessionsInputEnvelope
    set?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    disconnect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    delete?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    update?: refresh_tokensUpdateWithWhereUniqueWithoutSessionsInput | refresh_tokensUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: refresh_tokensUpdateManyWithWhereWithoutSessionsInput | refresh_tokensUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
  }

  export type sso_providersCreateNestedOneWithoutSso_domainsInput = {
    create?: XOR<sso_providersCreateWithoutSso_domainsInput, sso_providersUncheckedCreateWithoutSso_domainsInput>
    connectOrCreate?: sso_providersCreateOrConnectWithoutSso_domainsInput
    connect?: sso_providersWhereUniqueInput
  }

  export type sso_providersUpdateOneRequiredWithoutSso_domainsNestedInput = {
    create?: XOR<sso_providersCreateWithoutSso_domainsInput, sso_providersUncheckedCreateWithoutSso_domainsInput>
    connectOrCreate?: sso_providersCreateOrConnectWithoutSso_domainsInput
    upsert?: sso_providersUpsertWithoutSso_domainsInput
    connect?: sso_providersWhereUniqueInput
    update?: XOR<XOR<sso_providersUpdateToOneWithWhereWithoutSso_domainsInput, sso_providersUpdateWithoutSso_domainsInput>, sso_providersUncheckedUpdateWithoutSso_domainsInput>
  }

  export type saml_providersCreateNestedManyWithoutSso_providersInput = {
    create?: XOR<saml_providersCreateWithoutSso_providersInput, saml_providersUncheckedCreateWithoutSso_providersInput> | saml_providersCreateWithoutSso_providersInput[] | saml_providersUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_providersCreateOrConnectWithoutSso_providersInput | saml_providersCreateOrConnectWithoutSso_providersInput[]
    createMany?: saml_providersCreateManySso_providersInputEnvelope
    connect?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
  }

  export type saml_relay_statesCreateNestedManyWithoutSso_providersInput = {
    create?: XOR<saml_relay_statesCreateWithoutSso_providersInput, saml_relay_statesUncheckedCreateWithoutSso_providersInput> | saml_relay_statesCreateWithoutSso_providersInput[] | saml_relay_statesUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutSso_providersInput | saml_relay_statesCreateOrConnectWithoutSso_providersInput[]
    createMany?: saml_relay_statesCreateManySso_providersInputEnvelope
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
  }

  export type sso_domainsCreateNestedManyWithoutSso_providersInput = {
    create?: XOR<sso_domainsCreateWithoutSso_providersInput, sso_domainsUncheckedCreateWithoutSso_providersInput> | sso_domainsCreateWithoutSso_providersInput[] | sso_domainsUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: sso_domainsCreateOrConnectWithoutSso_providersInput | sso_domainsCreateOrConnectWithoutSso_providersInput[]
    createMany?: sso_domainsCreateManySso_providersInputEnvelope
    connect?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
  }

  export type saml_providersUncheckedCreateNestedManyWithoutSso_providersInput = {
    create?: XOR<saml_providersCreateWithoutSso_providersInput, saml_providersUncheckedCreateWithoutSso_providersInput> | saml_providersCreateWithoutSso_providersInput[] | saml_providersUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_providersCreateOrConnectWithoutSso_providersInput | saml_providersCreateOrConnectWithoutSso_providersInput[]
    createMany?: saml_providersCreateManySso_providersInputEnvelope
    connect?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
  }

  export type saml_relay_statesUncheckedCreateNestedManyWithoutSso_providersInput = {
    create?: XOR<saml_relay_statesCreateWithoutSso_providersInput, saml_relay_statesUncheckedCreateWithoutSso_providersInput> | saml_relay_statesCreateWithoutSso_providersInput[] | saml_relay_statesUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutSso_providersInput | saml_relay_statesCreateOrConnectWithoutSso_providersInput[]
    createMany?: saml_relay_statesCreateManySso_providersInputEnvelope
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
  }

  export type sso_domainsUncheckedCreateNestedManyWithoutSso_providersInput = {
    create?: XOR<sso_domainsCreateWithoutSso_providersInput, sso_domainsUncheckedCreateWithoutSso_providersInput> | sso_domainsCreateWithoutSso_providersInput[] | sso_domainsUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: sso_domainsCreateOrConnectWithoutSso_providersInput | sso_domainsCreateOrConnectWithoutSso_providersInput[]
    createMany?: sso_domainsCreateManySso_providersInputEnvelope
    connect?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
  }

  export type saml_providersUpdateManyWithoutSso_providersNestedInput = {
    create?: XOR<saml_providersCreateWithoutSso_providersInput, saml_providersUncheckedCreateWithoutSso_providersInput> | saml_providersCreateWithoutSso_providersInput[] | saml_providersUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_providersCreateOrConnectWithoutSso_providersInput | saml_providersCreateOrConnectWithoutSso_providersInput[]
    upsert?: saml_providersUpsertWithWhereUniqueWithoutSso_providersInput | saml_providersUpsertWithWhereUniqueWithoutSso_providersInput[]
    createMany?: saml_providersCreateManySso_providersInputEnvelope
    set?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    disconnect?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    delete?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    connect?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    update?: saml_providersUpdateWithWhereUniqueWithoutSso_providersInput | saml_providersUpdateWithWhereUniqueWithoutSso_providersInput[]
    updateMany?: saml_providersUpdateManyWithWhereWithoutSso_providersInput | saml_providersUpdateManyWithWhereWithoutSso_providersInput[]
    deleteMany?: saml_providersScalarWhereInput | saml_providersScalarWhereInput[]
  }

  export type saml_relay_statesUpdateManyWithoutSso_providersNestedInput = {
    create?: XOR<saml_relay_statesCreateWithoutSso_providersInput, saml_relay_statesUncheckedCreateWithoutSso_providersInput> | saml_relay_statesCreateWithoutSso_providersInput[] | saml_relay_statesUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutSso_providersInput | saml_relay_statesCreateOrConnectWithoutSso_providersInput[]
    upsert?: saml_relay_statesUpsertWithWhereUniqueWithoutSso_providersInput | saml_relay_statesUpsertWithWhereUniqueWithoutSso_providersInput[]
    createMany?: saml_relay_statesCreateManySso_providersInputEnvelope
    set?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    disconnect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    delete?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    update?: saml_relay_statesUpdateWithWhereUniqueWithoutSso_providersInput | saml_relay_statesUpdateWithWhereUniqueWithoutSso_providersInput[]
    updateMany?: saml_relay_statesUpdateManyWithWhereWithoutSso_providersInput | saml_relay_statesUpdateManyWithWhereWithoutSso_providersInput[]
    deleteMany?: saml_relay_statesScalarWhereInput | saml_relay_statesScalarWhereInput[]
  }

  export type sso_domainsUpdateManyWithoutSso_providersNestedInput = {
    create?: XOR<sso_domainsCreateWithoutSso_providersInput, sso_domainsUncheckedCreateWithoutSso_providersInput> | sso_domainsCreateWithoutSso_providersInput[] | sso_domainsUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: sso_domainsCreateOrConnectWithoutSso_providersInput | sso_domainsCreateOrConnectWithoutSso_providersInput[]
    upsert?: sso_domainsUpsertWithWhereUniqueWithoutSso_providersInput | sso_domainsUpsertWithWhereUniqueWithoutSso_providersInput[]
    createMany?: sso_domainsCreateManySso_providersInputEnvelope
    set?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    disconnect?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    delete?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    connect?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    update?: sso_domainsUpdateWithWhereUniqueWithoutSso_providersInput | sso_domainsUpdateWithWhereUniqueWithoutSso_providersInput[]
    updateMany?: sso_domainsUpdateManyWithWhereWithoutSso_providersInput | sso_domainsUpdateManyWithWhereWithoutSso_providersInput[]
    deleteMany?: sso_domainsScalarWhereInput | sso_domainsScalarWhereInput[]
  }

  export type saml_providersUncheckedUpdateManyWithoutSso_providersNestedInput = {
    create?: XOR<saml_providersCreateWithoutSso_providersInput, saml_providersUncheckedCreateWithoutSso_providersInput> | saml_providersCreateWithoutSso_providersInput[] | saml_providersUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_providersCreateOrConnectWithoutSso_providersInput | saml_providersCreateOrConnectWithoutSso_providersInput[]
    upsert?: saml_providersUpsertWithWhereUniqueWithoutSso_providersInput | saml_providersUpsertWithWhereUniqueWithoutSso_providersInput[]
    createMany?: saml_providersCreateManySso_providersInputEnvelope
    set?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    disconnect?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    delete?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    connect?: saml_providersWhereUniqueInput | saml_providersWhereUniqueInput[]
    update?: saml_providersUpdateWithWhereUniqueWithoutSso_providersInput | saml_providersUpdateWithWhereUniqueWithoutSso_providersInput[]
    updateMany?: saml_providersUpdateManyWithWhereWithoutSso_providersInput | saml_providersUpdateManyWithWhereWithoutSso_providersInput[]
    deleteMany?: saml_providersScalarWhereInput | saml_providersScalarWhereInput[]
  }

  export type saml_relay_statesUncheckedUpdateManyWithoutSso_providersNestedInput = {
    create?: XOR<saml_relay_statesCreateWithoutSso_providersInput, saml_relay_statesUncheckedCreateWithoutSso_providersInput> | saml_relay_statesCreateWithoutSso_providersInput[] | saml_relay_statesUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: saml_relay_statesCreateOrConnectWithoutSso_providersInput | saml_relay_statesCreateOrConnectWithoutSso_providersInput[]
    upsert?: saml_relay_statesUpsertWithWhereUniqueWithoutSso_providersInput | saml_relay_statesUpsertWithWhereUniqueWithoutSso_providersInput[]
    createMany?: saml_relay_statesCreateManySso_providersInputEnvelope
    set?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    disconnect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    delete?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    connect?: saml_relay_statesWhereUniqueInput | saml_relay_statesWhereUniqueInput[]
    update?: saml_relay_statesUpdateWithWhereUniqueWithoutSso_providersInput | saml_relay_statesUpdateWithWhereUniqueWithoutSso_providersInput[]
    updateMany?: saml_relay_statesUpdateManyWithWhereWithoutSso_providersInput | saml_relay_statesUpdateManyWithWhereWithoutSso_providersInput[]
    deleteMany?: saml_relay_statesScalarWhereInput | saml_relay_statesScalarWhereInput[]
  }

  export type sso_domainsUncheckedUpdateManyWithoutSso_providersNestedInput = {
    create?: XOR<sso_domainsCreateWithoutSso_providersInput, sso_domainsUncheckedCreateWithoutSso_providersInput> | sso_domainsCreateWithoutSso_providersInput[] | sso_domainsUncheckedCreateWithoutSso_providersInput[]
    connectOrCreate?: sso_domainsCreateOrConnectWithoutSso_providersInput | sso_domainsCreateOrConnectWithoutSso_providersInput[]
    upsert?: sso_domainsUpsertWithWhereUniqueWithoutSso_providersInput | sso_domainsUpsertWithWhereUniqueWithoutSso_providersInput[]
    createMany?: sso_domainsCreateManySso_providersInputEnvelope
    set?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    disconnect?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    delete?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    connect?: sso_domainsWhereUniqueInput | sso_domainsWhereUniqueInput[]
    update?: sso_domainsUpdateWithWhereUniqueWithoutSso_providersInput | sso_domainsUpdateWithWhereUniqueWithoutSso_providersInput[]
    updateMany?: sso_domainsUpdateManyWithWhereWithoutSso_providersInput | sso_domainsUpdateManyWithWhereWithoutSso_providersInput[]
    deleteMany?: sso_domainsScalarWhereInput | sso_domainsScalarWhereInput[]
  }

  export type identitiesCreateNestedManyWithoutUsersInput = {
    create?: XOR<identitiesCreateWithoutUsersInput, identitiesUncheckedCreateWithoutUsersInput> | identitiesCreateWithoutUsersInput[] | identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: identitiesCreateOrConnectWithoutUsersInput | identitiesCreateOrConnectWithoutUsersInput[]
    createMany?: identitiesCreateManyUsersInputEnvelope
    connect?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
  }

  export type mfa_factorsCreateNestedManyWithoutUsersInput = {
    create?: XOR<mfa_factorsCreateWithoutUsersInput, mfa_factorsUncheckedCreateWithoutUsersInput> | mfa_factorsCreateWithoutUsersInput[] | mfa_factorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mfa_factorsCreateOrConnectWithoutUsersInput | mfa_factorsCreateOrConnectWithoutUsersInput[]
    createMany?: mfa_factorsCreateManyUsersInputEnvelope
    connect?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
  }

  export type one_time_tokensCreateNestedManyWithoutUsersInput = {
    create?: XOR<one_time_tokensCreateWithoutUsersInput, one_time_tokensUncheckedCreateWithoutUsersInput> | one_time_tokensCreateWithoutUsersInput[] | one_time_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: one_time_tokensCreateOrConnectWithoutUsersInput | one_time_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: one_time_tokensCreateManyUsersInputEnvelope
    connect?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type profilesTableCreateNestedOneWithoutUsersInput = {
    create?: XOR<profilesTableCreateWithoutUsersInput, profilesTableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesTableCreateOrConnectWithoutUsersInput
    connect?: profilesTableWhereUniqueInput
  }

  export type identitiesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<identitiesCreateWithoutUsersInput, identitiesUncheckedCreateWithoutUsersInput> | identitiesCreateWithoutUsersInput[] | identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: identitiesCreateOrConnectWithoutUsersInput | identitiesCreateOrConnectWithoutUsersInput[]
    createMany?: identitiesCreateManyUsersInputEnvelope
    connect?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
  }

  export type mfa_factorsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<mfa_factorsCreateWithoutUsersInput, mfa_factorsUncheckedCreateWithoutUsersInput> | mfa_factorsCreateWithoutUsersInput[] | mfa_factorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mfa_factorsCreateOrConnectWithoutUsersInput | mfa_factorsCreateOrConnectWithoutUsersInput[]
    createMany?: mfa_factorsCreateManyUsersInputEnvelope
    connect?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
  }

  export type one_time_tokensUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<one_time_tokensCreateWithoutUsersInput, one_time_tokensUncheckedCreateWithoutUsersInput> | one_time_tokensCreateWithoutUsersInput[] | one_time_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: one_time_tokensCreateOrConnectWithoutUsersInput | one_time_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: one_time_tokensCreateManyUsersInputEnvelope
    connect?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type profilesTableUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<profilesTableCreateWithoutUsersInput, profilesTableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesTableCreateOrConnectWithoutUsersInput
    connect?: profilesTableWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type identitiesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<identitiesCreateWithoutUsersInput, identitiesUncheckedCreateWithoutUsersInput> | identitiesCreateWithoutUsersInput[] | identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: identitiesCreateOrConnectWithoutUsersInput | identitiesCreateOrConnectWithoutUsersInput[]
    upsert?: identitiesUpsertWithWhereUniqueWithoutUsersInput | identitiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: identitiesCreateManyUsersInputEnvelope
    set?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    disconnect?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    delete?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    connect?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    update?: identitiesUpdateWithWhereUniqueWithoutUsersInput | identitiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: identitiesUpdateManyWithWhereWithoutUsersInput | identitiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: identitiesScalarWhereInput | identitiesScalarWhereInput[]
  }

  export type mfa_factorsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<mfa_factorsCreateWithoutUsersInput, mfa_factorsUncheckedCreateWithoutUsersInput> | mfa_factorsCreateWithoutUsersInput[] | mfa_factorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mfa_factorsCreateOrConnectWithoutUsersInput | mfa_factorsCreateOrConnectWithoutUsersInput[]
    upsert?: mfa_factorsUpsertWithWhereUniqueWithoutUsersInput | mfa_factorsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: mfa_factorsCreateManyUsersInputEnvelope
    set?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    disconnect?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    delete?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    connect?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    update?: mfa_factorsUpdateWithWhereUniqueWithoutUsersInput | mfa_factorsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: mfa_factorsUpdateManyWithWhereWithoutUsersInput | mfa_factorsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: mfa_factorsScalarWhereInput | mfa_factorsScalarWhereInput[]
  }

  export type one_time_tokensUpdateManyWithoutUsersNestedInput = {
    create?: XOR<one_time_tokensCreateWithoutUsersInput, one_time_tokensUncheckedCreateWithoutUsersInput> | one_time_tokensCreateWithoutUsersInput[] | one_time_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: one_time_tokensCreateOrConnectWithoutUsersInput | one_time_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: one_time_tokensUpsertWithWhereUniqueWithoutUsersInput | one_time_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: one_time_tokensCreateManyUsersInputEnvelope
    set?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    disconnect?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    delete?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    connect?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    update?: one_time_tokensUpdateWithWhereUniqueWithoutUsersInput | one_time_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: one_time_tokensUpdateManyWithWhereWithoutUsersInput | one_time_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: one_time_tokensScalarWhereInput | one_time_tokensScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type profilesTableUpdateOneWithoutUsersNestedInput = {
    create?: XOR<profilesTableCreateWithoutUsersInput, profilesTableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesTableCreateOrConnectWithoutUsersInput
    upsert?: profilesTableUpsertWithoutUsersInput
    disconnect?: profilesTableWhereInput | boolean
    delete?: profilesTableWhereInput | boolean
    connect?: profilesTableWhereUniqueInput
    update?: XOR<XOR<profilesTableUpdateToOneWithWhereWithoutUsersInput, profilesTableUpdateWithoutUsersInput>, profilesTableUncheckedUpdateWithoutUsersInput>
  }

  export type identitiesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<identitiesCreateWithoutUsersInput, identitiesUncheckedCreateWithoutUsersInput> | identitiesCreateWithoutUsersInput[] | identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: identitiesCreateOrConnectWithoutUsersInput | identitiesCreateOrConnectWithoutUsersInput[]
    upsert?: identitiesUpsertWithWhereUniqueWithoutUsersInput | identitiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: identitiesCreateManyUsersInputEnvelope
    set?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    disconnect?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    delete?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    connect?: identitiesWhereUniqueInput | identitiesWhereUniqueInput[]
    update?: identitiesUpdateWithWhereUniqueWithoutUsersInput | identitiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: identitiesUpdateManyWithWhereWithoutUsersInput | identitiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: identitiesScalarWhereInput | identitiesScalarWhereInput[]
  }

  export type mfa_factorsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<mfa_factorsCreateWithoutUsersInput, mfa_factorsUncheckedCreateWithoutUsersInput> | mfa_factorsCreateWithoutUsersInput[] | mfa_factorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mfa_factorsCreateOrConnectWithoutUsersInput | mfa_factorsCreateOrConnectWithoutUsersInput[]
    upsert?: mfa_factorsUpsertWithWhereUniqueWithoutUsersInput | mfa_factorsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: mfa_factorsCreateManyUsersInputEnvelope
    set?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    disconnect?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    delete?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    connect?: mfa_factorsWhereUniqueInput | mfa_factorsWhereUniqueInput[]
    update?: mfa_factorsUpdateWithWhereUniqueWithoutUsersInput | mfa_factorsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: mfa_factorsUpdateManyWithWhereWithoutUsersInput | mfa_factorsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: mfa_factorsScalarWhereInput | mfa_factorsScalarWhereInput[]
  }

  export type one_time_tokensUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<one_time_tokensCreateWithoutUsersInput, one_time_tokensUncheckedCreateWithoutUsersInput> | one_time_tokensCreateWithoutUsersInput[] | one_time_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: one_time_tokensCreateOrConnectWithoutUsersInput | one_time_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: one_time_tokensUpsertWithWhereUniqueWithoutUsersInput | one_time_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: one_time_tokensCreateManyUsersInputEnvelope
    set?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    disconnect?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    delete?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    connect?: one_time_tokensWhereUniqueInput | one_time_tokensWhereUniqueInput[]
    update?: one_time_tokensUpdateWithWhereUniqueWithoutUsersInput | one_time_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: one_time_tokensUpdateManyWithWhereWithoutUsersInput | one_time_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: one_time_tokensScalarWhereInput | one_time_tokensScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type profilesTableUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<profilesTableCreateWithoutUsersInput, profilesTableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesTableCreateOrConnectWithoutUsersInput
    upsert?: profilesTableUpsertWithoutUsersInput
    disconnect?: profilesTableWhereInput | boolean
    delete?: profilesTableWhereInput | boolean
    connect?: profilesTableWhereUniqueInput
    update?: XOR<XOR<profilesTableUpdateToOneWithWhereWithoutUsersInput, profilesTableUpdateWithoutUsersInput>, profilesTableUncheckedUpdateWithoutUsersInput>
  }

  export type cropTableCreateNestedOneWithoutCropStakeholdersTableInput = {
    create?: XOR<cropTableCreateWithoutCropStakeholdersTableInput, cropTableUncheckedCreateWithoutCropStakeholdersTableInput>
    connectOrCreate?: cropTableCreateOrConnectWithoutCropStakeholdersTableInput
    connect?: cropTableWhereUniqueInput
  }

  export type organizationsTableCreateNestedOneWithoutCropStakeholdersTableInput = {
    create?: XOR<organizationsTableCreateWithoutCropStakeholdersTableInput, organizationsTableUncheckedCreateWithoutCropStakeholdersTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutCropStakeholdersTableInput
    connect?: organizationsTableWhereUniqueInput
  }

  export type stakeholderTypesTableCreateNestedOneWithoutCropStakeholdersTableInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutCropStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutCropStakeholdersTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutCropStakeholdersTableInput
    connect?: stakeholderTypesTableWhereUniqueInput
  }

  export type cropTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput = {
    create?: XOR<cropTableCreateWithoutCropStakeholdersTableInput, cropTableUncheckedCreateWithoutCropStakeholdersTableInput>
    connectOrCreate?: cropTableCreateOrConnectWithoutCropStakeholdersTableInput
    upsert?: cropTableUpsertWithoutCropStakeholdersTableInput
    connect?: cropTableWhereUniqueInput
    update?: XOR<XOR<cropTableUpdateToOneWithWhereWithoutCropStakeholdersTableInput, cropTableUpdateWithoutCropStakeholdersTableInput>, cropTableUncheckedUpdateWithoutCropStakeholdersTableInput>
  }

  export type organizationsTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput = {
    create?: XOR<organizationsTableCreateWithoutCropStakeholdersTableInput, organizationsTableUncheckedCreateWithoutCropStakeholdersTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutCropStakeholdersTableInput
    upsert?: organizationsTableUpsertWithoutCropStakeholdersTableInput
    connect?: organizationsTableWhereUniqueInput
    update?: XOR<XOR<organizationsTableUpdateToOneWithWhereWithoutCropStakeholdersTableInput, organizationsTableUpdateWithoutCropStakeholdersTableInput>, organizationsTableUncheckedUpdateWithoutCropStakeholdersTableInput>
  }

  export type stakeholderTypesTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutCropStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutCropStakeholdersTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutCropStakeholdersTableInput
    upsert?: stakeholderTypesTableUpsertWithoutCropStakeholdersTableInput
    connect?: stakeholderTypesTableWhereUniqueInput
    update?: XOR<XOR<stakeholderTypesTableUpdateToOneWithWhereWithoutCropStakeholdersTableInput, stakeholderTypesTableUpdateWithoutCropStakeholdersTableInput>, stakeholderTypesTableUncheckedUpdateWithoutCropStakeholdersTableInput>
  }

  export type cropStakeholdersTableCreateNestedManyWithoutCropTableInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutCropTableInput, cropStakeholdersTableUncheckedCreateWithoutCropTableInput> | cropStakeholdersTableCreateWithoutCropTableInput[] | cropStakeholdersTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutCropTableInput | cropStakeholdersTableCreateOrConnectWithoutCropTableInput[]
    createMany?: cropStakeholdersTableCreateManyCropTableInputEnvelope
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
  }

  export type csvObjTableCreateNestedOneWithoutCropTableInput = {
    create?: XOR<csvObjTableCreateWithoutCropTableInput, csvObjTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutCropTableInput
    connect?: csvObjTableWhereUniqueInput
  }

  export type organizationsTableCreateNestedOneWithoutCropTableInput = {
    create?: XOR<organizationsTableCreateWithoutCropTableInput, organizationsTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutCropTableInput
    connect?: organizationsTableWhereUniqueInput
  }

  export type projectsTableCreateNestedOneWithoutCropTableInput = {
    create?: XOR<projectsTableCreateWithoutCropTableInput, projectsTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: projectsTableCreateOrConnectWithoutCropTableInput
    connect?: projectsTableWhereUniqueInput
  }

  export type speciesTableCreateNestedOneWithoutCropTableInput = {
    create?: XOR<speciesTableCreateWithoutCropTableInput, speciesTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: speciesTableCreateOrConnectWithoutCropTableInput
    connect?: speciesTableWhereUniqueInput
  }

  export type plantingTableCreateNestedManyWithoutCropTableInput = {
    create?: XOR<plantingTableCreateWithoutCropTableInput, plantingTableUncheckedCreateWithoutCropTableInput> | plantingTableCreateWithoutCropTableInput[] | plantingTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutCropTableInput | plantingTableCreateOrConnectWithoutCropTableInput[]
    createMany?: plantingTableCreateManyCropTableInputEnvelope
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
  }

  export type cropStakeholdersTableUncheckedCreateNestedManyWithoutCropTableInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutCropTableInput, cropStakeholdersTableUncheckedCreateWithoutCropTableInput> | cropStakeholdersTableCreateWithoutCropTableInput[] | cropStakeholdersTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutCropTableInput | cropStakeholdersTableCreateOrConnectWithoutCropTableInput[]
    createMany?: cropStakeholdersTableCreateManyCropTableInputEnvelope
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
  }

  export type plantingTableUncheckedCreateNestedManyWithoutCropTableInput = {
    create?: XOR<plantingTableCreateWithoutCropTableInput, plantingTableUncheckedCreateWithoutCropTableInput> | plantingTableCreateWithoutCropTableInput[] | plantingTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutCropTableInput | plantingTableCreateOrConnectWithoutCropTableInput[]
    createMany?: plantingTableCreateManyCropTableInputEnvelope
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
  }

  export type cropStakeholdersTableUpdateManyWithoutCropTableNestedInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutCropTableInput, cropStakeholdersTableUncheckedCreateWithoutCropTableInput> | cropStakeholdersTableCreateWithoutCropTableInput[] | cropStakeholdersTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutCropTableInput | cropStakeholdersTableCreateOrConnectWithoutCropTableInput[]
    upsert?: cropStakeholdersTableUpsertWithWhereUniqueWithoutCropTableInput | cropStakeholdersTableUpsertWithWhereUniqueWithoutCropTableInput[]
    createMany?: cropStakeholdersTableCreateManyCropTableInputEnvelope
    set?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    disconnect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    delete?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    update?: cropStakeholdersTableUpdateWithWhereUniqueWithoutCropTableInput | cropStakeholdersTableUpdateWithWhereUniqueWithoutCropTableInput[]
    updateMany?: cropStakeholdersTableUpdateManyWithWhereWithoutCropTableInput | cropStakeholdersTableUpdateManyWithWhereWithoutCropTableInput[]
    deleteMany?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
  }

  export type csvObjTableUpdateOneWithoutCropTableNestedInput = {
    create?: XOR<csvObjTableCreateWithoutCropTableInput, csvObjTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutCropTableInput
    upsert?: csvObjTableUpsertWithoutCropTableInput
    disconnect?: csvObjTableWhereInput | boolean
    delete?: csvObjTableWhereInput | boolean
    connect?: csvObjTableWhereUniqueInput
    update?: XOR<XOR<csvObjTableUpdateToOneWithWhereWithoutCropTableInput, csvObjTableUpdateWithoutCropTableInput>, csvObjTableUncheckedUpdateWithoutCropTableInput>
  }

  export type organizationsTableUpdateOneWithoutCropTableNestedInput = {
    create?: XOR<organizationsTableCreateWithoutCropTableInput, organizationsTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutCropTableInput
    upsert?: organizationsTableUpsertWithoutCropTableInput
    disconnect?: organizationsTableWhereInput | boolean
    delete?: organizationsTableWhereInput | boolean
    connect?: organizationsTableWhereUniqueInput
    update?: XOR<XOR<organizationsTableUpdateToOneWithWhereWithoutCropTableInput, organizationsTableUpdateWithoutCropTableInput>, organizationsTableUncheckedUpdateWithoutCropTableInput>
  }

  export type projectsTableUpdateOneWithoutCropTableNestedInput = {
    create?: XOR<projectsTableCreateWithoutCropTableInput, projectsTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: projectsTableCreateOrConnectWithoutCropTableInput
    upsert?: projectsTableUpsertWithoutCropTableInput
    disconnect?: projectsTableWhereInput | boolean
    delete?: projectsTableWhereInput | boolean
    connect?: projectsTableWhereUniqueInput
    update?: XOR<XOR<projectsTableUpdateToOneWithWhereWithoutCropTableInput, projectsTableUpdateWithoutCropTableInput>, projectsTableUncheckedUpdateWithoutCropTableInput>
  }

  export type speciesTableUpdateOneWithoutCropTableNestedInput = {
    create?: XOR<speciesTableCreateWithoutCropTableInput, speciesTableUncheckedCreateWithoutCropTableInput>
    connectOrCreate?: speciesTableCreateOrConnectWithoutCropTableInput
    upsert?: speciesTableUpsertWithoutCropTableInput
    disconnect?: speciesTableWhereInput | boolean
    delete?: speciesTableWhereInput | boolean
    connect?: speciesTableWhereUniqueInput
    update?: XOR<XOR<speciesTableUpdateToOneWithWhereWithoutCropTableInput, speciesTableUpdateWithoutCropTableInput>, speciesTableUncheckedUpdateWithoutCropTableInput>
  }

  export type plantingTableUpdateManyWithoutCropTableNestedInput = {
    create?: XOR<plantingTableCreateWithoutCropTableInput, plantingTableUncheckedCreateWithoutCropTableInput> | plantingTableCreateWithoutCropTableInput[] | plantingTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutCropTableInput | plantingTableCreateOrConnectWithoutCropTableInput[]
    upsert?: plantingTableUpsertWithWhereUniqueWithoutCropTableInput | plantingTableUpsertWithWhereUniqueWithoutCropTableInput[]
    createMany?: plantingTableCreateManyCropTableInputEnvelope
    set?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    disconnect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    delete?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    update?: plantingTableUpdateWithWhereUniqueWithoutCropTableInput | plantingTableUpdateWithWhereUniqueWithoutCropTableInput[]
    updateMany?: plantingTableUpdateManyWithWhereWithoutCropTableInput | plantingTableUpdateManyWithWhereWithoutCropTableInput[]
    deleteMany?: plantingTableScalarWhereInput | plantingTableScalarWhereInput[]
  }

  export type cropStakeholdersTableUncheckedUpdateManyWithoutCropTableNestedInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutCropTableInput, cropStakeholdersTableUncheckedCreateWithoutCropTableInput> | cropStakeholdersTableCreateWithoutCropTableInput[] | cropStakeholdersTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutCropTableInput | cropStakeholdersTableCreateOrConnectWithoutCropTableInput[]
    upsert?: cropStakeholdersTableUpsertWithWhereUniqueWithoutCropTableInput | cropStakeholdersTableUpsertWithWhereUniqueWithoutCropTableInput[]
    createMany?: cropStakeholdersTableCreateManyCropTableInputEnvelope
    set?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    disconnect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    delete?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    update?: cropStakeholdersTableUpdateWithWhereUniqueWithoutCropTableInput | cropStakeholdersTableUpdateWithWhereUniqueWithoutCropTableInput[]
    updateMany?: cropStakeholdersTableUpdateManyWithWhereWithoutCropTableInput | cropStakeholdersTableUpdateManyWithWhereWithoutCropTableInput[]
    deleteMany?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
  }

  export type plantingTableUncheckedUpdateManyWithoutCropTableNestedInput = {
    create?: XOR<plantingTableCreateWithoutCropTableInput, plantingTableUncheckedCreateWithoutCropTableInput> | plantingTableCreateWithoutCropTableInput[] | plantingTableUncheckedCreateWithoutCropTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutCropTableInput | plantingTableCreateOrConnectWithoutCropTableInput[]
    upsert?: plantingTableUpsertWithWhereUniqueWithoutCropTableInput | plantingTableUpsertWithWhereUniqueWithoutCropTableInput[]
    createMany?: plantingTableCreateManyCropTableInputEnvelope
    set?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    disconnect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    delete?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    update?: plantingTableUpdateWithWhereUniqueWithoutCropTableInput | plantingTableUpdateWithWhereUniqueWithoutCropTableInput[]
    updateMany?: plantingTableUpdateManyWithWhereWithoutCropTableInput | plantingTableUpdateManyWithWhereWithoutCropTableInput[]
    deleteMany?: plantingTableScalarWhereInput | plantingTableScalarWhereInput[]
  }

  export type cropTableCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<cropTableCreateWithoutCsvObjTableInput, cropTableUncheckedCreateWithoutCsvObjTableInput> | cropTableCreateWithoutCsvObjTableInput[] | cropTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutCsvObjTableInput | cropTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: cropTableCreateManyCsvObjTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type landTableCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<landTableCreateWithoutCsvObjTableInput, landTableUncheckedCreateWithoutCsvObjTableInput> | landTableCreateWithoutCsvObjTableInput[] | landTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutCsvObjTableInput | landTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: landTableCreateManyCsvObjTableInputEnvelope
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
  }

  export type metadataTableCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<metadataTableCreateWithoutCsvObjTableInput, metadataTableUncheckedCreateWithoutCsvObjTableInput> | metadataTableCreateWithoutCsvObjTableInput[] | metadataTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: metadataTableCreateOrConnectWithoutCsvObjTableInput | metadataTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: metadataTableCreateManyCsvObjTableInputEnvelope
    connect?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
  }

  export type projectsTableCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<projectsTableCreateWithoutCsvObjTableInput, projectsTableUncheckedCreateWithoutCsvObjTableInput> | projectsTableCreateWithoutCsvObjTableInput[] | projectsTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: projectsTableCreateOrConnectWithoutCsvObjTableInput | projectsTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: projectsTableCreateManyCsvObjTableInputEnvelope
    connect?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
  }

  export type cropTableUncheckedCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<cropTableCreateWithoutCsvObjTableInput, cropTableUncheckedCreateWithoutCsvObjTableInput> | cropTableCreateWithoutCsvObjTableInput[] | cropTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutCsvObjTableInput | cropTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: cropTableCreateManyCsvObjTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type landTableUncheckedCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<landTableCreateWithoutCsvObjTableInput, landTableUncheckedCreateWithoutCsvObjTableInput> | landTableCreateWithoutCsvObjTableInput[] | landTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutCsvObjTableInput | landTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: landTableCreateManyCsvObjTableInputEnvelope
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
  }

  export type metadataTableUncheckedCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<metadataTableCreateWithoutCsvObjTableInput, metadataTableUncheckedCreateWithoutCsvObjTableInput> | metadataTableCreateWithoutCsvObjTableInput[] | metadataTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: metadataTableCreateOrConnectWithoutCsvObjTableInput | metadataTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: metadataTableCreateManyCsvObjTableInputEnvelope
    connect?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
  }

  export type projectsTableUncheckedCreateNestedManyWithoutCsvObjTableInput = {
    create?: XOR<projectsTableCreateWithoutCsvObjTableInput, projectsTableUncheckedCreateWithoutCsvObjTableInput> | projectsTableCreateWithoutCsvObjTableInput[] | projectsTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: projectsTableCreateOrConnectWithoutCsvObjTableInput | projectsTableCreateOrConnectWithoutCsvObjTableInput[]
    createMany?: projectsTableCreateManyCsvObjTableInputEnvelope
    connect?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
  }

  export type cropTableUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<cropTableCreateWithoutCsvObjTableInput, cropTableUncheckedCreateWithoutCsvObjTableInput> | cropTableCreateWithoutCsvObjTableInput[] | cropTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutCsvObjTableInput | cropTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutCsvObjTableInput | cropTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: cropTableCreateManyCsvObjTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutCsvObjTableInput | cropTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutCsvObjTableInput | cropTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type landTableUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<landTableCreateWithoutCsvObjTableInput, landTableUncheckedCreateWithoutCsvObjTableInput> | landTableCreateWithoutCsvObjTableInput[] | landTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutCsvObjTableInput | landTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: landTableUpsertWithWhereUniqueWithoutCsvObjTableInput | landTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: landTableCreateManyCsvObjTableInputEnvelope
    set?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    disconnect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    delete?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    update?: landTableUpdateWithWhereUniqueWithoutCsvObjTableInput | landTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: landTableUpdateManyWithWhereWithoutCsvObjTableInput | landTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: landTableScalarWhereInput | landTableScalarWhereInput[]
  }

  export type metadataTableUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<metadataTableCreateWithoutCsvObjTableInput, metadataTableUncheckedCreateWithoutCsvObjTableInput> | metadataTableCreateWithoutCsvObjTableInput[] | metadataTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: metadataTableCreateOrConnectWithoutCsvObjTableInput | metadataTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: metadataTableUpsertWithWhereUniqueWithoutCsvObjTableInput | metadataTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: metadataTableCreateManyCsvObjTableInputEnvelope
    set?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    disconnect?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    delete?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    connect?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    update?: metadataTableUpdateWithWhereUniqueWithoutCsvObjTableInput | metadataTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: metadataTableUpdateManyWithWhereWithoutCsvObjTableInput | metadataTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: metadataTableScalarWhereInput | metadataTableScalarWhereInput[]
  }

  export type projectsTableUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<projectsTableCreateWithoutCsvObjTableInput, projectsTableUncheckedCreateWithoutCsvObjTableInput> | projectsTableCreateWithoutCsvObjTableInput[] | projectsTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: projectsTableCreateOrConnectWithoutCsvObjTableInput | projectsTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: projectsTableUpsertWithWhereUniqueWithoutCsvObjTableInput | projectsTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: projectsTableCreateManyCsvObjTableInputEnvelope
    set?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    disconnect?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    delete?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    connect?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    update?: projectsTableUpdateWithWhereUniqueWithoutCsvObjTableInput | projectsTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: projectsTableUpdateManyWithWhereWithoutCsvObjTableInput | projectsTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: projectsTableScalarWhereInput | projectsTableScalarWhereInput[]
  }

  export type cropTableUncheckedUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<cropTableCreateWithoutCsvObjTableInput, cropTableUncheckedCreateWithoutCsvObjTableInput> | cropTableCreateWithoutCsvObjTableInput[] | cropTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutCsvObjTableInput | cropTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutCsvObjTableInput | cropTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: cropTableCreateManyCsvObjTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutCsvObjTableInput | cropTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutCsvObjTableInput | cropTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type landTableUncheckedUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<landTableCreateWithoutCsvObjTableInput, landTableUncheckedCreateWithoutCsvObjTableInput> | landTableCreateWithoutCsvObjTableInput[] | landTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutCsvObjTableInput | landTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: landTableUpsertWithWhereUniqueWithoutCsvObjTableInput | landTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: landTableCreateManyCsvObjTableInputEnvelope
    set?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    disconnect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    delete?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    update?: landTableUpdateWithWhereUniqueWithoutCsvObjTableInput | landTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: landTableUpdateManyWithWhereWithoutCsvObjTableInput | landTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: landTableScalarWhereInput | landTableScalarWhereInput[]
  }

  export type metadataTableUncheckedUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<metadataTableCreateWithoutCsvObjTableInput, metadataTableUncheckedCreateWithoutCsvObjTableInput> | metadataTableCreateWithoutCsvObjTableInput[] | metadataTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: metadataTableCreateOrConnectWithoutCsvObjTableInput | metadataTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: metadataTableUpsertWithWhereUniqueWithoutCsvObjTableInput | metadataTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: metadataTableCreateManyCsvObjTableInputEnvelope
    set?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    disconnect?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    delete?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    connect?: metadataTableWhereUniqueInput | metadataTableWhereUniqueInput[]
    update?: metadataTableUpdateWithWhereUniqueWithoutCsvObjTableInput | metadataTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: metadataTableUpdateManyWithWhereWithoutCsvObjTableInput | metadataTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: metadataTableScalarWhereInput | metadataTableScalarWhereInput[]
  }

  export type projectsTableUncheckedUpdateManyWithoutCsvObjTableNestedInput = {
    create?: XOR<projectsTableCreateWithoutCsvObjTableInput, projectsTableUncheckedCreateWithoutCsvObjTableInput> | projectsTableCreateWithoutCsvObjTableInput[] | projectsTableUncheckedCreateWithoutCsvObjTableInput[]
    connectOrCreate?: projectsTableCreateOrConnectWithoutCsvObjTableInput | projectsTableCreateOrConnectWithoutCsvObjTableInput[]
    upsert?: projectsTableUpsertWithWhereUniqueWithoutCsvObjTableInput | projectsTableUpsertWithWhereUniqueWithoutCsvObjTableInput[]
    createMany?: projectsTableCreateManyCsvObjTableInputEnvelope
    set?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    disconnect?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    delete?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    connect?: projectsTableWhereUniqueInput | projectsTableWhereUniqueInput[]
    update?: projectsTableUpdateWithWhereUniqueWithoutCsvObjTableInput | projectsTableUpdateWithWhereUniqueWithoutCsvObjTableInput[]
    updateMany?: projectsTableUpdateManyWithWhereWithoutCsvObjTableInput | projectsTableUpdateManyWithWhereWithoutCsvObjTableInput[]
    deleteMany?: projectsTableScalarWhereInput | projectsTableScalarWhereInput[]
  }

  export type landTableCreateNestedOneWithoutLandStakeholdersTableInput = {
    create?: XOR<landTableCreateWithoutLandStakeholdersTableInput, landTableUncheckedCreateWithoutLandStakeholdersTableInput>
    connectOrCreate?: landTableCreateOrConnectWithoutLandStakeholdersTableInput
    connect?: landTableWhereUniqueInput
  }

  export type organizationsTableCreateNestedOneWithoutLandStakeholdersTableInput = {
    create?: XOR<organizationsTableCreateWithoutLandStakeholdersTableInput, organizationsTableUncheckedCreateWithoutLandStakeholdersTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutLandStakeholdersTableInput
    connect?: organizationsTableWhereUniqueInput
  }

  export type stakeholderTypesTableCreateNestedOneWithoutLandStakeholdersTableInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutLandStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutLandStakeholdersTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutLandStakeholdersTableInput
    connect?: stakeholderTypesTableWhereUniqueInput
  }

  export type landTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput = {
    create?: XOR<landTableCreateWithoutLandStakeholdersTableInput, landTableUncheckedCreateWithoutLandStakeholdersTableInput>
    connectOrCreate?: landTableCreateOrConnectWithoutLandStakeholdersTableInput
    upsert?: landTableUpsertWithoutLandStakeholdersTableInput
    connect?: landTableWhereUniqueInput
    update?: XOR<XOR<landTableUpdateToOneWithWhereWithoutLandStakeholdersTableInput, landTableUpdateWithoutLandStakeholdersTableInput>, landTableUncheckedUpdateWithoutLandStakeholdersTableInput>
  }

  export type organizationsTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput = {
    create?: XOR<organizationsTableCreateWithoutLandStakeholdersTableInput, organizationsTableUncheckedCreateWithoutLandStakeholdersTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutLandStakeholdersTableInput
    upsert?: organizationsTableUpsertWithoutLandStakeholdersTableInput
    connect?: organizationsTableWhereUniqueInput
    update?: XOR<XOR<organizationsTableUpdateToOneWithWhereWithoutLandStakeholdersTableInput, organizationsTableUpdateWithoutLandStakeholdersTableInput>, organizationsTableUncheckedUpdateWithoutLandStakeholdersTableInput>
  }

  export type stakeholderTypesTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutLandStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutLandStakeholdersTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutLandStakeholdersTableInput
    upsert?: stakeholderTypesTableUpsertWithoutLandStakeholdersTableInput
    connect?: stakeholderTypesTableWhereUniqueInput
    update?: XOR<XOR<stakeholderTypesTableUpdateToOneWithWhereWithoutLandStakeholdersTableInput, stakeholderTypesTableUpdateWithoutLandStakeholdersTableInput>, stakeholderTypesTableUncheckedUpdateWithoutLandStakeholdersTableInput>
  }

  export type landStakeholdersTableCreateNestedManyWithoutLandTableInput = {
    create?: XOR<landStakeholdersTableCreateWithoutLandTableInput, landStakeholdersTableUncheckedCreateWithoutLandTableInput> | landStakeholdersTableCreateWithoutLandTableInput[] | landStakeholdersTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutLandTableInput | landStakeholdersTableCreateOrConnectWithoutLandTableInput[]
    createMany?: landStakeholdersTableCreateManyLandTableInputEnvelope
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
  }

  export type csvObjTableCreateNestedOneWithoutLandTableInput = {
    create?: XOR<csvObjTableCreateWithoutLandTableInput, csvObjTableUncheckedCreateWithoutLandTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutLandTableInput
    connect?: csvObjTableWhereUniqueInput
  }

  export type projectsTableCreateNestedOneWithoutLandTableInput = {
    create?: XOR<projectsTableCreateWithoutLandTableInput, projectsTableUncheckedCreateWithoutLandTableInput>
    connectOrCreate?: projectsTableCreateOrConnectWithoutLandTableInput
    connect?: projectsTableWhereUniqueInput
  }

  export type plantingTableCreateNestedManyWithoutLandTableInput = {
    create?: XOR<plantingTableCreateWithoutLandTableInput, plantingTableUncheckedCreateWithoutLandTableInput> | plantingTableCreateWithoutLandTableInput[] | plantingTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutLandTableInput | plantingTableCreateOrConnectWithoutLandTableInput[]
    createMany?: plantingTableCreateManyLandTableInputEnvelope
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
  }

  export type landStakeholdersTableUncheckedCreateNestedManyWithoutLandTableInput = {
    create?: XOR<landStakeholdersTableCreateWithoutLandTableInput, landStakeholdersTableUncheckedCreateWithoutLandTableInput> | landStakeholdersTableCreateWithoutLandTableInput[] | landStakeholdersTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutLandTableInput | landStakeholdersTableCreateOrConnectWithoutLandTableInput[]
    createMany?: landStakeholdersTableCreateManyLandTableInputEnvelope
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
  }

  export type plantingTableUncheckedCreateNestedManyWithoutLandTableInput = {
    create?: XOR<plantingTableCreateWithoutLandTableInput, plantingTableUncheckedCreateWithoutLandTableInput> | plantingTableCreateWithoutLandTableInput[] | plantingTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutLandTableInput | plantingTableCreateOrConnectWithoutLandTableInput[]
    createMany?: plantingTableCreateManyLandTableInputEnvelope
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumPreparationFieldUpdateOperationsInput = {
    set?: $Enums.Preparation | null
  }

  export type landStakeholdersTableUpdateManyWithoutLandTableNestedInput = {
    create?: XOR<landStakeholdersTableCreateWithoutLandTableInput, landStakeholdersTableUncheckedCreateWithoutLandTableInput> | landStakeholdersTableCreateWithoutLandTableInput[] | landStakeholdersTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutLandTableInput | landStakeholdersTableCreateOrConnectWithoutLandTableInput[]
    upsert?: landStakeholdersTableUpsertWithWhereUniqueWithoutLandTableInput | landStakeholdersTableUpsertWithWhereUniqueWithoutLandTableInput[]
    createMany?: landStakeholdersTableCreateManyLandTableInputEnvelope
    set?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    disconnect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    delete?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    update?: landStakeholdersTableUpdateWithWhereUniqueWithoutLandTableInput | landStakeholdersTableUpdateWithWhereUniqueWithoutLandTableInput[]
    updateMany?: landStakeholdersTableUpdateManyWithWhereWithoutLandTableInput | landStakeholdersTableUpdateManyWithWhereWithoutLandTableInput[]
    deleteMany?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
  }

  export type csvObjTableUpdateOneWithoutLandTableNestedInput = {
    create?: XOR<csvObjTableCreateWithoutLandTableInput, csvObjTableUncheckedCreateWithoutLandTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutLandTableInput
    upsert?: csvObjTableUpsertWithoutLandTableInput
    disconnect?: csvObjTableWhereInput | boolean
    delete?: csvObjTableWhereInput | boolean
    connect?: csvObjTableWhereUniqueInput
    update?: XOR<XOR<csvObjTableUpdateToOneWithWhereWithoutLandTableInput, csvObjTableUpdateWithoutLandTableInput>, csvObjTableUncheckedUpdateWithoutLandTableInput>
  }

  export type projectsTableUpdateOneWithoutLandTableNestedInput = {
    create?: XOR<projectsTableCreateWithoutLandTableInput, projectsTableUncheckedCreateWithoutLandTableInput>
    connectOrCreate?: projectsTableCreateOrConnectWithoutLandTableInput
    upsert?: projectsTableUpsertWithoutLandTableInput
    disconnect?: projectsTableWhereInput | boolean
    delete?: projectsTableWhereInput | boolean
    connect?: projectsTableWhereUniqueInput
    update?: XOR<XOR<projectsTableUpdateToOneWithWhereWithoutLandTableInput, projectsTableUpdateWithoutLandTableInput>, projectsTableUncheckedUpdateWithoutLandTableInput>
  }

  export type plantingTableUpdateManyWithoutLandTableNestedInput = {
    create?: XOR<plantingTableCreateWithoutLandTableInput, plantingTableUncheckedCreateWithoutLandTableInput> | plantingTableCreateWithoutLandTableInput[] | plantingTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutLandTableInput | plantingTableCreateOrConnectWithoutLandTableInput[]
    upsert?: plantingTableUpsertWithWhereUniqueWithoutLandTableInput | plantingTableUpsertWithWhereUniqueWithoutLandTableInput[]
    createMany?: plantingTableCreateManyLandTableInputEnvelope
    set?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    disconnect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    delete?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    update?: plantingTableUpdateWithWhereUniqueWithoutLandTableInput | plantingTableUpdateWithWhereUniqueWithoutLandTableInput[]
    updateMany?: plantingTableUpdateManyWithWhereWithoutLandTableInput | plantingTableUpdateManyWithWhereWithoutLandTableInput[]
    deleteMany?: plantingTableScalarWhereInput | plantingTableScalarWhereInput[]
  }

  export type landStakeholdersTableUncheckedUpdateManyWithoutLandTableNestedInput = {
    create?: XOR<landStakeholdersTableCreateWithoutLandTableInput, landStakeholdersTableUncheckedCreateWithoutLandTableInput> | landStakeholdersTableCreateWithoutLandTableInput[] | landStakeholdersTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutLandTableInput | landStakeholdersTableCreateOrConnectWithoutLandTableInput[]
    upsert?: landStakeholdersTableUpsertWithWhereUniqueWithoutLandTableInput | landStakeholdersTableUpsertWithWhereUniqueWithoutLandTableInput[]
    createMany?: landStakeholdersTableCreateManyLandTableInputEnvelope
    set?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    disconnect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    delete?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    update?: landStakeholdersTableUpdateWithWhereUniqueWithoutLandTableInput | landStakeholdersTableUpdateWithWhereUniqueWithoutLandTableInput[]
    updateMany?: landStakeholdersTableUpdateManyWithWhereWithoutLandTableInput | landStakeholdersTableUpdateManyWithWhereWithoutLandTableInput[]
    deleteMany?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
  }

  export type plantingTableUncheckedUpdateManyWithoutLandTableNestedInput = {
    create?: XOR<plantingTableCreateWithoutLandTableInput, plantingTableUncheckedCreateWithoutLandTableInput> | plantingTableCreateWithoutLandTableInput[] | plantingTableUncheckedCreateWithoutLandTableInput[]
    connectOrCreate?: plantingTableCreateOrConnectWithoutLandTableInput | plantingTableCreateOrConnectWithoutLandTableInput[]
    upsert?: plantingTableUpsertWithWhereUniqueWithoutLandTableInput | plantingTableUpsertWithWhereUniqueWithoutLandTableInput[]
    createMany?: plantingTableCreateManyLandTableInputEnvelope
    set?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    disconnect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    delete?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    connect?: plantingTableWhereUniqueInput | plantingTableWhereUniqueInput[]
    update?: plantingTableUpdateWithWhereUniqueWithoutLandTableInput | plantingTableUpdateWithWhereUniqueWithoutLandTableInput[]
    updateMany?: plantingTableUpdateManyWithWhereWithoutLandTableInput | plantingTableUpdateManyWithWhereWithoutLandTableInput[]
    deleteMany?: plantingTableScalarWhereInput | plantingTableScalarWhereInput[]
  }

  export type csvObjTableCreateNestedOneWithoutMetadataTableInput = {
    create?: XOR<csvObjTableCreateWithoutMetadataTableInput, csvObjTableUncheckedCreateWithoutMetadataTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutMetadataTableInput
    connect?: csvObjTableWhereUniqueInput
  }

  export type csvObjTableUpdateOneRequiredWithoutMetadataTableNestedInput = {
    create?: XOR<csvObjTableCreateWithoutMetadataTableInput, csvObjTableUncheckedCreateWithoutMetadataTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutMetadataTableInput
    upsert?: csvObjTableUpsertWithoutMetadataTableInput
    connect?: csvObjTableWhereUniqueInput
    update?: XOR<XOR<csvObjTableUpdateToOneWithWhereWithoutMetadataTableInput, csvObjTableUpdateWithoutMetadataTableInput>, csvObjTableUncheckedUpdateWithoutMetadataTableInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type cropStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | cropStakeholdersTableCreateWithoutOrganizationsTableInput[] | cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: cropStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
  }

  export type cropTableCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<cropTableCreateWithoutOrganizationsTableInput, cropTableUncheckedCreateWithoutOrganizationsTableInput> | cropTableCreateWithoutOrganizationsTableInput[] | cropTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutOrganizationsTableInput | cropTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: cropTableCreateManyOrganizationsTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type landStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<landStakeholdersTableCreateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | landStakeholdersTableCreateWithoutOrganizationsTableInput[] | landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: landStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
  }

  export type stakeholderTypesTableCreateNestedOneWithoutOrganizationsTableInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutOrganizationsTableInput, stakeholderTypesTableUncheckedCreateWithoutOrganizationsTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutOrganizationsTableInput
    connect?: stakeholderTypesTableWhereUniqueInput
  }

  export type profilesTableCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<profilesTableCreateWithoutOrganizationsTableInput, profilesTableUncheckedCreateWithoutOrganizationsTableInput> | profilesTableCreateWithoutOrganizationsTableInput[] | profilesTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: profilesTableCreateOrConnectWithoutOrganizationsTableInput | profilesTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: profilesTableCreateManyOrganizationsTableInputEnvelope
    connect?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
  }

  export type projectStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | projectStakeholdersTableCreateWithoutOrganizationsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: projectStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
  }

  export type cropStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | cropStakeholdersTableCreateWithoutOrganizationsTableInput[] | cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: cropStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
  }

  export type cropTableUncheckedCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<cropTableCreateWithoutOrganizationsTableInput, cropTableUncheckedCreateWithoutOrganizationsTableInput> | cropTableCreateWithoutOrganizationsTableInput[] | cropTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutOrganizationsTableInput | cropTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: cropTableCreateManyOrganizationsTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type landStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<landStakeholdersTableCreateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | landStakeholdersTableCreateWithoutOrganizationsTableInput[] | landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: landStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
  }

  export type profilesTableUncheckedCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<profilesTableCreateWithoutOrganizationsTableInput, profilesTableUncheckedCreateWithoutOrganizationsTableInput> | profilesTableCreateWithoutOrganizationsTableInput[] | profilesTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: profilesTableCreateOrConnectWithoutOrganizationsTableInput | profilesTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: profilesTableCreateManyOrganizationsTableInputEnvelope
    connect?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
  }

  export type projectStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | projectStakeholdersTableCreateWithoutOrganizationsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    createMany?: projectStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type cropStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | cropStakeholdersTableCreateWithoutOrganizationsTableInput[] | cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: cropStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | cropStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: cropStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    set?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    disconnect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    delete?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    update?: cropStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | cropStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: cropStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput | cropStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
  }

  export type cropTableUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<cropTableCreateWithoutOrganizationsTableInput, cropTableUncheckedCreateWithoutOrganizationsTableInput> | cropTableCreateWithoutOrganizationsTableInput[] | cropTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutOrganizationsTableInput | cropTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | cropTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: cropTableCreateManyOrganizationsTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | cropTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutOrganizationsTableInput | cropTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type landStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<landStakeholdersTableCreateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | landStakeholdersTableCreateWithoutOrganizationsTableInput[] | landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: landStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | landStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: landStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    set?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    disconnect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    delete?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    update?: landStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | landStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: landStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput | landStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
  }

  export type stakeholderTypesTableUpdateOneWithoutOrganizationsTableNestedInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutOrganizationsTableInput, stakeholderTypesTableUncheckedCreateWithoutOrganizationsTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutOrganizationsTableInput
    upsert?: stakeholderTypesTableUpsertWithoutOrganizationsTableInput
    disconnect?: stakeholderTypesTableWhereInput | boolean
    delete?: stakeholderTypesTableWhereInput | boolean
    connect?: stakeholderTypesTableWhereUniqueInput
    update?: XOR<XOR<stakeholderTypesTableUpdateToOneWithWhereWithoutOrganizationsTableInput, stakeholderTypesTableUpdateWithoutOrganizationsTableInput>, stakeholderTypesTableUncheckedUpdateWithoutOrganizationsTableInput>
  }

  export type profilesTableUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<profilesTableCreateWithoutOrganizationsTableInput, profilesTableUncheckedCreateWithoutOrganizationsTableInput> | profilesTableCreateWithoutOrganizationsTableInput[] | profilesTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: profilesTableCreateOrConnectWithoutOrganizationsTableInput | profilesTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: profilesTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | profilesTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: profilesTableCreateManyOrganizationsTableInputEnvelope
    set?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    disconnect?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    delete?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    connect?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    update?: profilesTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | profilesTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: profilesTableUpdateManyWithWhereWithoutOrganizationsTableInput | profilesTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: profilesTableScalarWhereInput | profilesTableScalarWhereInput[]
  }

  export type projectStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | projectStakeholdersTableCreateWithoutOrganizationsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: projectStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | projectStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: projectStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    set?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    disconnect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    delete?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    update?: projectStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | projectStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: projectStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput | projectStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
  }

  export type cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | cropStakeholdersTableCreateWithoutOrganizationsTableInput[] | cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: cropStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | cropStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: cropStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    set?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    disconnect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    delete?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    update?: cropStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | cropStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: cropStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput | cropStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
  }

  export type cropTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<cropTableCreateWithoutOrganizationsTableInput, cropTableUncheckedCreateWithoutOrganizationsTableInput> | cropTableCreateWithoutOrganizationsTableInput[] | cropTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutOrganizationsTableInput | cropTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | cropTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: cropTableCreateManyOrganizationsTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | cropTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutOrganizationsTableInput | cropTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<landStakeholdersTableCreateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | landStakeholdersTableCreateWithoutOrganizationsTableInput[] | landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: landStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | landStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: landStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    set?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    disconnect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    delete?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    update?: landStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | landStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: landStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput | landStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
  }

  export type profilesTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<profilesTableCreateWithoutOrganizationsTableInput, profilesTableUncheckedCreateWithoutOrganizationsTableInput> | profilesTableCreateWithoutOrganizationsTableInput[] | profilesTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: profilesTableCreateOrConnectWithoutOrganizationsTableInput | profilesTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: profilesTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | profilesTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: profilesTableCreateManyOrganizationsTableInputEnvelope
    set?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    disconnect?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    delete?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    connect?: profilesTableWhereUniqueInput | profilesTableWhereUniqueInput[]
    update?: profilesTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | profilesTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: profilesTableUpdateManyWithWhereWithoutOrganizationsTableInput | profilesTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: profilesTableScalarWhereInput | profilesTableScalarWhereInput[]
  }

  export type projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput> | projectStakeholdersTableCreateWithoutOrganizationsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput | projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput[]
    upsert?: projectStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput | projectStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput[]
    createMany?: projectStakeholdersTableCreateManyOrganizationsTableInputEnvelope
    set?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    disconnect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    delete?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    update?: projectStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput | projectStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput[]
    updateMany?: projectStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput | projectStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput[]
    deleteMany?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
  }

  export type cropTableCreateNestedOneWithoutPlantingTableInput = {
    create?: XOR<cropTableCreateWithoutPlantingTableInput, cropTableUncheckedCreateWithoutPlantingTableInput>
    connectOrCreate?: cropTableCreateOrConnectWithoutPlantingTableInput
    connect?: cropTableWhereUniqueInput
  }

  export type landTableCreateNestedOneWithoutPlantingTableInput = {
    create?: XOR<landTableCreateWithoutPlantingTableInput, landTableUncheckedCreateWithoutPlantingTableInput>
    connectOrCreate?: landTableCreateOrConnectWithoutPlantingTableInput
    connect?: landTableWhereUniqueInput
  }

  export type cropTableUpdateOneWithoutPlantingTableNestedInput = {
    create?: XOR<cropTableCreateWithoutPlantingTableInput, cropTableUncheckedCreateWithoutPlantingTableInput>
    connectOrCreate?: cropTableCreateOrConnectWithoutPlantingTableInput
    upsert?: cropTableUpsertWithoutPlantingTableInput
    disconnect?: cropTableWhereInput | boolean
    delete?: cropTableWhereInput | boolean
    connect?: cropTableWhereUniqueInput
    update?: XOR<XOR<cropTableUpdateToOneWithWhereWithoutPlantingTableInput, cropTableUpdateWithoutPlantingTableInput>, cropTableUncheckedUpdateWithoutPlantingTableInput>
  }

  export type landTableUpdateOneWithoutPlantingTableNestedInput = {
    create?: XOR<landTableCreateWithoutPlantingTableInput, landTableUncheckedCreateWithoutPlantingTableInput>
    connectOrCreate?: landTableCreateOrConnectWithoutPlantingTableInput
    upsert?: landTableUpsertWithoutPlantingTableInput
    disconnect?: landTableWhereInput | boolean
    delete?: landTableWhereInput | boolean
    connect?: landTableWhereUniqueInput
    update?: XOR<XOR<landTableUpdateToOneWithWhereWithoutPlantingTableInput, landTableUpdateWithoutPlantingTableInput>, landTableUncheckedUpdateWithoutPlantingTableInput>
  }

  export type organizationsTableCreateNestedOneWithoutProfilesTableInput = {
    create?: XOR<organizationsTableCreateWithoutProfilesTableInput, organizationsTableUncheckedCreateWithoutProfilesTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutProfilesTableInput
    connect?: organizationsTableWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutProfilesTableInput = {
    create?: XOR<usersCreateWithoutProfilesTableInput, usersUncheckedCreateWithoutProfilesTableInput>
    connectOrCreate?: usersCreateOrConnectWithoutProfilesTableInput
    connect?: usersWhereUniqueInput
  }

  export type NullableEnumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role | null
  }

  export type organizationsTableUpdateOneWithoutProfilesTableNestedInput = {
    create?: XOR<organizationsTableCreateWithoutProfilesTableInput, organizationsTableUncheckedCreateWithoutProfilesTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutProfilesTableInput
    upsert?: organizationsTableUpsertWithoutProfilesTableInput
    disconnect?: organizationsTableWhereInput | boolean
    delete?: organizationsTableWhereInput | boolean
    connect?: organizationsTableWhereUniqueInput
    update?: XOR<XOR<organizationsTableUpdateToOneWithWhereWithoutProfilesTableInput, organizationsTableUpdateWithoutProfilesTableInput>, organizationsTableUncheckedUpdateWithoutProfilesTableInput>
  }

  export type usersUpdateOneRequiredWithoutProfilesTableNestedInput = {
    create?: XOR<usersCreateWithoutProfilesTableInput, usersUncheckedCreateWithoutProfilesTableInput>
    connectOrCreate?: usersCreateOrConnectWithoutProfilesTableInput
    upsert?: usersUpsertWithoutProfilesTableInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProfilesTableInput, usersUpdateWithoutProfilesTableInput>, usersUncheckedUpdateWithoutProfilesTableInput>
  }

  export type organizationsTableCreateNestedOneWithoutProjectStakeholdersTableInput = {
    create?: XOR<organizationsTableCreateWithoutProjectStakeholdersTableInput, organizationsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutProjectStakeholdersTableInput
    connect?: organizationsTableWhereUniqueInput
  }

  export type projectsTableCreateNestedOneWithoutProjectStakeholdersTableInput = {
    create?: XOR<projectsTableCreateWithoutProjectStakeholdersTableInput, projectsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    connectOrCreate?: projectsTableCreateOrConnectWithoutProjectStakeholdersTableInput
    connect?: projectsTableWhereUniqueInput
  }

  export type stakeholderTypesTableCreateNestedOneWithoutProjectStakeholdersTableInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutProjectStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutProjectStakeholdersTableInput
    connect?: stakeholderTypesTableWhereUniqueInput
  }

  export type organizationsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput = {
    create?: XOR<organizationsTableCreateWithoutProjectStakeholdersTableInput, organizationsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    connectOrCreate?: organizationsTableCreateOrConnectWithoutProjectStakeholdersTableInput
    upsert?: organizationsTableUpsertWithoutProjectStakeholdersTableInput
    connect?: organizationsTableWhereUniqueInput
    update?: XOR<XOR<organizationsTableUpdateToOneWithWhereWithoutProjectStakeholdersTableInput, organizationsTableUpdateWithoutProjectStakeholdersTableInput>, organizationsTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
  }

  export type projectsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput = {
    create?: XOR<projectsTableCreateWithoutProjectStakeholdersTableInput, projectsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    connectOrCreate?: projectsTableCreateOrConnectWithoutProjectStakeholdersTableInput
    upsert?: projectsTableUpsertWithoutProjectStakeholdersTableInput
    connect?: projectsTableWhereUniqueInput
    update?: XOR<XOR<projectsTableUpdateToOneWithWhereWithoutProjectStakeholdersTableInput, projectsTableUpdateWithoutProjectStakeholdersTableInput>, projectsTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
  }

  export type stakeholderTypesTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput = {
    create?: XOR<stakeholderTypesTableCreateWithoutProjectStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    connectOrCreate?: stakeholderTypesTableCreateOrConnectWithoutProjectStakeholdersTableInput
    upsert?: stakeholderTypesTableUpsertWithoutProjectStakeholdersTableInput
    connect?: stakeholderTypesTableWhereUniqueInput
    update?: XOR<XOR<stakeholderTypesTableUpdateToOneWithWhereWithoutProjectStakeholdersTableInput, stakeholderTypesTableUpdateWithoutProjectStakeholdersTableInput>, stakeholderTypesTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
  }

  export type cropTableCreateNestedManyWithoutProjectsTableInput = {
    create?: XOR<cropTableCreateWithoutProjectsTableInput, cropTableUncheckedCreateWithoutProjectsTableInput> | cropTableCreateWithoutProjectsTableInput[] | cropTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutProjectsTableInput | cropTableCreateOrConnectWithoutProjectsTableInput[]
    createMany?: cropTableCreateManyProjectsTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type landTableCreateNestedManyWithoutProjectsTableInput = {
    create?: XOR<landTableCreateWithoutProjectsTableInput, landTableUncheckedCreateWithoutProjectsTableInput> | landTableCreateWithoutProjectsTableInput[] | landTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutProjectsTableInput | landTableCreateOrConnectWithoutProjectsTableInput[]
    createMany?: landTableCreateManyProjectsTableInputEnvelope
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
  }

  export type projectStakeholdersTableCreateNestedManyWithoutProjectsTableInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutProjectsTableInput, projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput> | projectStakeholdersTableCreateWithoutProjectsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput | projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput[]
    createMany?: projectStakeholdersTableCreateManyProjectsTableInputEnvelope
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
  }

  export type csvObjTableCreateNestedOneWithoutProjectsTableInput = {
    create?: XOR<csvObjTableCreateWithoutProjectsTableInput, csvObjTableUncheckedCreateWithoutProjectsTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutProjectsTableInput
    connect?: csvObjTableWhereUniqueInput
  }

  export type cropTableUncheckedCreateNestedManyWithoutProjectsTableInput = {
    create?: XOR<cropTableCreateWithoutProjectsTableInput, cropTableUncheckedCreateWithoutProjectsTableInput> | cropTableCreateWithoutProjectsTableInput[] | cropTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutProjectsTableInput | cropTableCreateOrConnectWithoutProjectsTableInput[]
    createMany?: cropTableCreateManyProjectsTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type landTableUncheckedCreateNestedManyWithoutProjectsTableInput = {
    create?: XOR<landTableCreateWithoutProjectsTableInput, landTableUncheckedCreateWithoutProjectsTableInput> | landTableCreateWithoutProjectsTableInput[] | landTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutProjectsTableInput | landTableCreateOrConnectWithoutProjectsTableInput[]
    createMany?: landTableCreateManyProjectsTableInputEnvelope
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
  }

  export type projectStakeholdersTableUncheckedCreateNestedManyWithoutProjectsTableInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutProjectsTableInput, projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput> | projectStakeholdersTableCreateWithoutProjectsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput | projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput[]
    createMany?: projectStakeholdersTableCreateManyProjectsTableInputEnvelope
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
  }

  export type cropTableUpdateManyWithoutProjectsTableNestedInput = {
    create?: XOR<cropTableCreateWithoutProjectsTableInput, cropTableUncheckedCreateWithoutProjectsTableInput> | cropTableCreateWithoutProjectsTableInput[] | cropTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutProjectsTableInput | cropTableCreateOrConnectWithoutProjectsTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutProjectsTableInput | cropTableUpsertWithWhereUniqueWithoutProjectsTableInput[]
    createMany?: cropTableCreateManyProjectsTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutProjectsTableInput | cropTableUpdateWithWhereUniqueWithoutProjectsTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutProjectsTableInput | cropTableUpdateManyWithWhereWithoutProjectsTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type landTableUpdateManyWithoutProjectsTableNestedInput = {
    create?: XOR<landTableCreateWithoutProjectsTableInput, landTableUncheckedCreateWithoutProjectsTableInput> | landTableCreateWithoutProjectsTableInput[] | landTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutProjectsTableInput | landTableCreateOrConnectWithoutProjectsTableInput[]
    upsert?: landTableUpsertWithWhereUniqueWithoutProjectsTableInput | landTableUpsertWithWhereUniqueWithoutProjectsTableInput[]
    createMany?: landTableCreateManyProjectsTableInputEnvelope
    set?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    disconnect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    delete?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    update?: landTableUpdateWithWhereUniqueWithoutProjectsTableInput | landTableUpdateWithWhereUniqueWithoutProjectsTableInput[]
    updateMany?: landTableUpdateManyWithWhereWithoutProjectsTableInput | landTableUpdateManyWithWhereWithoutProjectsTableInput[]
    deleteMany?: landTableScalarWhereInput | landTableScalarWhereInput[]
  }

  export type projectStakeholdersTableUpdateManyWithoutProjectsTableNestedInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutProjectsTableInput, projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput> | projectStakeholdersTableCreateWithoutProjectsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput | projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput[]
    upsert?: projectStakeholdersTableUpsertWithWhereUniqueWithoutProjectsTableInput | projectStakeholdersTableUpsertWithWhereUniqueWithoutProjectsTableInput[]
    createMany?: projectStakeholdersTableCreateManyProjectsTableInputEnvelope
    set?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    disconnect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    delete?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    update?: projectStakeholdersTableUpdateWithWhereUniqueWithoutProjectsTableInput | projectStakeholdersTableUpdateWithWhereUniqueWithoutProjectsTableInput[]
    updateMany?: projectStakeholdersTableUpdateManyWithWhereWithoutProjectsTableInput | projectStakeholdersTableUpdateManyWithWhereWithoutProjectsTableInput[]
    deleteMany?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
  }

  export type csvObjTableUpdateOneWithoutProjectsTableNestedInput = {
    create?: XOR<csvObjTableCreateWithoutProjectsTableInput, csvObjTableUncheckedCreateWithoutProjectsTableInput>
    connectOrCreate?: csvObjTableCreateOrConnectWithoutProjectsTableInput
    upsert?: csvObjTableUpsertWithoutProjectsTableInput
    disconnect?: csvObjTableWhereInput | boolean
    delete?: csvObjTableWhereInput | boolean
    connect?: csvObjTableWhereUniqueInput
    update?: XOR<XOR<csvObjTableUpdateToOneWithWhereWithoutProjectsTableInput, csvObjTableUpdateWithoutProjectsTableInput>, csvObjTableUncheckedUpdateWithoutProjectsTableInput>
  }

  export type cropTableUncheckedUpdateManyWithoutProjectsTableNestedInput = {
    create?: XOR<cropTableCreateWithoutProjectsTableInput, cropTableUncheckedCreateWithoutProjectsTableInput> | cropTableCreateWithoutProjectsTableInput[] | cropTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutProjectsTableInput | cropTableCreateOrConnectWithoutProjectsTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutProjectsTableInput | cropTableUpsertWithWhereUniqueWithoutProjectsTableInput[]
    createMany?: cropTableCreateManyProjectsTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutProjectsTableInput | cropTableUpdateWithWhereUniqueWithoutProjectsTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutProjectsTableInput | cropTableUpdateManyWithWhereWithoutProjectsTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type landTableUncheckedUpdateManyWithoutProjectsTableNestedInput = {
    create?: XOR<landTableCreateWithoutProjectsTableInput, landTableUncheckedCreateWithoutProjectsTableInput> | landTableCreateWithoutProjectsTableInput[] | landTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: landTableCreateOrConnectWithoutProjectsTableInput | landTableCreateOrConnectWithoutProjectsTableInput[]
    upsert?: landTableUpsertWithWhereUniqueWithoutProjectsTableInput | landTableUpsertWithWhereUniqueWithoutProjectsTableInput[]
    createMany?: landTableCreateManyProjectsTableInputEnvelope
    set?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    disconnect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    delete?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    connect?: landTableWhereUniqueInput | landTableWhereUniqueInput[]
    update?: landTableUpdateWithWhereUniqueWithoutProjectsTableInput | landTableUpdateWithWhereUniqueWithoutProjectsTableInput[]
    updateMany?: landTableUpdateManyWithWhereWithoutProjectsTableInput | landTableUpdateManyWithWhereWithoutProjectsTableInput[]
    deleteMany?: landTableScalarWhereInput | landTableScalarWhereInput[]
  }

  export type projectStakeholdersTableUncheckedUpdateManyWithoutProjectsTableNestedInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutProjectsTableInput, projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput> | projectStakeholdersTableCreateWithoutProjectsTableInput[] | projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput | projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput[]
    upsert?: projectStakeholdersTableUpsertWithWhereUniqueWithoutProjectsTableInput | projectStakeholdersTableUpsertWithWhereUniqueWithoutProjectsTableInput[]
    createMany?: projectStakeholdersTableCreateManyProjectsTableInputEnvelope
    set?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    disconnect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    delete?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    update?: projectStakeholdersTableUpdateWithWhereUniqueWithoutProjectsTableInput | projectStakeholdersTableUpdateWithWhereUniqueWithoutProjectsTableInput[]
    updateMany?: projectStakeholdersTableUpdateManyWithWhereWithoutProjectsTableInput | projectStakeholdersTableUpdateManyWithWhereWithoutProjectsTableInput[]
    deleteMany?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
  }

  export type cropTableCreateNestedManyWithoutSpeciesTableInput = {
    create?: XOR<cropTableCreateWithoutSpeciesTableInput, cropTableUncheckedCreateWithoutSpeciesTableInput> | cropTableCreateWithoutSpeciesTableInput[] | cropTableUncheckedCreateWithoutSpeciesTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutSpeciesTableInput | cropTableCreateOrConnectWithoutSpeciesTableInput[]
    createMany?: cropTableCreateManySpeciesTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type cropTableUncheckedCreateNestedManyWithoutSpeciesTableInput = {
    create?: XOR<cropTableCreateWithoutSpeciesTableInput, cropTableUncheckedCreateWithoutSpeciesTableInput> | cropTableCreateWithoutSpeciesTableInput[] | cropTableUncheckedCreateWithoutSpeciesTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutSpeciesTableInput | cropTableCreateOrConnectWithoutSpeciesTableInput[]
    createMany?: cropTableCreateManySpeciesTableInputEnvelope
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
  }

  export type cropTableUpdateManyWithoutSpeciesTableNestedInput = {
    create?: XOR<cropTableCreateWithoutSpeciesTableInput, cropTableUncheckedCreateWithoutSpeciesTableInput> | cropTableCreateWithoutSpeciesTableInput[] | cropTableUncheckedCreateWithoutSpeciesTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutSpeciesTableInput | cropTableCreateOrConnectWithoutSpeciesTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutSpeciesTableInput | cropTableUpsertWithWhereUniqueWithoutSpeciesTableInput[]
    createMany?: cropTableCreateManySpeciesTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutSpeciesTableInput | cropTableUpdateWithWhereUniqueWithoutSpeciesTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutSpeciesTableInput | cropTableUpdateManyWithWhereWithoutSpeciesTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type cropTableUncheckedUpdateManyWithoutSpeciesTableNestedInput = {
    create?: XOR<cropTableCreateWithoutSpeciesTableInput, cropTableUncheckedCreateWithoutSpeciesTableInput> | cropTableCreateWithoutSpeciesTableInput[] | cropTableUncheckedCreateWithoutSpeciesTableInput[]
    connectOrCreate?: cropTableCreateOrConnectWithoutSpeciesTableInput | cropTableCreateOrConnectWithoutSpeciesTableInput[]
    upsert?: cropTableUpsertWithWhereUniqueWithoutSpeciesTableInput | cropTableUpsertWithWhereUniqueWithoutSpeciesTableInput[]
    createMany?: cropTableCreateManySpeciesTableInputEnvelope
    set?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    disconnect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    delete?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    connect?: cropTableWhereUniqueInput | cropTableWhereUniqueInput[]
    update?: cropTableUpdateWithWhereUniqueWithoutSpeciesTableInput | cropTableUpdateWithWhereUniqueWithoutSpeciesTableInput[]
    updateMany?: cropTableUpdateManyWithWhereWithoutSpeciesTableInput | cropTableUpdateManyWithWhereWithoutSpeciesTableInput[]
    deleteMany?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
  }

  export type cropStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | cropStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: cropStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
  }

  export type landStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<landStakeholdersTableCreateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | landStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: landStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
  }

  export type organizationsTableCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<organizationsTableCreateWithoutStakeholderTypesTableInput, organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput> | organizationsTableCreateWithoutStakeholderTypesTableInput[] | organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput | organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: organizationsTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
  }

  export type projectStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | projectStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: projectStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
  }

  export type cropStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | cropStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: cropStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
  }

  export type landStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<landStakeholdersTableCreateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | landStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: landStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
  }

  export type organizationsTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<organizationsTableCreateWithoutStakeholderTypesTableInput, organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput> | organizationsTableCreateWithoutStakeholderTypesTableInput[] | organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput | organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: organizationsTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
  }

  export type projectStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | projectStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    createMany?: projectStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
  }

  export type cropStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | cropStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: cropStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | cropStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: cropStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    set?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    disconnect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    delete?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    update?: cropStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | cropStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: cropStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | cropStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
  }

  export type landStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<landStakeholdersTableCreateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | landStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: landStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | landStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: landStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    set?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    disconnect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    delete?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    update?: landStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | landStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: landStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | landStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
  }

  export type organizationsTableUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<organizationsTableCreateWithoutStakeholderTypesTableInput, organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput> | organizationsTableCreateWithoutStakeholderTypesTableInput[] | organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput | organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: organizationsTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | organizationsTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: organizationsTableCreateManyStakeholderTypesTableInputEnvelope
    set?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    disconnect?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    delete?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    connect?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    update?: organizationsTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | organizationsTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: organizationsTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | organizationsTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: organizationsTableScalarWhereInput | organizationsTableScalarWhereInput[]
  }

  export type projectStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | projectStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: projectStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | projectStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: projectStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    set?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    disconnect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    delete?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    update?: projectStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | projectStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: projectStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | projectStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
  }

  export type cropStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<cropStakeholdersTableCreateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | cropStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: cropStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | cropStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: cropStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    set?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    disconnect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    delete?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    connect?: cropStakeholdersTableWhereUniqueInput | cropStakeholdersTableWhereUniqueInput[]
    update?: cropStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | cropStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: cropStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | cropStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
  }

  export type landStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<landStakeholdersTableCreateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | landStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: landStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | landStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: landStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    set?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    disconnect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    delete?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    connect?: landStakeholdersTableWhereUniqueInput | landStakeholdersTableWhereUniqueInput[]
    update?: landStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | landStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: landStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | landStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
  }

  export type organizationsTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<organizationsTableCreateWithoutStakeholderTypesTableInput, organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput> | organizationsTableCreateWithoutStakeholderTypesTableInput[] | organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput | organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: organizationsTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | organizationsTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: organizationsTableCreateManyStakeholderTypesTableInputEnvelope
    set?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    disconnect?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    delete?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    connect?: organizationsTableWhereUniqueInput | organizationsTableWhereUniqueInput[]
    update?: organizationsTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | organizationsTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: organizationsTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | organizationsTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: organizationsTableScalarWhereInput | organizationsTableScalarWhereInput[]
  }

  export type projectStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput = {
    create?: XOR<projectStakeholdersTableCreateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput> | projectStakeholdersTableCreateWithoutStakeholderTypesTableInput[] | projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput[]
    connectOrCreate?: projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput | projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput[]
    upsert?: projectStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput | projectStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput[]
    createMany?: projectStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope
    set?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    disconnect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    delete?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    connect?: projectStakeholdersTableWhereUniqueInput | projectStakeholdersTableWhereUniqueInput[]
    update?: projectStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput | projectStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput[]
    updateMany?: projectStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput | projectStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput[]
    deleteMany?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumcode_challenge_methodFilter<$PrismaModel = never> = {
    equals?: $Enums.code_challenge_method | Enumcode_challenge_methodFieldRefInput<$PrismaModel>
    in?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    notIn?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    not?: NestedEnumcode_challenge_methodFilter<$PrismaModel> | $Enums.code_challenge_method
  }

  export type NestedEnumcode_challenge_methodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.code_challenge_method | Enumcode_challenge_methodFieldRefInput<$PrismaModel>
    in?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    notIn?: $Enums.code_challenge_method[] | ListEnumcode_challenge_methodFieldRefInput<$PrismaModel>
    not?: NestedEnumcode_challenge_methodWithAggregatesFilter<$PrismaModel> | $Enums.code_challenge_method
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcode_challenge_methodFilter<$PrismaModel>
    _max?: NestedEnumcode_challenge_methodFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumfactor_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_type | Enumfactor_typeFieldRefInput<$PrismaModel>
    in?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_typeFilter<$PrismaModel> | $Enums.factor_type
  }

  export type NestedEnumfactor_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_status | Enumfactor_statusFieldRefInput<$PrismaModel>
    in?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_statusFilter<$PrismaModel> | $Enums.factor_status
  }

  export type NestedEnumfactor_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_type | Enumfactor_typeFieldRefInput<$PrismaModel>
    in?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_type[] | ListEnumfactor_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_typeWithAggregatesFilter<$PrismaModel> | $Enums.factor_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfactor_typeFilter<$PrismaModel>
    _max?: NestedEnumfactor_typeFilter<$PrismaModel>
  }

  export type NestedEnumfactor_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.factor_status | Enumfactor_statusFieldRefInput<$PrismaModel>
    in?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.factor_status[] | ListEnumfactor_statusFieldRefInput<$PrismaModel>
    not?: NestedEnumfactor_statusWithAggregatesFilter<$PrismaModel> | $Enums.factor_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfactor_statusFilter<$PrismaModel>
    _max?: NestedEnumfactor_statusFilter<$PrismaModel>
  }

  export type NestedEnumone_time_token_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.one_time_token_type | Enumone_time_token_typeFieldRefInput<$PrismaModel>
    in?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumone_time_token_typeFilter<$PrismaModel> | $Enums.one_time_token_type
  }

  export type NestedEnumone_time_token_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.one_time_token_type | Enumone_time_token_typeFieldRefInput<$PrismaModel>
    in?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.one_time_token_type[] | ListEnumone_time_token_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumone_time_token_typeWithAggregatesFilter<$PrismaModel> | $Enums.one_time_token_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumone_time_token_typeFilter<$PrismaModel>
    _max?: NestedEnumone_time_token_typeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumaal_levelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.aal_level | Enumaal_levelFieldRefInput<$PrismaModel> | null
    in?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumaal_levelNullableFilter<$PrismaModel> | $Enums.aal_level | null
  }

  export type NestedEnumaal_levelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.aal_level | Enumaal_levelFieldRefInput<$PrismaModel> | null
    in?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.aal_level[] | ListEnumaal_levelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumaal_levelNullableWithAggregatesFilter<$PrismaModel> | $Enums.aal_level | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumaal_levelNullableFilter<$PrismaModel>
    _max?: NestedEnumaal_levelNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumPreparationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Preparation | EnumPreparationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPreparationNullableFilter<$PrismaModel> | $Enums.Preparation | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPreparationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Preparation | EnumPreparationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Preparation[] | ListEnumPreparationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPreparationNullableWithAggregatesFilter<$PrismaModel> | $Enums.Preparation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPreparationNullableFilter<$PrismaModel>
    _max?: NestedEnumPreparationNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumuser_roleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableFilter<$PrismaModel> | $Enums.user_role | null
  }

  export type NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_roleNullableFilter<$PrismaModel>
  }

  export type saml_relay_statesCreateWithoutFlow_stateInput = {
    id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    sso_providers: sso_providersCreateNestedOneWithoutSaml_relay_statesInput
  }

  export type saml_relay_statesUncheckedCreateWithoutFlow_stateInput = {
    id: string
    sso_provider_id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type saml_relay_statesCreateOrConnectWithoutFlow_stateInput = {
    where: saml_relay_statesWhereUniqueInput
    create: XOR<saml_relay_statesCreateWithoutFlow_stateInput, saml_relay_statesUncheckedCreateWithoutFlow_stateInput>
  }

  export type saml_relay_statesCreateManyFlow_stateInputEnvelope = {
    data: saml_relay_statesCreateManyFlow_stateInput | saml_relay_statesCreateManyFlow_stateInput[]
    skipDuplicates?: boolean
  }

  export type saml_relay_statesUpsertWithWhereUniqueWithoutFlow_stateInput = {
    where: saml_relay_statesWhereUniqueInput
    update: XOR<saml_relay_statesUpdateWithoutFlow_stateInput, saml_relay_statesUncheckedUpdateWithoutFlow_stateInput>
    create: XOR<saml_relay_statesCreateWithoutFlow_stateInput, saml_relay_statesUncheckedCreateWithoutFlow_stateInput>
  }

  export type saml_relay_statesUpdateWithWhereUniqueWithoutFlow_stateInput = {
    where: saml_relay_statesWhereUniqueInput
    data: XOR<saml_relay_statesUpdateWithoutFlow_stateInput, saml_relay_statesUncheckedUpdateWithoutFlow_stateInput>
  }

  export type saml_relay_statesUpdateManyWithWhereWithoutFlow_stateInput = {
    where: saml_relay_statesScalarWhereInput
    data: XOR<saml_relay_statesUpdateManyMutationInput, saml_relay_statesUncheckedUpdateManyWithoutFlow_stateInput>
  }

  export type saml_relay_statesScalarWhereInput = {
    AND?: saml_relay_statesScalarWhereInput | saml_relay_statesScalarWhereInput[]
    OR?: saml_relay_statesScalarWhereInput[]
    NOT?: saml_relay_statesScalarWhereInput | saml_relay_statesScalarWhereInput[]
    id?: UuidFilter<"saml_relay_states"> | string
    sso_provider_id?: UuidFilter<"saml_relay_states"> | string
    request_id?: StringFilter<"saml_relay_states"> | string
    for_email?: StringNullableFilter<"saml_relay_states"> | string | null
    redirect_to?: StringNullableFilter<"saml_relay_states"> | string | null
    created_at?: DateTimeNullableFilter<"saml_relay_states"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saml_relay_states"> | Date | string | null
    flow_state_id?: UuidNullableFilter<"saml_relay_states"> | string | null
  }

  export type usersCreateWithoutIdentitiesInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    mfa_factors?: mfa_factorsCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutIdentitiesInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    mfa_factors?: mfa_factorsUncheckedCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutIdentitiesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutIdentitiesInput, usersUncheckedCreateWithoutIdentitiesInput>
  }

  export type usersUpsertWithoutIdentitiesInput = {
    update: XOR<usersUpdateWithoutIdentitiesInput, usersUncheckedUpdateWithoutIdentitiesInput>
    create: XOR<usersCreateWithoutIdentitiesInput, usersUncheckedCreateWithoutIdentitiesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutIdentitiesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutIdentitiesInput, usersUncheckedUpdateWithoutIdentitiesInput>
  }

  export type usersUpdateWithoutIdentitiesInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    mfa_factors?: mfa_factorsUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutIdentitiesInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    mfa_factors?: mfa_factorsUncheckedUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type sessionsCreateWithoutMfa_amr_claimsInput = {
    id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutSessionsInput
    users: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutMfa_amr_claimsInput = {
    id: string
    user_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutMfa_amr_claimsInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutMfa_amr_claimsInput, sessionsUncheckedCreateWithoutMfa_amr_claimsInput>
  }

  export type sessionsUpsertWithoutMfa_amr_claimsInput = {
    update: XOR<sessionsUpdateWithoutMfa_amr_claimsInput, sessionsUncheckedUpdateWithoutMfa_amr_claimsInput>
    create: XOR<sessionsCreateWithoutMfa_amr_claimsInput, sessionsUncheckedCreateWithoutMfa_amr_claimsInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutMfa_amr_claimsInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutMfa_amr_claimsInput, sessionsUncheckedUpdateWithoutMfa_amr_claimsInput>
  }

  export type sessionsUpdateWithoutMfa_amr_claimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_tokens?: refresh_tokensUpdateManyWithoutSessionsNestedInput
    users?: usersUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutMfa_amr_claimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type mfa_factorsCreateWithoutMfa_challengesInput = {
    id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
    users: usersCreateNestedOneWithoutMfa_factorsInput
  }

  export type mfa_factorsUncheckedCreateWithoutMfa_challengesInput = {
    id: string
    user_id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
  }

  export type mfa_factorsCreateOrConnectWithoutMfa_challengesInput = {
    where: mfa_factorsWhereUniqueInput
    create: XOR<mfa_factorsCreateWithoutMfa_challengesInput, mfa_factorsUncheckedCreateWithoutMfa_challengesInput>
  }

  export type mfa_factorsUpsertWithoutMfa_challengesInput = {
    update: XOR<mfa_factorsUpdateWithoutMfa_challengesInput, mfa_factorsUncheckedUpdateWithoutMfa_challengesInput>
    create: XOR<mfa_factorsCreateWithoutMfa_challengesInput, mfa_factorsUncheckedCreateWithoutMfa_challengesInput>
    where?: mfa_factorsWhereInput
  }

  export type mfa_factorsUpdateToOneWithWhereWithoutMfa_challengesInput = {
    where?: mfa_factorsWhereInput
    data: XOR<mfa_factorsUpdateWithoutMfa_challengesInput, mfa_factorsUncheckedUpdateWithoutMfa_challengesInput>
  }

  export type mfa_factorsUpdateWithoutMfa_challengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutMfa_factorsNestedInput
  }

  export type mfa_factorsUncheckedUpdateWithoutMfa_challengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mfa_challengesCreateWithoutMfa_factorsInput = {
    id: string
    created_at: Date | string
    verified_at?: Date | string | null
    ip_address: string
    otp_code?: string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesUncheckedCreateWithoutMfa_factorsInput = {
    id: string
    created_at: Date | string
    verified_at?: Date | string | null
    ip_address: string
    otp_code?: string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesCreateOrConnectWithoutMfa_factorsInput = {
    where: mfa_challengesWhereUniqueInput
    create: XOR<mfa_challengesCreateWithoutMfa_factorsInput, mfa_challengesUncheckedCreateWithoutMfa_factorsInput>
  }

  export type mfa_challengesCreateManyMfa_factorsInputEnvelope = {
    data: mfa_challengesCreateManyMfa_factorsInput | mfa_challengesCreateManyMfa_factorsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutMfa_factorsInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMfa_factorsInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesUncheckedCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMfa_factorsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMfa_factorsInput, usersUncheckedCreateWithoutMfa_factorsInput>
  }

  export type mfa_challengesUpsertWithWhereUniqueWithoutMfa_factorsInput = {
    where: mfa_challengesWhereUniqueInput
    update: XOR<mfa_challengesUpdateWithoutMfa_factorsInput, mfa_challengesUncheckedUpdateWithoutMfa_factorsInput>
    create: XOR<mfa_challengesCreateWithoutMfa_factorsInput, mfa_challengesUncheckedCreateWithoutMfa_factorsInput>
  }

  export type mfa_challengesUpdateWithWhereUniqueWithoutMfa_factorsInput = {
    where: mfa_challengesWhereUniqueInput
    data: XOR<mfa_challengesUpdateWithoutMfa_factorsInput, mfa_challengesUncheckedUpdateWithoutMfa_factorsInput>
  }

  export type mfa_challengesUpdateManyWithWhereWithoutMfa_factorsInput = {
    where: mfa_challengesScalarWhereInput
    data: XOR<mfa_challengesUpdateManyMutationInput, mfa_challengesUncheckedUpdateManyWithoutMfa_factorsInput>
  }

  export type mfa_challengesScalarWhereInput = {
    AND?: mfa_challengesScalarWhereInput | mfa_challengesScalarWhereInput[]
    OR?: mfa_challengesScalarWhereInput[]
    NOT?: mfa_challengesScalarWhereInput | mfa_challengesScalarWhereInput[]
    id?: UuidFilter<"mfa_challenges"> | string
    factor_id?: UuidFilter<"mfa_challenges"> | string
    created_at?: DateTimeFilter<"mfa_challenges"> | Date | string
    verified_at?: DateTimeNullableFilter<"mfa_challenges"> | Date | string | null
    ip_address?: StringFilter<"mfa_challenges"> | string
    otp_code?: StringNullableFilter<"mfa_challenges"> | string | null
    web_authn_session_data?: JsonNullableFilter<"mfa_challenges">
  }

  export type usersUpsertWithoutMfa_factorsInput = {
    update: XOR<usersUpdateWithoutMfa_factorsInput, usersUncheckedUpdateWithoutMfa_factorsInput>
    create: XOR<usersCreateWithoutMfa_factorsInput, usersUncheckedCreateWithoutMfa_factorsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMfa_factorsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMfa_factorsInput, usersUncheckedUpdateWithoutMfa_factorsInput>
  }

  export type usersUpdateWithoutMfa_factorsInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMfa_factorsInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUncheckedUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutOne_time_tokensInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutOne_time_tokensInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesUncheckedCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutOne_time_tokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOne_time_tokensInput, usersUncheckedCreateWithoutOne_time_tokensInput>
  }

  export type usersUpsertWithoutOne_time_tokensInput = {
    update: XOR<usersUpdateWithoutOne_time_tokensInput, usersUncheckedUpdateWithoutOne_time_tokensInput>
    create: XOR<usersCreateWithoutOne_time_tokensInput, usersUncheckedCreateWithoutOne_time_tokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOne_time_tokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOne_time_tokensInput, usersUncheckedUpdateWithoutOne_time_tokensInput>
  }

  export type usersUpdateWithoutOne_time_tokensInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutOne_time_tokensInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUncheckedUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type sessionsCreateWithoutRefresh_tokensInput = {
    id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    mfa_amr_claims?: mfa_amr_claimsCreateNestedManyWithoutSessionsInput
    users: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutRefresh_tokensInput = {
    id: string
    user_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    mfa_amr_claims?: mfa_amr_claimsUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutRefresh_tokensInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutRefresh_tokensInput, sessionsUncheckedCreateWithoutRefresh_tokensInput>
  }

  export type sessionsUpsertWithoutRefresh_tokensInput = {
    update: XOR<sessionsUpdateWithoutRefresh_tokensInput, sessionsUncheckedUpdateWithoutRefresh_tokensInput>
    create: XOR<sessionsCreateWithoutRefresh_tokensInput, sessionsUncheckedCreateWithoutRefresh_tokensInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutRefresh_tokensInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutRefresh_tokensInput, sessionsUncheckedUpdateWithoutRefresh_tokensInput>
  }

  export type sessionsUpdateWithoutRefresh_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_amr_claims?: mfa_amr_claimsUpdateManyWithoutSessionsNestedInput
    users?: usersUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutRefresh_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_amr_claims?: mfa_amr_claimsUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sso_providersCreateWithoutSaml_providersInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_relay_states?: saml_relay_statesCreateNestedManyWithoutSso_providersInput
    sso_domains?: sso_domainsCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersUncheckedCreateWithoutSaml_providersInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_relay_states?: saml_relay_statesUncheckedCreateNestedManyWithoutSso_providersInput
    sso_domains?: sso_domainsUncheckedCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersCreateOrConnectWithoutSaml_providersInput = {
    where: sso_providersWhereUniqueInput
    create: XOR<sso_providersCreateWithoutSaml_providersInput, sso_providersUncheckedCreateWithoutSaml_providersInput>
  }

  export type sso_providersUpsertWithoutSaml_providersInput = {
    update: XOR<sso_providersUpdateWithoutSaml_providersInput, sso_providersUncheckedUpdateWithoutSaml_providersInput>
    create: XOR<sso_providersCreateWithoutSaml_providersInput, sso_providersUncheckedCreateWithoutSaml_providersInput>
    where?: sso_providersWhereInput
  }

  export type sso_providersUpdateToOneWithWhereWithoutSaml_providersInput = {
    where?: sso_providersWhereInput
    data: XOR<sso_providersUpdateWithoutSaml_providersInput, sso_providersUncheckedUpdateWithoutSaml_providersInput>
  }

  export type sso_providersUpdateWithoutSaml_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_relay_states?: saml_relay_statesUpdateManyWithoutSso_providersNestedInput
    sso_domains?: sso_domainsUpdateManyWithoutSso_providersNestedInput
  }

  export type sso_providersUncheckedUpdateWithoutSaml_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_relay_states?: saml_relay_statesUncheckedUpdateManyWithoutSso_providersNestedInput
    sso_domains?: sso_domainsUncheckedUpdateManyWithoutSso_providersNestedInput
  }

  export type flow_stateCreateWithoutSaml_relay_statesInput = {
    id: string
    user_id?: string | null
    auth_code: string
    code_challenge_method: $Enums.code_challenge_method
    code_challenge: string
    provider_type: string
    provider_access_token?: string | null
    provider_refresh_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    authentication_method: string
    auth_code_issued_at?: Date | string | null
  }

  export type flow_stateUncheckedCreateWithoutSaml_relay_statesInput = {
    id: string
    user_id?: string | null
    auth_code: string
    code_challenge_method: $Enums.code_challenge_method
    code_challenge: string
    provider_type: string
    provider_access_token?: string | null
    provider_refresh_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    authentication_method: string
    auth_code_issued_at?: Date | string | null
  }

  export type flow_stateCreateOrConnectWithoutSaml_relay_statesInput = {
    where: flow_stateWhereUniqueInput
    create: XOR<flow_stateCreateWithoutSaml_relay_statesInput, flow_stateUncheckedCreateWithoutSaml_relay_statesInput>
  }

  export type sso_providersCreateWithoutSaml_relay_statesInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_providers?: saml_providersCreateNestedManyWithoutSso_providersInput
    sso_domains?: sso_domainsCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersUncheckedCreateWithoutSaml_relay_statesInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_providers?: saml_providersUncheckedCreateNestedManyWithoutSso_providersInput
    sso_domains?: sso_domainsUncheckedCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersCreateOrConnectWithoutSaml_relay_statesInput = {
    where: sso_providersWhereUniqueInput
    create: XOR<sso_providersCreateWithoutSaml_relay_statesInput, sso_providersUncheckedCreateWithoutSaml_relay_statesInput>
  }

  export type flow_stateUpsertWithoutSaml_relay_statesInput = {
    update: XOR<flow_stateUpdateWithoutSaml_relay_statesInput, flow_stateUncheckedUpdateWithoutSaml_relay_statesInput>
    create: XOR<flow_stateCreateWithoutSaml_relay_statesInput, flow_stateUncheckedCreateWithoutSaml_relay_statesInput>
    where?: flow_stateWhereInput
  }

  export type flow_stateUpdateToOneWithWhereWithoutSaml_relay_statesInput = {
    where?: flow_stateWhereInput
    data: XOR<flow_stateUpdateWithoutSaml_relay_statesInput, flow_stateUncheckedUpdateWithoutSaml_relay_statesInput>
  }

  export type flow_stateUpdateWithoutSaml_relay_statesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    auth_code?: StringFieldUpdateOperationsInput | string
    code_challenge_method?: Enumcode_challenge_methodFieldUpdateOperationsInput | $Enums.code_challenge_method
    code_challenge?: StringFieldUpdateOperationsInput | string
    provider_type?: StringFieldUpdateOperationsInput | string
    provider_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    provider_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authentication_method?: StringFieldUpdateOperationsInput | string
    auth_code_issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type flow_stateUncheckedUpdateWithoutSaml_relay_statesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    auth_code?: StringFieldUpdateOperationsInput | string
    code_challenge_method?: Enumcode_challenge_methodFieldUpdateOperationsInput | $Enums.code_challenge_method
    code_challenge?: StringFieldUpdateOperationsInput | string
    provider_type?: StringFieldUpdateOperationsInput | string
    provider_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    provider_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authentication_method?: StringFieldUpdateOperationsInput | string
    auth_code_issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sso_providersUpsertWithoutSaml_relay_statesInput = {
    update: XOR<sso_providersUpdateWithoutSaml_relay_statesInput, sso_providersUncheckedUpdateWithoutSaml_relay_statesInput>
    create: XOR<sso_providersCreateWithoutSaml_relay_statesInput, sso_providersUncheckedCreateWithoutSaml_relay_statesInput>
    where?: sso_providersWhereInput
  }

  export type sso_providersUpdateToOneWithWhereWithoutSaml_relay_statesInput = {
    where?: sso_providersWhereInput
    data: XOR<sso_providersUpdateWithoutSaml_relay_statesInput, sso_providersUncheckedUpdateWithoutSaml_relay_statesInput>
  }

  export type sso_providersUpdateWithoutSaml_relay_statesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_providers?: saml_providersUpdateManyWithoutSso_providersNestedInput
    sso_domains?: sso_domainsUpdateManyWithoutSso_providersNestedInput
  }

  export type sso_providersUncheckedUpdateWithoutSaml_relay_statesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_providers?: saml_providersUncheckedUpdateManyWithoutSso_providersNestedInput
    sso_domains?: sso_domainsUncheckedUpdateManyWithoutSso_providersNestedInput
  }

  export type mfa_amr_claimsCreateWithoutSessionsInput = {
    created_at: Date | string
    updated_at: Date | string
    authentication_method: string
    id: string
  }

  export type mfa_amr_claimsUncheckedCreateWithoutSessionsInput = {
    created_at: Date | string
    updated_at: Date | string
    authentication_method: string
    id: string
  }

  export type mfa_amr_claimsCreateOrConnectWithoutSessionsInput = {
    where: mfa_amr_claimsWhereUniqueInput
    create: XOR<mfa_amr_claimsCreateWithoutSessionsInput, mfa_amr_claimsUncheckedCreateWithoutSessionsInput>
  }

  export type mfa_amr_claimsCreateManySessionsInputEnvelope = {
    data: mfa_amr_claimsCreateManySessionsInput | mfa_amr_claimsCreateManySessionsInput[]
    skipDuplicates?: boolean
  }

  export type refresh_tokensCreateWithoutSessionsInput = {
    instance_id?: string | null
    id?: bigint | number
    token?: string | null
    user_id?: string | null
    revoked?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parent?: string | null
  }

  export type refresh_tokensUncheckedCreateWithoutSessionsInput = {
    instance_id?: string | null
    id?: bigint | number
    token?: string | null
    user_id?: string | null
    revoked?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parent?: string | null
  }

  export type refresh_tokensCreateOrConnectWithoutSessionsInput = {
    where: refresh_tokensWhereUniqueInput
    create: XOR<refresh_tokensCreateWithoutSessionsInput, refresh_tokensUncheckedCreateWithoutSessionsInput>
  }

  export type refresh_tokensCreateManySessionsInputEnvelope = {
    data: refresh_tokensCreateManySessionsInput | refresh_tokensCreateManySessionsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutSessionsInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSessionsInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesUncheckedCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsUncheckedCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensUncheckedCreateNestedManyWithoutUsersInput
    profilesTable?: profilesTableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
  }

  export type mfa_amr_claimsUpsertWithWhereUniqueWithoutSessionsInput = {
    where: mfa_amr_claimsWhereUniqueInput
    update: XOR<mfa_amr_claimsUpdateWithoutSessionsInput, mfa_amr_claimsUncheckedUpdateWithoutSessionsInput>
    create: XOR<mfa_amr_claimsCreateWithoutSessionsInput, mfa_amr_claimsUncheckedCreateWithoutSessionsInput>
  }

  export type mfa_amr_claimsUpdateWithWhereUniqueWithoutSessionsInput = {
    where: mfa_amr_claimsWhereUniqueInput
    data: XOR<mfa_amr_claimsUpdateWithoutSessionsInput, mfa_amr_claimsUncheckedUpdateWithoutSessionsInput>
  }

  export type mfa_amr_claimsUpdateManyWithWhereWithoutSessionsInput = {
    where: mfa_amr_claimsScalarWhereInput
    data: XOR<mfa_amr_claimsUpdateManyMutationInput, mfa_amr_claimsUncheckedUpdateManyWithoutSessionsInput>
  }

  export type mfa_amr_claimsScalarWhereInput = {
    AND?: mfa_amr_claimsScalarWhereInput | mfa_amr_claimsScalarWhereInput[]
    OR?: mfa_amr_claimsScalarWhereInput[]
    NOT?: mfa_amr_claimsScalarWhereInput | mfa_amr_claimsScalarWhereInput[]
    session_id?: UuidFilter<"mfa_amr_claims"> | string
    created_at?: DateTimeFilter<"mfa_amr_claims"> | Date | string
    updated_at?: DateTimeFilter<"mfa_amr_claims"> | Date | string
    authentication_method?: StringFilter<"mfa_amr_claims"> | string
    id?: UuidFilter<"mfa_amr_claims"> | string
  }

  export type refresh_tokensUpsertWithWhereUniqueWithoutSessionsInput = {
    where: refresh_tokensWhereUniqueInput
    update: XOR<refresh_tokensUpdateWithoutSessionsInput, refresh_tokensUncheckedUpdateWithoutSessionsInput>
    create: XOR<refresh_tokensCreateWithoutSessionsInput, refresh_tokensUncheckedCreateWithoutSessionsInput>
  }

  export type refresh_tokensUpdateWithWhereUniqueWithoutSessionsInput = {
    where: refresh_tokensWhereUniqueInput
    data: XOR<refresh_tokensUpdateWithoutSessionsInput, refresh_tokensUncheckedUpdateWithoutSessionsInput>
  }

  export type refresh_tokensUpdateManyWithWhereWithoutSessionsInput = {
    where: refresh_tokensScalarWhereInput
    data: XOR<refresh_tokensUpdateManyMutationInput, refresh_tokensUncheckedUpdateManyWithoutSessionsInput>
  }

  export type refresh_tokensScalarWhereInput = {
    AND?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
    OR?: refresh_tokensScalarWhereInput[]
    NOT?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
    instance_id?: UuidNullableFilter<"refresh_tokens"> | string | null
    id?: BigIntFilter<"refresh_tokens"> | bigint | number
    token?: StringNullableFilter<"refresh_tokens"> | string | null
    user_id?: StringNullableFilter<"refresh_tokens"> | string | null
    revoked?: BoolNullableFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    parent?: StringNullableFilter<"refresh_tokens"> | string | null
    session_id?: UuidNullableFilter<"refresh_tokens"> | string | null
  }

  export type usersUpsertWithoutSessionsInput = {
    update: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateWithoutSessionsInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionsInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUncheckedUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUncheckedUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUncheckedUpdateManyWithoutUsersNestedInput
    profilesTable?: profilesTableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type sso_providersCreateWithoutSso_domainsInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_providers?: saml_providersCreateNestedManyWithoutSso_providersInput
    saml_relay_states?: saml_relay_statesCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersUncheckedCreateWithoutSso_domainsInput = {
    id: string
    resource_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    saml_providers?: saml_providersUncheckedCreateNestedManyWithoutSso_providersInput
    saml_relay_states?: saml_relay_statesUncheckedCreateNestedManyWithoutSso_providersInput
  }

  export type sso_providersCreateOrConnectWithoutSso_domainsInput = {
    where: sso_providersWhereUniqueInput
    create: XOR<sso_providersCreateWithoutSso_domainsInput, sso_providersUncheckedCreateWithoutSso_domainsInput>
  }

  export type sso_providersUpsertWithoutSso_domainsInput = {
    update: XOR<sso_providersUpdateWithoutSso_domainsInput, sso_providersUncheckedUpdateWithoutSso_domainsInput>
    create: XOR<sso_providersCreateWithoutSso_domainsInput, sso_providersUncheckedCreateWithoutSso_domainsInput>
    where?: sso_providersWhereInput
  }

  export type sso_providersUpdateToOneWithWhereWithoutSso_domainsInput = {
    where?: sso_providersWhereInput
    data: XOR<sso_providersUpdateWithoutSso_domainsInput, sso_providersUncheckedUpdateWithoutSso_domainsInput>
  }

  export type sso_providersUpdateWithoutSso_domainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_providers?: saml_providersUpdateManyWithoutSso_providersNestedInput
    saml_relay_states?: saml_relay_statesUpdateManyWithoutSso_providersNestedInput
  }

  export type sso_providersUncheckedUpdateWithoutSso_domainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saml_providers?: saml_providersUncheckedUpdateManyWithoutSso_providersNestedInput
    saml_relay_states?: saml_relay_statesUncheckedUpdateManyWithoutSso_providersNestedInput
  }

  export type saml_providersCreateWithoutSso_providersInput = {
    id: string
    entity_id: string
    metadata_xml: string
    metadata_url?: string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name_id_format?: string | null
  }

  export type saml_providersUncheckedCreateWithoutSso_providersInput = {
    id: string
    entity_id: string
    metadata_xml: string
    metadata_url?: string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name_id_format?: string | null
  }

  export type saml_providersCreateOrConnectWithoutSso_providersInput = {
    where: saml_providersWhereUniqueInput
    create: XOR<saml_providersCreateWithoutSso_providersInput, saml_providersUncheckedCreateWithoutSso_providersInput>
  }

  export type saml_providersCreateManySso_providersInputEnvelope = {
    data: saml_providersCreateManySso_providersInput | saml_providersCreateManySso_providersInput[]
    skipDuplicates?: boolean
  }

  export type saml_relay_statesCreateWithoutSso_providersInput = {
    id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    flow_state?: flow_stateCreateNestedOneWithoutSaml_relay_statesInput
  }

  export type saml_relay_statesUncheckedCreateWithoutSso_providersInput = {
    id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    flow_state_id?: string | null
  }

  export type saml_relay_statesCreateOrConnectWithoutSso_providersInput = {
    where: saml_relay_statesWhereUniqueInput
    create: XOR<saml_relay_statesCreateWithoutSso_providersInput, saml_relay_statesUncheckedCreateWithoutSso_providersInput>
  }

  export type saml_relay_statesCreateManySso_providersInputEnvelope = {
    data: saml_relay_statesCreateManySso_providersInput | saml_relay_statesCreateManySso_providersInput[]
    skipDuplicates?: boolean
  }

  export type sso_domainsCreateWithoutSso_providersInput = {
    id: string
    domain: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sso_domainsUncheckedCreateWithoutSso_providersInput = {
    id: string
    domain: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sso_domainsCreateOrConnectWithoutSso_providersInput = {
    where: sso_domainsWhereUniqueInput
    create: XOR<sso_domainsCreateWithoutSso_providersInput, sso_domainsUncheckedCreateWithoutSso_providersInput>
  }

  export type sso_domainsCreateManySso_providersInputEnvelope = {
    data: sso_domainsCreateManySso_providersInput | sso_domainsCreateManySso_providersInput[]
    skipDuplicates?: boolean
  }

  export type saml_providersUpsertWithWhereUniqueWithoutSso_providersInput = {
    where: saml_providersWhereUniqueInput
    update: XOR<saml_providersUpdateWithoutSso_providersInput, saml_providersUncheckedUpdateWithoutSso_providersInput>
    create: XOR<saml_providersCreateWithoutSso_providersInput, saml_providersUncheckedCreateWithoutSso_providersInput>
  }

  export type saml_providersUpdateWithWhereUniqueWithoutSso_providersInput = {
    where: saml_providersWhereUniqueInput
    data: XOR<saml_providersUpdateWithoutSso_providersInput, saml_providersUncheckedUpdateWithoutSso_providersInput>
  }

  export type saml_providersUpdateManyWithWhereWithoutSso_providersInput = {
    where: saml_providersScalarWhereInput
    data: XOR<saml_providersUpdateManyMutationInput, saml_providersUncheckedUpdateManyWithoutSso_providersInput>
  }

  export type saml_providersScalarWhereInput = {
    AND?: saml_providersScalarWhereInput | saml_providersScalarWhereInput[]
    OR?: saml_providersScalarWhereInput[]
    NOT?: saml_providersScalarWhereInput | saml_providersScalarWhereInput[]
    id?: UuidFilter<"saml_providers"> | string
    sso_provider_id?: UuidFilter<"saml_providers"> | string
    entity_id?: StringFilter<"saml_providers"> | string
    metadata_xml?: StringFilter<"saml_providers"> | string
    metadata_url?: StringNullableFilter<"saml_providers"> | string | null
    attribute_mapping?: JsonNullableFilter<"saml_providers">
    created_at?: DateTimeNullableFilter<"saml_providers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saml_providers"> | Date | string | null
    name_id_format?: StringNullableFilter<"saml_providers"> | string | null
  }

  export type saml_relay_statesUpsertWithWhereUniqueWithoutSso_providersInput = {
    where: saml_relay_statesWhereUniqueInput
    update: XOR<saml_relay_statesUpdateWithoutSso_providersInput, saml_relay_statesUncheckedUpdateWithoutSso_providersInput>
    create: XOR<saml_relay_statesCreateWithoutSso_providersInput, saml_relay_statesUncheckedCreateWithoutSso_providersInput>
  }

  export type saml_relay_statesUpdateWithWhereUniqueWithoutSso_providersInput = {
    where: saml_relay_statesWhereUniqueInput
    data: XOR<saml_relay_statesUpdateWithoutSso_providersInput, saml_relay_statesUncheckedUpdateWithoutSso_providersInput>
  }

  export type saml_relay_statesUpdateManyWithWhereWithoutSso_providersInput = {
    where: saml_relay_statesScalarWhereInput
    data: XOR<saml_relay_statesUpdateManyMutationInput, saml_relay_statesUncheckedUpdateManyWithoutSso_providersInput>
  }

  export type sso_domainsUpsertWithWhereUniqueWithoutSso_providersInput = {
    where: sso_domainsWhereUniqueInput
    update: XOR<sso_domainsUpdateWithoutSso_providersInput, sso_domainsUncheckedUpdateWithoutSso_providersInput>
    create: XOR<sso_domainsCreateWithoutSso_providersInput, sso_domainsUncheckedCreateWithoutSso_providersInput>
  }

  export type sso_domainsUpdateWithWhereUniqueWithoutSso_providersInput = {
    where: sso_domainsWhereUniqueInput
    data: XOR<sso_domainsUpdateWithoutSso_providersInput, sso_domainsUncheckedUpdateWithoutSso_providersInput>
  }

  export type sso_domainsUpdateManyWithWhereWithoutSso_providersInput = {
    where: sso_domainsScalarWhereInput
    data: XOR<sso_domainsUpdateManyMutationInput, sso_domainsUncheckedUpdateManyWithoutSso_providersInput>
  }

  export type sso_domainsScalarWhereInput = {
    AND?: sso_domainsScalarWhereInput | sso_domainsScalarWhereInput[]
    OR?: sso_domainsScalarWhereInput[]
    NOT?: sso_domainsScalarWhereInput | sso_domainsScalarWhereInput[]
    id?: UuidFilter<"sso_domains"> | string
    sso_provider_id?: UuidFilter<"sso_domains"> | string
    domain?: StringFilter<"sso_domains"> | string
    created_at?: DateTimeNullableFilter<"sso_domains"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sso_domains"> | Date | string | null
  }

  export type identitiesCreateWithoutUsersInput = {
    provider_id: string
    identity_data: JsonNullValueInput | InputJsonValue
    provider: string
    last_sign_in_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    email?: string | null
    id?: string
  }

  export type identitiesUncheckedCreateWithoutUsersInput = {
    provider_id: string
    identity_data: JsonNullValueInput | InputJsonValue
    provider: string
    last_sign_in_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    email?: string | null
    id?: string
  }

  export type identitiesCreateOrConnectWithoutUsersInput = {
    where: identitiesWhereUniqueInput
    create: XOR<identitiesCreateWithoutUsersInput, identitiesUncheckedCreateWithoutUsersInput>
  }

  export type identitiesCreateManyUsersInputEnvelope = {
    data: identitiesCreateManyUsersInput | identitiesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type mfa_factorsCreateWithoutUsersInput = {
    id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
    mfa_challenges?: mfa_challengesCreateNestedManyWithoutMfa_factorsInput
  }

  export type mfa_factorsUncheckedCreateWithoutUsersInput = {
    id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
    mfa_challenges?: mfa_challengesUncheckedCreateNestedManyWithoutMfa_factorsInput
  }

  export type mfa_factorsCreateOrConnectWithoutUsersInput = {
    where: mfa_factorsWhereUniqueInput
    create: XOR<mfa_factorsCreateWithoutUsersInput, mfa_factorsUncheckedCreateWithoutUsersInput>
  }

  export type mfa_factorsCreateManyUsersInputEnvelope = {
    data: mfa_factorsCreateManyUsersInput | mfa_factorsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type one_time_tokensCreateWithoutUsersInput = {
    id: string
    token_type: $Enums.one_time_token_type
    token_hash: string
    relates_to: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type one_time_tokensUncheckedCreateWithoutUsersInput = {
    id: string
    token_type: $Enums.one_time_token_type
    token_hash: string
    relates_to: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type one_time_tokensCreateOrConnectWithoutUsersInput = {
    where: one_time_tokensWhereUniqueInput
    create: XOR<one_time_tokensCreateWithoutUsersInput, one_time_tokensUncheckedCreateWithoutUsersInput>
  }

  export type one_time_tokensCreateManyUsersInputEnvelope = {
    data: one_time_tokensCreateManyUsersInput | one_time_tokensCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutUsersInput = {
    id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    mfa_amr_claims?: mfa_amr_claimsCreateNestedManyWithoutSessionsInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutUsersInput = {
    id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
    mfa_amr_claims?: mfa_amr_claimsUncheckedCreateNestedManyWithoutSessionsInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsCreateManyUsersInputEnvelope = {
    data: sessionsCreateManyUsersInput | sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type profilesTableCreateWithoutUsersInput = {
    id?: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    locale?: string | null
    timezone?: string | null
    organizationsTable?: organizationsTableCreateNestedOneWithoutProfilesTableInput
  }

  export type profilesTableUncheckedCreateWithoutUsersInput = {
    id?: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    organizationid?: string | null
    locale?: string | null
    timezone?: string | null
  }

  export type profilesTableCreateOrConnectWithoutUsersInput = {
    where: profilesTableWhereUniqueInput
    create: XOR<profilesTableCreateWithoutUsersInput, profilesTableUncheckedCreateWithoutUsersInput>
  }

  export type identitiesUpsertWithWhereUniqueWithoutUsersInput = {
    where: identitiesWhereUniqueInput
    update: XOR<identitiesUpdateWithoutUsersInput, identitiesUncheckedUpdateWithoutUsersInput>
    create: XOR<identitiesCreateWithoutUsersInput, identitiesUncheckedCreateWithoutUsersInput>
  }

  export type identitiesUpdateWithWhereUniqueWithoutUsersInput = {
    where: identitiesWhereUniqueInput
    data: XOR<identitiesUpdateWithoutUsersInput, identitiesUncheckedUpdateWithoutUsersInput>
  }

  export type identitiesUpdateManyWithWhereWithoutUsersInput = {
    where: identitiesScalarWhereInput
    data: XOR<identitiesUpdateManyMutationInput, identitiesUncheckedUpdateManyWithoutUsersInput>
  }

  export type identitiesScalarWhereInput = {
    AND?: identitiesScalarWhereInput | identitiesScalarWhereInput[]
    OR?: identitiesScalarWhereInput[]
    NOT?: identitiesScalarWhereInput | identitiesScalarWhereInput[]
    provider_id?: StringFilter<"identities"> | string
    user_id?: UuidFilter<"identities"> | string
    identity_data?: JsonFilter<"identities">
    provider?: StringFilter<"identities"> | string
    last_sign_in_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    created_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"identities"> | Date | string | null
    email?: StringNullableFilter<"identities"> | string | null
    id?: UuidFilter<"identities"> | string
  }

  export type mfa_factorsUpsertWithWhereUniqueWithoutUsersInput = {
    where: mfa_factorsWhereUniqueInput
    update: XOR<mfa_factorsUpdateWithoutUsersInput, mfa_factorsUncheckedUpdateWithoutUsersInput>
    create: XOR<mfa_factorsCreateWithoutUsersInput, mfa_factorsUncheckedCreateWithoutUsersInput>
  }

  export type mfa_factorsUpdateWithWhereUniqueWithoutUsersInput = {
    where: mfa_factorsWhereUniqueInput
    data: XOR<mfa_factorsUpdateWithoutUsersInput, mfa_factorsUncheckedUpdateWithoutUsersInput>
  }

  export type mfa_factorsUpdateManyWithWhereWithoutUsersInput = {
    where: mfa_factorsScalarWhereInput
    data: XOR<mfa_factorsUpdateManyMutationInput, mfa_factorsUncheckedUpdateManyWithoutUsersInput>
  }

  export type mfa_factorsScalarWhereInput = {
    AND?: mfa_factorsScalarWhereInput | mfa_factorsScalarWhereInput[]
    OR?: mfa_factorsScalarWhereInput[]
    NOT?: mfa_factorsScalarWhereInput | mfa_factorsScalarWhereInput[]
    id?: UuidFilter<"mfa_factors"> | string
    user_id?: UuidFilter<"mfa_factors"> | string
    friendly_name?: StringNullableFilter<"mfa_factors"> | string | null
    factor_type?: Enumfactor_typeFilter<"mfa_factors"> | $Enums.factor_type
    status?: Enumfactor_statusFilter<"mfa_factors"> | $Enums.factor_status
    created_at?: DateTimeFilter<"mfa_factors"> | Date | string
    updated_at?: DateTimeFilter<"mfa_factors"> | Date | string
    secret?: StringNullableFilter<"mfa_factors"> | string | null
    phone?: StringNullableFilter<"mfa_factors"> | string | null
    last_challenged_at?: DateTimeNullableFilter<"mfa_factors"> | Date | string | null
    web_authn_credential?: JsonNullableFilter<"mfa_factors">
    web_authn_aaguid?: UuidNullableFilter<"mfa_factors"> | string | null
  }

  export type one_time_tokensUpsertWithWhereUniqueWithoutUsersInput = {
    where: one_time_tokensWhereUniqueInput
    update: XOR<one_time_tokensUpdateWithoutUsersInput, one_time_tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<one_time_tokensCreateWithoutUsersInput, one_time_tokensUncheckedCreateWithoutUsersInput>
  }

  export type one_time_tokensUpdateWithWhereUniqueWithoutUsersInput = {
    where: one_time_tokensWhereUniqueInput
    data: XOR<one_time_tokensUpdateWithoutUsersInput, one_time_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type one_time_tokensUpdateManyWithWhereWithoutUsersInput = {
    where: one_time_tokensScalarWhereInput
    data: XOR<one_time_tokensUpdateManyMutationInput, one_time_tokensUncheckedUpdateManyWithoutUsersInput>
  }

  export type one_time_tokensScalarWhereInput = {
    AND?: one_time_tokensScalarWhereInput | one_time_tokensScalarWhereInput[]
    OR?: one_time_tokensScalarWhereInput[]
    NOT?: one_time_tokensScalarWhereInput | one_time_tokensScalarWhereInput[]
    id?: UuidFilter<"one_time_tokens"> | string
    user_id?: UuidFilter<"one_time_tokens"> | string
    token_type?: Enumone_time_token_typeFilter<"one_time_tokens"> | $Enums.one_time_token_type
    token_hash?: StringFilter<"one_time_tokens"> | string
    relates_to?: StringFilter<"one_time_tokens"> | string
    created_at?: DateTimeFilter<"one_time_tokens"> | Date | string
    updated_at?: DateTimeFilter<"one_time_tokens"> | Date | string
  }

  export type sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    OR?: sessionsScalarWhereInput[]
    NOT?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    id?: UuidFilter<"sessions"> | string
    user_id?: UuidFilter<"sessions"> | string
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    factor_id?: UuidNullableFilter<"sessions"> | string | null
    aal?: Enumaal_levelNullableFilter<"sessions"> | $Enums.aal_level | null
    not_after?: DateTimeNullableFilter<"sessions"> | Date | string | null
    refreshed_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    user_agent?: StringNullableFilter<"sessions"> | string | null
    ip?: StringNullableFilter<"sessions"> | string | null
    tag?: StringNullableFilter<"sessions"> | string | null
  }

  export type profilesTableUpsertWithoutUsersInput = {
    update: XOR<profilesTableUpdateWithoutUsersInput, profilesTableUncheckedUpdateWithoutUsersInput>
    create: XOR<profilesTableCreateWithoutUsersInput, profilesTableUncheckedCreateWithoutUsersInput>
    where?: profilesTableWhereInput
  }

  export type profilesTableUpdateToOneWithWhereWithoutUsersInput = {
    where?: profilesTableWhereInput
    data: XOR<profilesTableUpdateWithoutUsersInput, profilesTableUncheckedUpdateWithoutUsersInput>
  }

  export type profilesTableUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    organizationsTable?: organizationsTableUpdateOneWithoutProfilesTableNestedInput
  }

  export type profilesTableUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    organizationid?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cropTableCreateWithoutCropStakeholdersTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropNotes?: string | null
    speciesTemp?: string | null
    csvObjTable?: csvObjTableCreateNestedOneWithoutCropTableInput
    organizationsTable?: organizationsTableCreateNestedOneWithoutCropTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutCropTableInput
    speciesTable?: speciesTableCreateNestedOneWithoutCropTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutCropTableInput
  }

  export type cropTableUncheckedCreateWithoutCropStakeholdersTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutCropTableInput
  }

  export type cropTableCreateOrConnectWithoutCropStakeholdersTableInput = {
    where: cropTableWhereUniqueInput
    create: XOR<cropTableCreateWithoutCropStakeholdersTableInput, cropTableUncheckedCreateWithoutCropStakeholdersTableInput>
  }

  export type organizationsTableCreateWithoutCropStakeholdersTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropTable?: cropTableCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    stakeholderTypesTable?: stakeholderTypesTableCreateNestedOneWithoutOrganizationsTableInput
    profilesTable?: profilesTableCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUncheckedCreateWithoutCropStakeholdersTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    stakeholderTypeId?: string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    profilesTable?: profilesTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableCreateOrConnectWithoutCropStakeholdersTableInput = {
    where: organizationsTableWhereUniqueInput
    create: XOR<organizationsTableCreateWithoutCropStakeholdersTableInput, organizationsTableUncheckedCreateWithoutCropStakeholdersTableInput>
  }

  export type stakeholderTypesTableCreateWithoutCropStakeholdersTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableUncheckedCreateWithoutCropStakeholdersTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableCreateOrConnectWithoutCropStakeholdersTableInput = {
    where: stakeholderTypesTableWhereUniqueInput
    create: XOR<stakeholderTypesTableCreateWithoutCropStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutCropStakeholdersTableInput>
  }

  export type cropTableUpsertWithoutCropStakeholdersTableInput = {
    update: XOR<cropTableUpdateWithoutCropStakeholdersTableInput, cropTableUncheckedUpdateWithoutCropStakeholdersTableInput>
    create: XOR<cropTableCreateWithoutCropStakeholdersTableInput, cropTableUncheckedCreateWithoutCropStakeholdersTableInput>
    where?: cropTableWhereInput
  }

  export type cropTableUpdateToOneWithWhereWithoutCropStakeholdersTableInput = {
    where?: cropTableWhereInput
    data: XOR<cropTableUpdateWithoutCropStakeholdersTableInput, cropTableUncheckedUpdateWithoutCropStakeholdersTableInput>
  }

  export type cropTableUpdateWithoutCropStakeholdersTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    csvObjTable?: csvObjTableUpdateOneWithoutCropTableNestedInput
    organizationsTable?: organizationsTableUpdateOneWithoutCropTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutCropTableNestedInput
    speciesTable?: speciesTableUpdateOneWithoutCropTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateWithoutCropStakeholdersTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    plantingTable?: plantingTableUncheckedUpdateManyWithoutCropTableNestedInput
  }

  export type organizationsTableUpsertWithoutCropStakeholdersTableInput = {
    update: XOR<organizationsTableUpdateWithoutCropStakeholdersTableInput, organizationsTableUncheckedUpdateWithoutCropStakeholdersTableInput>
    create: XOR<organizationsTableCreateWithoutCropStakeholdersTableInput, organizationsTableUncheckedCreateWithoutCropStakeholdersTableInput>
    where?: organizationsTableWhereInput
  }

  export type organizationsTableUpdateToOneWithWhereWithoutCropStakeholdersTableInput = {
    where?: organizationsTableWhereInput
    data: XOR<organizationsTableUpdateWithoutCropStakeholdersTableInput, organizationsTableUncheckedUpdateWithoutCropStakeholdersTableInput>
  }

  export type organizationsTableUpdateWithoutCropStakeholdersTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropTable?: cropTableUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateWithoutCropStakeholdersTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    stakeholderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type stakeholderTypesTableUpsertWithoutCropStakeholdersTableInput = {
    update: XOR<stakeholderTypesTableUpdateWithoutCropStakeholdersTableInput, stakeholderTypesTableUncheckedUpdateWithoutCropStakeholdersTableInput>
    create: XOR<stakeholderTypesTableCreateWithoutCropStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutCropStakeholdersTableInput>
    where?: stakeholderTypesTableWhereInput
  }

  export type stakeholderTypesTableUpdateToOneWithWhereWithoutCropStakeholdersTableInput = {
    where?: stakeholderTypesTableWhereInput
    data: XOR<stakeholderTypesTableUpdateWithoutCropStakeholdersTableInput, stakeholderTypesTableUncheckedUpdateWithoutCropStakeholdersTableInput>
  }

  export type stakeholderTypesTableUpdateWithoutCropStakeholdersTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type stakeholderTypesTableUncheckedUpdateWithoutCropStakeholdersTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type cropStakeholdersTableCreateWithoutCropTableInput = {
    cropStakeholderId?: string
    organizationsTable: organizationsTableCreateNestedOneWithoutCropStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutCropStakeholdersTableInput
  }

  export type cropStakeholdersTableUncheckedCreateWithoutCropTableInput = {
    cropStakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type cropStakeholdersTableCreateOrConnectWithoutCropTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    create: XOR<cropStakeholdersTableCreateWithoutCropTableInput, cropStakeholdersTableUncheckedCreateWithoutCropTableInput>
  }

  export type cropStakeholdersTableCreateManyCropTableInputEnvelope = {
    data: cropStakeholdersTableCreateManyCropTableInput | cropStakeholdersTableCreateManyCropTableInput[]
    skipDuplicates?: boolean
  }

  export type csvObjTableCreateWithoutCropTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    landTable?: landTableCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableUncheckedCreateWithoutCropTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    landTable?: landTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableUncheckedCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableCreateOrConnectWithoutCropTableInput = {
    where: csvObjTableWhereUniqueInput
    create: XOR<csvObjTableCreateWithoutCropTableInput, csvObjTableUncheckedCreateWithoutCropTableInput>
  }

  export type organizationsTableCreateWithoutCropTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    stakeholderTypesTable?: stakeholderTypesTableCreateNestedOneWithoutOrganizationsTableInput
    profilesTable?: profilesTableCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUncheckedCreateWithoutCropTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    stakeholderTypeId?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    profilesTable?: profilesTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableCreateOrConnectWithoutCropTableInput = {
    where: organizationsTableWhereUniqueInput
    create: XOR<organizationsTableCreateWithoutCropTableInput, organizationsTableUncheckedCreateWithoutCropTableInput>
  }

  export type projectsTableCreateWithoutCropTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    source?: string | null
    landTable?: landTableCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutProjectsTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutProjectsTableInput
  }

  export type projectsTableUncheckedCreateWithoutCropTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    csvobjId?: string | null
    source?: string | null
    landTable?: landTableUncheckedCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutProjectsTableInput
  }

  export type projectsTableCreateOrConnectWithoutCropTableInput = {
    where: projectsTableWhereUniqueInput
    create: XOR<projectsTableCreateWithoutCropTableInput, projectsTableUncheckedCreateWithoutCropTableInput>
  }

  export type speciesTableCreateWithoutCropTableInput = {
    speciesId: string
    commonName: string
    scientificName?: string | null
    type?: string | null
    family?: string | null
    reference?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
  }

  export type speciesTableUncheckedCreateWithoutCropTableInput = {
    speciesId: string
    commonName: string
    scientificName?: string | null
    type?: string | null
    family?: string | null
    reference?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
  }

  export type speciesTableCreateOrConnectWithoutCropTableInput = {
    where: speciesTableWhereUniqueInput
    create: XOR<speciesTableCreateWithoutCropTableInput, speciesTableUncheckedCreateWithoutCropTableInput>
  }

  export type plantingTableCreateWithoutCropTableInput = {
    plantingId?: string
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    plantingNotes?: string | null
    landTable?: landTableCreateNestedOneWithoutPlantingTableInput
  }

  export type plantingTableUncheckedCreateWithoutCropTableInput = {
    plantingId?: string
    landId?: string | null
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    plantingNotes?: string | null
  }

  export type plantingTableCreateOrConnectWithoutCropTableInput = {
    where: plantingTableWhereUniqueInput
    create: XOR<plantingTableCreateWithoutCropTableInput, plantingTableUncheckedCreateWithoutCropTableInput>
  }

  export type plantingTableCreateManyCropTableInputEnvelope = {
    data: plantingTableCreateManyCropTableInput | plantingTableCreateManyCropTableInput[]
    skipDuplicates?: boolean
  }

  export type cropStakeholdersTableUpsertWithWhereUniqueWithoutCropTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    update: XOR<cropStakeholdersTableUpdateWithoutCropTableInput, cropStakeholdersTableUncheckedUpdateWithoutCropTableInput>
    create: XOR<cropStakeholdersTableCreateWithoutCropTableInput, cropStakeholdersTableUncheckedCreateWithoutCropTableInput>
  }

  export type cropStakeholdersTableUpdateWithWhereUniqueWithoutCropTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    data: XOR<cropStakeholdersTableUpdateWithoutCropTableInput, cropStakeholdersTableUncheckedUpdateWithoutCropTableInput>
  }

  export type cropStakeholdersTableUpdateManyWithWhereWithoutCropTableInput = {
    where: cropStakeholdersTableScalarWhereInput
    data: XOR<cropStakeholdersTableUpdateManyMutationInput, cropStakeholdersTableUncheckedUpdateManyWithoutCropTableInput>
  }

  export type cropStakeholdersTableScalarWhereInput = {
    AND?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
    OR?: cropStakeholdersTableScalarWhereInput[]
    NOT?: cropStakeholdersTableScalarWhereInput | cropStakeholdersTableScalarWhereInput[]
    cropStakeholderId?: UuidFilter<"cropStakeholdersTable"> | string
    cropId?: UuidFilter<"cropStakeholdersTable"> | string
    organizationId?: UuidFilter<"cropStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"cropStakeholdersTable"> | string
  }

  export type csvObjTableUpsertWithoutCropTableInput = {
    update: XOR<csvObjTableUpdateWithoutCropTableInput, csvObjTableUncheckedUpdateWithoutCropTableInput>
    create: XOR<csvObjTableCreateWithoutCropTableInput, csvObjTableUncheckedCreateWithoutCropTableInput>
    where?: csvObjTableWhereInput
  }

  export type csvObjTableUpdateToOneWithWhereWithoutCropTableInput = {
    where?: csvObjTableWhereInput
    data: XOR<csvObjTableUpdateWithoutCropTableInput, csvObjTableUncheckedUpdateWithoutCropTableInput>
  }

  export type csvObjTableUpdateWithoutCropTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landTable?: landTableUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUpdateManyWithoutCsvObjTableNestedInput
  }

  export type csvObjTableUncheckedUpdateWithoutCropTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landTable?: landTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
  }

  export type organizationsTableUpsertWithoutCropTableInput = {
    update: XOR<organizationsTableUpdateWithoutCropTableInput, organizationsTableUncheckedUpdateWithoutCropTableInput>
    create: XOR<organizationsTableCreateWithoutCropTableInput, organizationsTableUncheckedCreateWithoutCropTableInput>
    where?: organizationsTableWhereInput
  }

  export type organizationsTableUpdateToOneWithWhereWithoutCropTableInput = {
    where?: organizationsTableWhereInput
    data: XOR<organizationsTableUpdateWithoutCropTableInput, organizationsTableUncheckedUpdateWithoutCropTableInput>
  }

  export type organizationsTableUpdateWithoutCropTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateWithoutCropTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    stakeholderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type projectsTableUpsertWithoutCropTableInput = {
    update: XOR<projectsTableUpdateWithoutCropTableInput, projectsTableUncheckedUpdateWithoutCropTableInput>
    create: XOR<projectsTableCreateWithoutCropTableInput, projectsTableUncheckedCreateWithoutCropTableInput>
    where?: projectsTableWhereInput
  }

  export type projectsTableUpdateToOneWithWhereWithoutCropTableInput = {
    where?: projectsTableWhereInput
    data: XOR<projectsTableUpdateWithoutCropTableInput, projectsTableUncheckedUpdateWithoutCropTableInput>
  }

  export type projectsTableUpdateWithoutCropTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    landTable?: landTableUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutProjectsTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutProjectsTableNestedInput
  }

  export type projectsTableUncheckedUpdateWithoutCropTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    landTable?: landTableUncheckedUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutProjectsTableNestedInput
  }

  export type speciesTableUpsertWithoutCropTableInput = {
    update: XOR<speciesTableUpdateWithoutCropTableInput, speciesTableUncheckedUpdateWithoutCropTableInput>
    create: XOR<speciesTableCreateWithoutCropTableInput, speciesTableUncheckedCreateWithoutCropTableInput>
    where?: speciesTableWhereInput
  }

  export type speciesTableUpdateToOneWithWhereWithoutCropTableInput = {
    where?: speciesTableWhereInput
    data: XOR<speciesTableUpdateWithoutCropTableInput, speciesTableUncheckedUpdateWithoutCropTableInput>
  }

  export type speciesTableUpdateWithoutCropTableInput = {
    speciesId?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    family?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type speciesTableUncheckedUpdateWithoutCropTableInput = {
    speciesId?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    family?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type plantingTableUpsertWithWhereUniqueWithoutCropTableInput = {
    where: plantingTableWhereUniqueInput
    update: XOR<plantingTableUpdateWithoutCropTableInput, plantingTableUncheckedUpdateWithoutCropTableInput>
    create: XOR<plantingTableCreateWithoutCropTableInput, plantingTableUncheckedCreateWithoutCropTableInput>
  }

  export type plantingTableUpdateWithWhereUniqueWithoutCropTableInput = {
    where: plantingTableWhereUniqueInput
    data: XOR<plantingTableUpdateWithoutCropTableInput, plantingTableUncheckedUpdateWithoutCropTableInput>
  }

  export type plantingTableUpdateManyWithWhereWithoutCropTableInput = {
    where: plantingTableScalarWhereInput
    data: XOR<plantingTableUpdateManyMutationInput, plantingTableUncheckedUpdateManyWithoutCropTableInput>
  }

  export type plantingTableScalarWhereInput = {
    AND?: plantingTableScalarWhereInput | plantingTableScalarWhereInput[]
    OR?: plantingTableScalarWhereInput[]
    NOT?: plantingTableScalarWhereInput | plantingTableScalarWhereInput[]
    plantingId?: UuidFilter<"plantingTable"> | string
    landId?: UuidNullableFilter<"plantingTable"> | string | null
    planted?: IntNullableFilter<"plantingTable"> | number | null
    plantingDate?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"plantingTable"> | Date | string | null
    deleted?: BoolNullableFilter<"plantingTable"> | boolean | null
    cropId?: UuidNullableFilter<"plantingTable"> | string | null
    plantingNotes?: StringNullableFilter<"plantingTable"> | string | null
  }

  export type cropTableCreateWithoutCsvObjTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropNotes?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutCropTableInput
    organizationsTable?: organizationsTableCreateNestedOneWithoutCropTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutCropTableInput
    speciesTable?: speciesTableCreateNestedOneWithoutCropTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutCropTableInput
  }

  export type cropTableUncheckedCreateWithoutCsvObjTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutCropTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutCropTableInput
  }

  export type cropTableCreateOrConnectWithoutCsvObjTableInput = {
    where: cropTableWhereUniqueInput
    create: XOR<cropTableCreateWithoutCsvObjTableInput, cropTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type cropTableCreateManyCsvObjTableInputEnvelope = {
    data: cropTableCreateManyCsvObjTableInput | cropTableCreateManyCsvObjTableInput[]
    skipDuplicates?: boolean
  }

  export type landTableCreateWithoutCsvObjTableInput = {
    landId?: string
    landName: string
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutLandTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutLandTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutLandTableInput
  }

  export type landTableUncheckedCreateWithoutCsvObjTableInput = {
    landId?: string
    landName: string
    projectId?: string | null
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutLandTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutLandTableInput
  }

  export type landTableCreateOrConnectWithoutCsvObjTableInput = {
    where: landTableWhereUniqueInput
    create: XOR<landTableCreateWithoutCsvObjTableInput, landTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type landTableCreateManyCsvObjTableInputEnvelope = {
    data: landTableCreateManyCsvObjTableInput | landTableCreateManyCsvObjTableInput[]
    skipDuplicates?: boolean
  }

  export type metadataTableCreateWithoutCsvObjTableInput = {
    metadataId?: string
    csvKey: string
    dbKey: string
    createdAt?: Date | string | null
  }

  export type metadataTableUncheckedCreateWithoutCsvObjTableInput = {
    metadataId?: string
    csvKey: string
    dbKey: string
    createdAt?: Date | string | null
  }

  export type metadataTableCreateOrConnectWithoutCsvObjTableInput = {
    where: metadataTableWhereUniqueInput
    create: XOR<metadataTableCreateWithoutCsvObjTableInput, metadataTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type metadataTableCreateManyCsvObjTableInputEnvelope = {
    data: metadataTableCreateManyCsvObjTableInput | metadataTableCreateManyCsvObjTableInput[]
    skipDuplicates?: boolean
  }

  export type projectsTableCreateWithoutCsvObjTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    source?: string | null
    cropTable?: cropTableCreateNestedManyWithoutProjectsTableInput
    landTable?: landTableCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutProjectsTableInput
  }

  export type projectsTableUncheckedCreateWithoutCsvObjTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    source?: string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutProjectsTableInput
    landTable?: landTableUncheckedCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutProjectsTableInput
  }

  export type projectsTableCreateOrConnectWithoutCsvObjTableInput = {
    where: projectsTableWhereUniqueInput
    create: XOR<projectsTableCreateWithoutCsvObjTableInput, projectsTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type projectsTableCreateManyCsvObjTableInputEnvelope = {
    data: projectsTableCreateManyCsvObjTableInput | projectsTableCreateManyCsvObjTableInput[]
    skipDuplicates?: boolean
  }

  export type cropTableUpsertWithWhereUniqueWithoutCsvObjTableInput = {
    where: cropTableWhereUniqueInput
    update: XOR<cropTableUpdateWithoutCsvObjTableInput, cropTableUncheckedUpdateWithoutCsvObjTableInput>
    create: XOR<cropTableCreateWithoutCsvObjTableInput, cropTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type cropTableUpdateWithWhereUniqueWithoutCsvObjTableInput = {
    where: cropTableWhereUniqueInput
    data: XOR<cropTableUpdateWithoutCsvObjTableInput, cropTableUncheckedUpdateWithoutCsvObjTableInput>
  }

  export type cropTableUpdateManyWithWhereWithoutCsvObjTableInput = {
    where: cropTableScalarWhereInput
    data: XOR<cropTableUpdateManyMutationInput, cropTableUncheckedUpdateManyWithoutCsvObjTableInput>
  }

  export type cropTableScalarWhereInput = {
    AND?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
    OR?: cropTableScalarWhereInput[]
    NOT?: cropTableScalarWhereInput | cropTableScalarWhereInput[]
    cropId?: UuidFilter<"cropTable"> | string
    cropName?: StringFilter<"cropTable"> | string
    speciesId?: UuidNullableFilter<"cropTable"> | string | null
    seedInfo?: StringNullableFilter<"cropTable"> | string | null
    cropStock?: StringNullableFilter<"cropTable"> | string | null
    createdAt?: DateTimeNullableFilter<"cropTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"cropTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"cropTable"> | string | null
    deleted?: BoolNullableFilter<"cropTable"> | boolean | null
    projectId?: UuidNullableFilter<"cropTable"> | string | null
    organizationId?: UuidNullableFilter<"cropTable"> | string | null
    cropNotes?: StringNullableFilter<"cropTable"> | string | null
    csvobjId?: UuidNullableFilter<"cropTable"> | string | null
    speciesTemp?: StringNullableFilter<"cropTable"> | string | null
  }

  export type landTableUpsertWithWhereUniqueWithoutCsvObjTableInput = {
    where: landTableWhereUniqueInput
    update: XOR<landTableUpdateWithoutCsvObjTableInput, landTableUncheckedUpdateWithoutCsvObjTableInput>
    create: XOR<landTableCreateWithoutCsvObjTableInput, landTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type landTableUpdateWithWhereUniqueWithoutCsvObjTableInput = {
    where: landTableWhereUniqueInput
    data: XOR<landTableUpdateWithoutCsvObjTableInput, landTableUncheckedUpdateWithoutCsvObjTableInput>
  }

  export type landTableUpdateManyWithWhereWithoutCsvObjTableInput = {
    where: landTableScalarWhereInput
    data: XOR<landTableUpdateManyMutationInput, landTableUncheckedUpdateManyWithoutCsvObjTableInput>
  }

  export type landTableScalarWhereInput = {
    AND?: landTableScalarWhereInput | landTableScalarWhereInput[]
    OR?: landTableScalarWhereInput[]
    NOT?: landTableScalarWhereInput | landTableScalarWhereInput[]
    landId?: UuidFilter<"landTable"> | string
    landName?: StringFilter<"landTable"> | string
    projectId?: UuidNullableFilter<"landTable"> | string | null
    hectares?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLat?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    gpsLon?: DecimalNullableFilter<"landTable"> | Decimal | DecimalJsLike | number | string | null
    landNotes?: StringNullableFilter<"landTable"> | string | null
    createdAt?: DateTimeNullableFilter<"landTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"landTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"landTable"> | string | null
    deleted?: BoolNullableFilter<"landTable"> | boolean | null
    preparation?: EnumPreparationNullableFilter<"landTable"> | $Enums.Preparation | null
    csvobjId?: UuidNullableFilter<"landTable"> | string | null
    polygon?: JsonNullableFilter<"landTable">
  }

  export type metadataTableUpsertWithWhereUniqueWithoutCsvObjTableInput = {
    where: metadataTableWhereUniqueInput
    update: XOR<metadataTableUpdateWithoutCsvObjTableInput, metadataTableUncheckedUpdateWithoutCsvObjTableInput>
    create: XOR<metadataTableCreateWithoutCsvObjTableInput, metadataTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type metadataTableUpdateWithWhereUniqueWithoutCsvObjTableInput = {
    where: metadataTableWhereUniqueInput
    data: XOR<metadataTableUpdateWithoutCsvObjTableInput, metadataTableUncheckedUpdateWithoutCsvObjTableInput>
  }

  export type metadataTableUpdateManyWithWhereWithoutCsvObjTableInput = {
    where: metadataTableScalarWhereInput
    data: XOR<metadataTableUpdateManyMutationInput, metadataTableUncheckedUpdateManyWithoutCsvObjTableInput>
  }

  export type metadataTableScalarWhereInput = {
    AND?: metadataTableScalarWhereInput | metadataTableScalarWhereInput[]
    OR?: metadataTableScalarWhereInput[]
    NOT?: metadataTableScalarWhereInput | metadataTableScalarWhereInput[]
    metadataId?: UuidFilter<"metadataTable"> | string
    csvobjId?: UuidFilter<"metadataTable"> | string
    csvKey?: StringFilter<"metadataTable"> | string
    dbKey?: StringFilter<"metadataTable"> | string
    createdAt?: DateTimeNullableFilter<"metadataTable"> | Date | string | null
  }

  export type projectsTableUpsertWithWhereUniqueWithoutCsvObjTableInput = {
    where: projectsTableWhereUniqueInput
    update: XOR<projectsTableUpdateWithoutCsvObjTableInput, projectsTableUncheckedUpdateWithoutCsvObjTableInput>
    create: XOR<projectsTableCreateWithoutCsvObjTableInput, projectsTableUncheckedCreateWithoutCsvObjTableInput>
  }

  export type projectsTableUpdateWithWhereUniqueWithoutCsvObjTableInput = {
    where: projectsTableWhereUniqueInput
    data: XOR<projectsTableUpdateWithoutCsvObjTableInput, projectsTableUncheckedUpdateWithoutCsvObjTableInput>
  }

  export type projectsTableUpdateManyWithWhereWithoutCsvObjTableInput = {
    where: projectsTableScalarWhereInput
    data: XOR<projectsTableUpdateManyMutationInput, projectsTableUncheckedUpdateManyWithoutCsvObjTableInput>
  }

  export type projectsTableScalarWhereInput = {
    AND?: projectsTableScalarWhereInput | projectsTableScalarWhereInput[]
    OR?: projectsTableScalarWhereInput[]
    NOT?: projectsTableScalarWhereInput | projectsTableScalarWhereInput[]
    projectId?: UuidFilter<"projectsTable"> | string
    projectName?: StringFilter<"projectsTable"> | string
    projectNotes?: StringNullableFilter<"projectsTable"> | string | null
    createdAt?: DateTimeNullableFilter<"projectsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"projectsTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"projectsTable"> | string | null
    deleted?: BoolNullableFilter<"projectsTable"> | boolean | null
    csvobjId?: UuidNullableFilter<"projectsTable"> | string | null
    source?: StringNullableFilter<"projectsTable"> | string | null
  }

  export type landTableCreateWithoutLandStakeholdersTableInput = {
    landId?: string
    landName: string
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    csvObjTable?: csvObjTableCreateNestedOneWithoutLandTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutLandTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutLandTableInput
  }

  export type landTableUncheckedCreateWithoutLandStakeholdersTableInput = {
    landId?: string
    landName: string
    projectId?: string | null
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    csvobjId?: string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutLandTableInput
  }

  export type landTableCreateOrConnectWithoutLandStakeholdersTableInput = {
    where: landTableWhereUniqueInput
    create: XOR<landTableCreateWithoutLandStakeholdersTableInput, landTableUncheckedCreateWithoutLandStakeholdersTableInput>
  }

  export type organizationsTableCreateWithoutLandStakeholdersTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableCreateNestedManyWithoutOrganizationsTableInput
    stakeholderTypesTable?: stakeholderTypesTableCreateNestedOneWithoutOrganizationsTableInput
    profilesTable?: profilesTableCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUncheckedCreateWithoutLandStakeholdersTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    stakeholderTypeId?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    profilesTable?: profilesTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableCreateOrConnectWithoutLandStakeholdersTableInput = {
    where: organizationsTableWhereUniqueInput
    create: XOR<organizationsTableCreateWithoutLandStakeholdersTableInput, organizationsTableUncheckedCreateWithoutLandStakeholdersTableInput>
  }

  export type stakeholderTypesTableCreateWithoutLandStakeholdersTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableUncheckedCreateWithoutLandStakeholdersTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableCreateOrConnectWithoutLandStakeholdersTableInput = {
    where: stakeholderTypesTableWhereUniqueInput
    create: XOR<stakeholderTypesTableCreateWithoutLandStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutLandStakeholdersTableInput>
  }

  export type landTableUpsertWithoutLandStakeholdersTableInput = {
    update: XOR<landTableUpdateWithoutLandStakeholdersTableInput, landTableUncheckedUpdateWithoutLandStakeholdersTableInput>
    create: XOR<landTableCreateWithoutLandStakeholdersTableInput, landTableUncheckedCreateWithoutLandStakeholdersTableInput>
    where?: landTableWhereInput
  }

  export type landTableUpdateToOneWithWhereWithoutLandStakeholdersTableInput = {
    where?: landTableWhereInput
    data: XOR<landTableUpdateWithoutLandStakeholdersTableInput, landTableUncheckedUpdateWithoutLandStakeholdersTableInput>
  }

  export type landTableUpdateWithoutLandStakeholdersTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    csvObjTable?: csvObjTableUpdateOneWithoutLandTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutLandTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutLandTableNestedInput
  }

  export type landTableUncheckedUpdateWithoutLandStakeholdersTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    plantingTable?: plantingTableUncheckedUpdateManyWithoutLandTableNestedInput
  }

  export type organizationsTableUpsertWithoutLandStakeholdersTableInput = {
    update: XOR<organizationsTableUpdateWithoutLandStakeholdersTableInput, organizationsTableUncheckedUpdateWithoutLandStakeholdersTableInput>
    create: XOR<organizationsTableCreateWithoutLandStakeholdersTableInput, organizationsTableUncheckedCreateWithoutLandStakeholdersTableInput>
    where?: organizationsTableWhereInput
  }

  export type organizationsTableUpdateToOneWithWhereWithoutLandStakeholdersTableInput = {
    where?: organizationsTableWhereInput
    data: XOR<organizationsTableUpdateWithoutLandStakeholdersTableInput, organizationsTableUncheckedUpdateWithoutLandStakeholdersTableInput>
  }

  export type organizationsTableUpdateWithoutLandStakeholdersTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUpdateManyWithoutOrganizationsTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateWithoutLandStakeholdersTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    stakeholderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type stakeholderTypesTableUpsertWithoutLandStakeholdersTableInput = {
    update: XOR<stakeholderTypesTableUpdateWithoutLandStakeholdersTableInput, stakeholderTypesTableUncheckedUpdateWithoutLandStakeholdersTableInput>
    create: XOR<stakeholderTypesTableCreateWithoutLandStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutLandStakeholdersTableInput>
    where?: stakeholderTypesTableWhereInput
  }

  export type stakeholderTypesTableUpdateToOneWithWhereWithoutLandStakeholdersTableInput = {
    where?: stakeholderTypesTableWhereInput
    data: XOR<stakeholderTypesTableUpdateWithoutLandStakeholdersTableInput, stakeholderTypesTableUncheckedUpdateWithoutLandStakeholdersTableInput>
  }

  export type stakeholderTypesTableUpdateWithoutLandStakeholdersTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type stakeholderTypesTableUncheckedUpdateWithoutLandStakeholdersTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type landStakeholdersTableCreateWithoutLandTableInput = {
    landStakeholderId?: string
    organizationsTable: organizationsTableCreateNestedOneWithoutLandStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutLandStakeholdersTableInput
  }

  export type landStakeholdersTableUncheckedCreateWithoutLandTableInput = {
    landStakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type landStakeholdersTableCreateOrConnectWithoutLandTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    create: XOR<landStakeholdersTableCreateWithoutLandTableInput, landStakeholdersTableUncheckedCreateWithoutLandTableInput>
  }

  export type landStakeholdersTableCreateManyLandTableInputEnvelope = {
    data: landStakeholdersTableCreateManyLandTableInput | landStakeholdersTableCreateManyLandTableInput[]
    skipDuplicates?: boolean
  }

  export type csvObjTableCreateWithoutLandTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableUncheckedCreateWithoutLandTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableUncheckedCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableCreateOrConnectWithoutLandTableInput = {
    where: csvObjTableWhereUniqueInput
    create: XOR<csvObjTableCreateWithoutLandTableInput, csvObjTableUncheckedCreateWithoutLandTableInput>
  }

  export type projectsTableCreateWithoutLandTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    source?: string | null
    cropTable?: cropTableCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutProjectsTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutProjectsTableInput
  }

  export type projectsTableUncheckedCreateWithoutLandTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    csvobjId?: string | null
    source?: string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutProjectsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutProjectsTableInput
  }

  export type projectsTableCreateOrConnectWithoutLandTableInput = {
    where: projectsTableWhereUniqueInput
    create: XOR<projectsTableCreateWithoutLandTableInput, projectsTableUncheckedCreateWithoutLandTableInput>
  }

  export type plantingTableCreateWithoutLandTableInput = {
    plantingId?: string
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    plantingNotes?: string | null
    cropTable?: cropTableCreateNestedOneWithoutPlantingTableInput
  }

  export type plantingTableUncheckedCreateWithoutLandTableInput = {
    plantingId?: string
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    cropId?: string | null
    plantingNotes?: string | null
  }

  export type plantingTableCreateOrConnectWithoutLandTableInput = {
    where: plantingTableWhereUniqueInput
    create: XOR<plantingTableCreateWithoutLandTableInput, plantingTableUncheckedCreateWithoutLandTableInput>
  }

  export type plantingTableCreateManyLandTableInputEnvelope = {
    data: plantingTableCreateManyLandTableInput | plantingTableCreateManyLandTableInput[]
    skipDuplicates?: boolean
  }

  export type landStakeholdersTableUpsertWithWhereUniqueWithoutLandTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    update: XOR<landStakeholdersTableUpdateWithoutLandTableInput, landStakeholdersTableUncheckedUpdateWithoutLandTableInput>
    create: XOR<landStakeholdersTableCreateWithoutLandTableInput, landStakeholdersTableUncheckedCreateWithoutLandTableInput>
  }

  export type landStakeholdersTableUpdateWithWhereUniqueWithoutLandTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    data: XOR<landStakeholdersTableUpdateWithoutLandTableInput, landStakeholdersTableUncheckedUpdateWithoutLandTableInput>
  }

  export type landStakeholdersTableUpdateManyWithWhereWithoutLandTableInput = {
    where: landStakeholdersTableScalarWhereInput
    data: XOR<landStakeholdersTableUpdateManyMutationInput, landStakeholdersTableUncheckedUpdateManyWithoutLandTableInput>
  }

  export type landStakeholdersTableScalarWhereInput = {
    AND?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
    OR?: landStakeholdersTableScalarWhereInput[]
    NOT?: landStakeholdersTableScalarWhereInput | landStakeholdersTableScalarWhereInput[]
    landStakeholderId?: UuidFilter<"landStakeholdersTable"> | string
    landId?: UuidFilter<"landStakeholdersTable"> | string
    organizationId?: UuidFilter<"landStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"landStakeholdersTable"> | string
  }

  export type csvObjTableUpsertWithoutLandTableInput = {
    update: XOR<csvObjTableUpdateWithoutLandTableInput, csvObjTableUncheckedUpdateWithoutLandTableInput>
    create: XOR<csvObjTableCreateWithoutLandTableInput, csvObjTableUncheckedCreateWithoutLandTableInput>
    where?: csvObjTableWhereInput
  }

  export type csvObjTableUpdateToOneWithWhereWithoutLandTableInput = {
    where?: csvObjTableWhereInput
    data: XOR<csvObjTableUpdateWithoutLandTableInput, csvObjTableUncheckedUpdateWithoutLandTableInput>
  }

  export type csvObjTableUpdateWithoutLandTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUpdateManyWithoutCsvObjTableNestedInput
  }

  export type csvObjTableUncheckedUpdateWithoutLandTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
  }

  export type projectsTableUpsertWithoutLandTableInput = {
    update: XOR<projectsTableUpdateWithoutLandTableInput, projectsTableUncheckedUpdateWithoutLandTableInput>
    create: XOR<projectsTableCreateWithoutLandTableInput, projectsTableUncheckedCreateWithoutLandTableInput>
    where?: projectsTableWhereInput
  }

  export type projectsTableUpdateToOneWithWhereWithoutLandTableInput = {
    where?: projectsTableWhereInput
    data: XOR<projectsTableUpdateWithoutLandTableInput, projectsTableUncheckedUpdateWithoutLandTableInput>
  }

  export type projectsTableUpdateWithoutLandTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutProjectsTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutProjectsTableNestedInput
  }

  export type projectsTableUncheckedUpdateWithoutLandTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutProjectsTableNestedInput
  }

  export type plantingTableUpsertWithWhereUniqueWithoutLandTableInput = {
    where: plantingTableWhereUniqueInput
    update: XOR<plantingTableUpdateWithoutLandTableInput, plantingTableUncheckedUpdateWithoutLandTableInput>
    create: XOR<plantingTableCreateWithoutLandTableInput, plantingTableUncheckedCreateWithoutLandTableInput>
  }

  export type plantingTableUpdateWithWhereUniqueWithoutLandTableInput = {
    where: plantingTableWhereUniqueInput
    data: XOR<plantingTableUpdateWithoutLandTableInput, plantingTableUncheckedUpdateWithoutLandTableInput>
  }

  export type plantingTableUpdateManyWithWhereWithoutLandTableInput = {
    where: plantingTableScalarWhereInput
    data: XOR<plantingTableUpdateManyMutationInput, plantingTableUncheckedUpdateManyWithoutLandTableInput>
  }

  export type csvObjTableCreateWithoutMetadataTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableCreateNestedManyWithoutCsvObjTableInput
    landTable?: landTableCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableUncheckedCreateWithoutMetadataTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    landTable?: landTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    projectsTable?: projectsTableUncheckedCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableCreateOrConnectWithoutMetadataTableInput = {
    where: csvObjTableWhereUniqueInput
    create: XOR<csvObjTableCreateWithoutMetadataTableInput, csvObjTableUncheckedCreateWithoutMetadataTableInput>
  }

  export type csvObjTableUpsertWithoutMetadataTableInput = {
    update: XOR<csvObjTableUpdateWithoutMetadataTableInput, csvObjTableUncheckedUpdateWithoutMetadataTableInput>
    create: XOR<csvObjTableCreateWithoutMetadataTableInput, csvObjTableUncheckedCreateWithoutMetadataTableInput>
    where?: csvObjTableWhereInput
  }

  export type csvObjTableUpdateToOneWithWhereWithoutMetadataTableInput = {
    where?: csvObjTableWhereInput
    data: XOR<csvObjTableUpdateWithoutMetadataTableInput, csvObjTableUncheckedUpdateWithoutMetadataTableInput>
  }

  export type csvObjTableUpdateWithoutMetadataTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUpdateManyWithoutCsvObjTableNestedInput
    landTable?: landTableUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUpdateManyWithoutCsvObjTableNestedInput
  }

  export type csvObjTableUncheckedUpdateWithoutMetadataTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    landTable?: landTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    projectsTable?: projectsTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
  }

  export type cropStakeholdersTableCreateWithoutOrganizationsTableInput = {
    cropStakeholderId?: string
    cropTable: cropTableCreateNestedOneWithoutCropStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutCropStakeholdersTableInput
  }

  export type cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput = {
    cropStakeholderId?: string
    cropId: string
    stakeholderTypeId: string
  }

  export type cropStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    create: XOR<cropStakeholdersTableCreateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type cropStakeholdersTableCreateManyOrganizationsTableInputEnvelope = {
    data: cropStakeholdersTableCreateManyOrganizationsTableInput | cropStakeholdersTableCreateManyOrganizationsTableInput[]
    skipDuplicates?: boolean
  }

  export type cropTableCreateWithoutOrganizationsTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropNotes?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutCropTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutCropTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutCropTableInput
    speciesTable?: speciesTableCreateNestedOneWithoutCropTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutCropTableInput
  }

  export type cropTableUncheckedCreateWithoutOrganizationsTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutCropTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutCropTableInput
  }

  export type cropTableCreateOrConnectWithoutOrganizationsTableInput = {
    where: cropTableWhereUniqueInput
    create: XOR<cropTableCreateWithoutOrganizationsTableInput, cropTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type cropTableCreateManyOrganizationsTableInputEnvelope = {
    data: cropTableCreateManyOrganizationsTableInput | cropTableCreateManyOrganizationsTableInput[]
    skipDuplicates?: boolean
  }

  export type landStakeholdersTableCreateWithoutOrganizationsTableInput = {
    landStakeholderId?: string
    landTable: landTableCreateNestedOneWithoutLandStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutLandStakeholdersTableInput
  }

  export type landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput = {
    landStakeholderId?: string
    landId: string
    stakeholderTypeId: string
  }

  export type landStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    create: XOR<landStakeholdersTableCreateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type landStakeholdersTableCreateManyOrganizationsTableInputEnvelope = {
    data: landStakeholdersTableCreateManyOrganizationsTableInput | landStakeholdersTableCreateManyOrganizationsTableInput[]
    skipDuplicates?: boolean
  }

  export type stakeholderTypesTableCreateWithoutOrganizationsTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableUncheckedCreateWithoutOrganizationsTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableCreateOrConnectWithoutOrganizationsTableInput = {
    where: stakeholderTypesTableWhereUniqueInput
    create: XOR<stakeholderTypesTableCreateWithoutOrganizationsTableInput, stakeholderTypesTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type profilesTableCreateWithoutOrganizationsTableInput = {
    id?: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    locale?: string | null
    timezone?: string | null
    users: usersCreateNestedOneWithoutProfilesTableInput
  }

  export type profilesTableUncheckedCreateWithoutOrganizationsTableInput = {
    id?: string
    user_id: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    locale?: string | null
    timezone?: string | null
  }

  export type profilesTableCreateOrConnectWithoutOrganizationsTableInput = {
    where: profilesTableWhereUniqueInput
    create: XOR<profilesTableCreateWithoutOrganizationsTableInput, profilesTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type profilesTableCreateManyOrganizationsTableInputEnvelope = {
    data: profilesTableCreateManyOrganizationsTableInput | profilesTableCreateManyOrganizationsTableInput[]
    skipDuplicates?: boolean
  }

  export type projectStakeholdersTableCreateWithoutOrganizationsTableInput = {
    stakeholderId?: string
    projectsTable: projectsTableCreateNestedOneWithoutProjectStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutProjectStakeholdersTableInput
  }

  export type projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput = {
    stakeholderId?: string
    stakeholderTypeId: string
    projectId: string
  }

  export type projectStakeholdersTableCreateOrConnectWithoutOrganizationsTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    create: XOR<projectStakeholdersTableCreateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type projectStakeholdersTableCreateManyOrganizationsTableInputEnvelope = {
    data: projectStakeholdersTableCreateManyOrganizationsTableInput | projectStakeholdersTableCreateManyOrganizationsTableInput[]
    skipDuplicates?: boolean
  }

  export type cropStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    update: XOR<cropStakeholdersTableUpdateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput>
    create: XOR<cropStakeholdersTableCreateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type cropStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    data: XOR<cropStakeholdersTableUpdateWithoutOrganizationsTableInput, cropStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput>
  }

  export type cropStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput = {
    where: cropStakeholdersTableScalarWhereInput
    data: XOR<cropStakeholdersTableUpdateManyMutationInput, cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableInput>
  }

  export type cropTableUpsertWithWhereUniqueWithoutOrganizationsTableInput = {
    where: cropTableWhereUniqueInput
    update: XOR<cropTableUpdateWithoutOrganizationsTableInput, cropTableUncheckedUpdateWithoutOrganizationsTableInput>
    create: XOR<cropTableCreateWithoutOrganizationsTableInput, cropTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type cropTableUpdateWithWhereUniqueWithoutOrganizationsTableInput = {
    where: cropTableWhereUniqueInput
    data: XOR<cropTableUpdateWithoutOrganizationsTableInput, cropTableUncheckedUpdateWithoutOrganizationsTableInput>
  }

  export type cropTableUpdateManyWithWhereWithoutOrganizationsTableInput = {
    where: cropTableScalarWhereInput
    data: XOR<cropTableUpdateManyMutationInput, cropTableUncheckedUpdateManyWithoutOrganizationsTableInput>
  }

  export type landStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    update: XOR<landStakeholdersTableUpdateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput>
    create: XOR<landStakeholdersTableCreateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type landStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    data: XOR<landStakeholdersTableUpdateWithoutOrganizationsTableInput, landStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput>
  }

  export type landStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput = {
    where: landStakeholdersTableScalarWhereInput
    data: XOR<landStakeholdersTableUpdateManyMutationInput, landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableInput>
  }

  export type stakeholderTypesTableUpsertWithoutOrganizationsTableInput = {
    update: XOR<stakeholderTypesTableUpdateWithoutOrganizationsTableInput, stakeholderTypesTableUncheckedUpdateWithoutOrganizationsTableInput>
    create: XOR<stakeholderTypesTableCreateWithoutOrganizationsTableInput, stakeholderTypesTableUncheckedCreateWithoutOrganizationsTableInput>
    where?: stakeholderTypesTableWhereInput
  }

  export type stakeholderTypesTableUpdateToOneWithWhereWithoutOrganizationsTableInput = {
    where?: stakeholderTypesTableWhereInput
    data: XOR<stakeholderTypesTableUpdateWithoutOrganizationsTableInput, stakeholderTypesTableUncheckedUpdateWithoutOrganizationsTableInput>
  }

  export type stakeholderTypesTableUpdateWithoutOrganizationsTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type stakeholderTypesTableUncheckedUpdateWithoutOrganizationsTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type profilesTableUpsertWithWhereUniqueWithoutOrganizationsTableInput = {
    where: profilesTableWhereUniqueInput
    update: XOR<profilesTableUpdateWithoutOrganizationsTableInput, profilesTableUncheckedUpdateWithoutOrganizationsTableInput>
    create: XOR<profilesTableCreateWithoutOrganizationsTableInput, profilesTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type profilesTableUpdateWithWhereUniqueWithoutOrganizationsTableInput = {
    where: profilesTableWhereUniqueInput
    data: XOR<profilesTableUpdateWithoutOrganizationsTableInput, profilesTableUncheckedUpdateWithoutOrganizationsTableInput>
  }

  export type profilesTableUpdateManyWithWhereWithoutOrganizationsTableInput = {
    where: profilesTableScalarWhereInput
    data: XOR<profilesTableUpdateManyMutationInput, profilesTableUncheckedUpdateManyWithoutOrganizationsTableInput>
  }

  export type profilesTableScalarWhereInput = {
    AND?: profilesTableScalarWhereInput | profilesTableScalarWhereInput[]
    OR?: profilesTableScalarWhereInput[]
    NOT?: profilesTableScalarWhereInput | profilesTableScalarWhereInput[]
    id?: UuidFilter<"profilesTable"> | string
    user_id?: UuidFilter<"profilesTable"> | string
    firstname?: StringFilter<"profilesTable"> | string
    lastname?: StringFilter<"profilesTable"> | string
    phonenumber?: StringNullableFilter<"profilesTable"> | string | null
    isactive?: BoolNullableFilter<"profilesTable"> | boolean | null
    isverified?: BoolNullableFilter<"profilesTable"> | boolean | null
    role?: Enumuser_roleNullableFilter<"profilesTable"> | $Enums.user_role | null
    permissions?: JsonNullableFilter<"profilesTable">
    createdat?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    lastlogin?: DateTimeNullableFilter<"profilesTable"> | Date | string | null
    twofactorenabled?: BoolNullableFilter<"profilesTable"> | boolean | null
    twofactorsecret?: StringNullableFilter<"profilesTable"> | string | null
    organizationid?: UuidNullableFilter<"profilesTable"> | string | null
    locale?: StringNullableFilter<"profilesTable"> | string | null
    timezone?: StringNullableFilter<"profilesTable"> | string | null
  }

  export type projectStakeholdersTableUpsertWithWhereUniqueWithoutOrganizationsTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    update: XOR<projectStakeholdersTableUpdateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput>
    create: XOR<projectStakeholdersTableCreateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedCreateWithoutOrganizationsTableInput>
  }

  export type projectStakeholdersTableUpdateWithWhereUniqueWithoutOrganizationsTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    data: XOR<projectStakeholdersTableUpdateWithoutOrganizationsTableInput, projectStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput>
  }

  export type projectStakeholdersTableUpdateManyWithWhereWithoutOrganizationsTableInput = {
    where: projectStakeholdersTableScalarWhereInput
    data: XOR<projectStakeholdersTableUpdateManyMutationInput, projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableInput>
  }

  export type projectStakeholdersTableScalarWhereInput = {
    AND?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
    OR?: projectStakeholdersTableScalarWhereInput[]
    NOT?: projectStakeholdersTableScalarWhereInput | projectStakeholdersTableScalarWhereInput[]
    stakeholderId?: UuidFilter<"projectStakeholdersTable"> | string
    organizationId?: UuidFilter<"projectStakeholdersTable"> | string
    stakeholderTypeId?: UuidFilter<"projectStakeholdersTable"> | string
    projectId?: UuidFilter<"projectStakeholdersTable"> | string
  }

  export type cropTableCreateWithoutPlantingTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropNotes?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutCropTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutCropTableInput
    organizationsTable?: organizationsTableCreateNestedOneWithoutCropTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutCropTableInput
    speciesTable?: speciesTableCreateNestedOneWithoutCropTableInput
  }

  export type cropTableUncheckedCreateWithoutPlantingTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutCropTableInput
  }

  export type cropTableCreateOrConnectWithoutPlantingTableInput = {
    where: cropTableWhereUniqueInput
    create: XOR<cropTableCreateWithoutPlantingTableInput, cropTableUncheckedCreateWithoutPlantingTableInput>
  }

  export type landTableCreateWithoutPlantingTableInput = {
    landId?: string
    landName: string
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutLandTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutLandTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutLandTableInput
  }

  export type landTableUncheckedCreateWithoutPlantingTableInput = {
    landId?: string
    landName: string
    projectId?: string | null
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    csvobjId?: string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutLandTableInput
  }

  export type landTableCreateOrConnectWithoutPlantingTableInput = {
    where: landTableWhereUniqueInput
    create: XOR<landTableCreateWithoutPlantingTableInput, landTableUncheckedCreateWithoutPlantingTableInput>
  }

  export type cropTableUpsertWithoutPlantingTableInput = {
    update: XOR<cropTableUpdateWithoutPlantingTableInput, cropTableUncheckedUpdateWithoutPlantingTableInput>
    create: XOR<cropTableCreateWithoutPlantingTableInput, cropTableUncheckedCreateWithoutPlantingTableInput>
    where?: cropTableWhereInput
  }

  export type cropTableUpdateToOneWithWhereWithoutPlantingTableInput = {
    where?: cropTableWhereInput
    data: XOR<cropTableUpdateWithoutPlantingTableInput, cropTableUncheckedUpdateWithoutPlantingTableInput>
  }

  export type cropTableUpdateWithoutPlantingTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutCropTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutCropTableNestedInput
    organizationsTable?: organizationsTableUpdateOneWithoutCropTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutCropTableNestedInput
    speciesTable?: speciesTableUpdateOneWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateWithoutPlantingTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutCropTableNestedInput
  }

  export type landTableUpsertWithoutPlantingTableInput = {
    update: XOR<landTableUpdateWithoutPlantingTableInput, landTableUncheckedUpdateWithoutPlantingTableInput>
    create: XOR<landTableCreateWithoutPlantingTableInput, landTableUncheckedCreateWithoutPlantingTableInput>
    where?: landTableWhereInput
  }

  export type landTableUpdateToOneWithWhereWithoutPlantingTableInput = {
    where?: landTableWhereInput
    data: XOR<landTableUpdateWithoutPlantingTableInput, landTableUncheckedUpdateWithoutPlantingTableInput>
  }

  export type landTableUpdateWithoutPlantingTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutLandTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutLandTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutLandTableNestedInput
  }

  export type landTableUncheckedUpdateWithoutPlantingTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutLandTableNestedInput
  }

  export type organizationsTableCreateWithoutProfilesTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    stakeholderTypesTable?: stakeholderTypesTableCreateNestedOneWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUncheckedCreateWithoutProfilesTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    stakeholderTypeId?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableCreateOrConnectWithoutProfilesTableInput = {
    where: organizationsTableWhereUniqueInput
    create: XOR<organizationsTableCreateWithoutProfilesTableInput, organizationsTableUncheckedCreateWithoutProfilesTableInput>
  }

  export type usersCreateWithoutProfilesTableInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutProfilesTableInput = {
    instance_id?: string | null
    id: string
    aud?: string | null
    role?: string | null
    email?: string | null
    encrypted_password?: string | null
    email_confirmed_at?: Date | string | null
    invited_at?: Date | string | null
    confirmation_token?: string | null
    confirmation_sent_at?: Date | string | null
    recovery_token?: string | null
    recovery_sent_at?: Date | string | null
    email_change_token_new?: string | null
    email_change?: string | null
    email_change_sent_at?: Date | string | null
    last_sign_in_at?: Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    phone?: string | null
    phone_confirmed_at?: Date | string | null
    phone_change?: string | null
    phone_change_token?: string | null
    phone_change_sent_at?: Date | string | null
    confirmed_at?: Date | string | null
    email_change_token_current?: string | null
    email_change_confirm_status?: number | null
    banned_until?: Date | string | null
    reauthentication_token?: string | null
    reauthentication_sent_at?: Date | string | null
    is_sso_user?: boolean
    deleted_at?: Date | string | null
    is_anonymous?: boolean
    identities?: identitiesUncheckedCreateNestedManyWithoutUsersInput
    mfa_factors?: mfa_factorsUncheckedCreateNestedManyWithoutUsersInput
    one_time_tokens?: one_time_tokensUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutProfilesTableInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProfilesTableInput, usersUncheckedCreateWithoutProfilesTableInput>
  }

  export type organizationsTableUpsertWithoutProfilesTableInput = {
    update: XOR<organizationsTableUpdateWithoutProfilesTableInput, organizationsTableUncheckedUpdateWithoutProfilesTableInput>
    create: XOR<organizationsTableCreateWithoutProfilesTableInput, organizationsTableUncheckedCreateWithoutProfilesTableInput>
    where?: organizationsTableWhereInput
  }

  export type organizationsTableUpdateToOneWithWhereWithoutProfilesTableInput = {
    where?: organizationsTableWhereInput
    data: XOR<organizationsTableUpdateWithoutProfilesTableInput, organizationsTableUncheckedUpdateWithoutProfilesTableInput>
  }

  export type organizationsTableUpdateWithoutProfilesTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateWithoutProfilesTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    stakeholderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type usersUpsertWithoutProfilesTableInput = {
    update: XOR<usersUpdateWithoutProfilesTableInput, usersUncheckedUpdateWithoutProfilesTableInput>
    create: XOR<usersCreateWithoutProfilesTableInput, usersUncheckedCreateWithoutProfilesTableInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProfilesTableInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProfilesTableInput, usersUncheckedUpdateWithoutProfilesTableInput>
  }

  export type usersUpdateWithoutProfilesTableInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutProfilesTableInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    aud?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted_password?: NullableStringFieldUpdateOperationsInput | string | null
    email_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invited_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmation_token?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recovery_token?: NullableStringFieldUpdateOperationsInput | string | null
    recovery_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_new?: NullableStringFieldUpdateOperationsInput | string | null
    email_change?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_app_meta_data?: NullableJsonNullValueInput | InputJsonValue
    raw_user_meta_data?: NullableJsonNullValueInput | InputJsonValue
    is_super_admin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_change?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_token?: NullableStringFieldUpdateOperationsInput | string | null
    phone_change_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_change_token_current?: NullableStringFieldUpdateOperationsInput | string | null
    email_change_confirm_status?: NullableIntFieldUpdateOperationsInput | number | null
    banned_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reauthentication_token?: NullableStringFieldUpdateOperationsInput | string | null
    reauthentication_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_sso_user?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    identities?: identitiesUncheckedUpdateManyWithoutUsersNestedInput
    mfa_factors?: mfa_factorsUncheckedUpdateManyWithoutUsersNestedInput
    one_time_tokens?: one_time_tokensUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type organizationsTableCreateWithoutProjectStakeholdersTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    stakeholderTypesTable?: stakeholderTypesTableCreateNestedOneWithoutOrganizationsTableInput
    profilesTable?: profilesTableCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUncheckedCreateWithoutProjectStakeholdersTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    stakeholderTypeId?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    profilesTable?: profilesTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableCreateOrConnectWithoutProjectStakeholdersTableInput = {
    where: organizationsTableWhereUniqueInput
    create: XOR<organizationsTableCreateWithoutProjectStakeholdersTableInput, organizationsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
  }

  export type projectsTableCreateWithoutProjectStakeholdersTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    source?: string | null
    cropTable?: cropTableCreateNestedManyWithoutProjectsTableInput
    landTable?: landTableCreateNestedManyWithoutProjectsTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutProjectsTableInput
  }

  export type projectsTableUncheckedCreateWithoutProjectStakeholdersTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    csvobjId?: string | null
    source?: string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutProjectsTableInput
    landTable?: landTableUncheckedCreateNestedManyWithoutProjectsTableInput
  }

  export type projectsTableCreateOrConnectWithoutProjectStakeholdersTableInput = {
    where: projectsTableWhereUniqueInput
    create: XOR<projectsTableCreateWithoutProjectStakeholdersTableInput, projectsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
  }

  export type stakeholderTypesTableCreateWithoutProjectStakeholdersTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableUncheckedCreateWithoutProjectStakeholdersTableInput = {
    stakeholderType: string
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    stakeholderTypeId?: string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
    organizationsTable?: organizationsTableUncheckedCreateNestedManyWithoutStakeholderTypesTableInput
  }

  export type stakeholderTypesTableCreateOrConnectWithoutProjectStakeholdersTableInput = {
    where: stakeholderTypesTableWhereUniqueInput
    create: XOR<stakeholderTypesTableCreateWithoutProjectStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutProjectStakeholdersTableInput>
  }

  export type organizationsTableUpsertWithoutProjectStakeholdersTableInput = {
    update: XOR<organizationsTableUpdateWithoutProjectStakeholdersTableInput, organizationsTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
    create: XOR<organizationsTableCreateWithoutProjectStakeholdersTableInput, organizationsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    where?: organizationsTableWhereInput
  }

  export type organizationsTableUpdateToOneWithWhereWithoutProjectStakeholdersTableInput = {
    where?: organizationsTableWhereInput
    data: XOR<organizationsTableUpdateWithoutProjectStakeholdersTableInput, organizationsTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
  }

  export type organizationsTableUpdateWithoutProjectStakeholdersTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateWithoutProjectStakeholdersTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    stakeholderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type projectsTableUpsertWithoutProjectStakeholdersTableInput = {
    update: XOR<projectsTableUpdateWithoutProjectStakeholdersTableInput, projectsTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
    create: XOR<projectsTableCreateWithoutProjectStakeholdersTableInput, projectsTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    where?: projectsTableWhereInput
  }

  export type projectsTableUpdateToOneWithWhereWithoutProjectStakeholdersTableInput = {
    where?: projectsTableWhereInput
    data: XOR<projectsTableUpdateWithoutProjectStakeholdersTableInput, projectsTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
  }

  export type projectsTableUpdateWithoutProjectStakeholdersTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUpdateManyWithoutProjectsTableNestedInput
    landTable?: landTableUpdateManyWithoutProjectsTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutProjectsTableNestedInput
  }

  export type projectsTableUncheckedUpdateWithoutProjectStakeholdersTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutProjectsTableNestedInput
    landTable?: landTableUncheckedUpdateManyWithoutProjectsTableNestedInput
  }

  export type stakeholderTypesTableUpsertWithoutProjectStakeholdersTableInput = {
    update: XOR<stakeholderTypesTableUpdateWithoutProjectStakeholdersTableInput, stakeholderTypesTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
    create: XOR<stakeholderTypesTableCreateWithoutProjectStakeholdersTableInput, stakeholderTypesTableUncheckedCreateWithoutProjectStakeholdersTableInput>
    where?: stakeholderTypesTableWhereInput
  }

  export type stakeholderTypesTableUpdateToOneWithWhereWithoutProjectStakeholdersTableInput = {
    where?: stakeholderTypesTableWhereInput
    data: XOR<stakeholderTypesTableUpdateWithoutProjectStakeholdersTableInput, stakeholderTypesTableUncheckedUpdateWithoutProjectStakeholdersTableInput>
  }

  export type stakeholderTypesTableUpdateWithoutProjectStakeholdersTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type stakeholderTypesTableUncheckedUpdateWithoutProjectStakeholdersTableInput = {
    stakeholderType?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
    organizationsTable?: organizationsTableUncheckedUpdateManyWithoutStakeholderTypesTableNestedInput
  }

  export type cropTableCreateWithoutProjectsTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropNotes?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutCropTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutCropTableInput
    organizationsTable?: organizationsTableCreateNestedOneWithoutCropTableInput
    speciesTable?: speciesTableCreateNestedOneWithoutCropTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutCropTableInput
  }

  export type cropTableUncheckedCreateWithoutProjectsTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutCropTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutCropTableInput
  }

  export type cropTableCreateOrConnectWithoutProjectsTableInput = {
    where: cropTableWhereUniqueInput
    create: XOR<cropTableCreateWithoutProjectsTableInput, cropTableUncheckedCreateWithoutProjectsTableInput>
  }

  export type cropTableCreateManyProjectsTableInputEnvelope = {
    data: cropTableCreateManyProjectsTableInput | cropTableCreateManyProjectsTableInput[]
    skipDuplicates?: boolean
  }

  export type landTableCreateWithoutProjectsTableInput = {
    landId?: string
    landName: string
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutLandTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutLandTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutLandTableInput
  }

  export type landTableUncheckedCreateWithoutProjectsTableInput = {
    landId?: string
    landName: string
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    csvobjId?: string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutLandTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutLandTableInput
  }

  export type landTableCreateOrConnectWithoutProjectsTableInput = {
    where: landTableWhereUniqueInput
    create: XOR<landTableCreateWithoutProjectsTableInput, landTableUncheckedCreateWithoutProjectsTableInput>
  }

  export type landTableCreateManyProjectsTableInputEnvelope = {
    data: landTableCreateManyProjectsTableInput | landTableCreateManyProjectsTableInput[]
    skipDuplicates?: boolean
  }

  export type projectStakeholdersTableCreateWithoutProjectsTableInput = {
    stakeholderId?: string
    organizationsTable: organizationsTableCreateNestedOneWithoutProjectStakeholdersTableInput
    stakeholderTypesTable: stakeholderTypesTableCreateNestedOneWithoutProjectStakeholdersTableInput
  }

  export type projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput = {
    stakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type projectStakeholdersTableCreateOrConnectWithoutProjectsTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    create: XOR<projectStakeholdersTableCreateWithoutProjectsTableInput, projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput>
  }

  export type projectStakeholdersTableCreateManyProjectsTableInputEnvelope = {
    data: projectStakeholdersTableCreateManyProjectsTableInput | projectStakeholdersTableCreateManyProjectsTableInput[]
    skipDuplicates?: boolean
  }

  export type csvObjTableCreateWithoutProjectsTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableCreateNestedManyWithoutCsvObjTableInput
    landTable?: landTableCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableUncheckedCreateWithoutProjectsTableInput = {
    csvobjId?: string
    jsonData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    cropTable?: cropTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    landTable?: landTableUncheckedCreateNestedManyWithoutCsvObjTableInput
    metadataTable?: metadataTableUncheckedCreateNestedManyWithoutCsvObjTableInput
  }

  export type csvObjTableCreateOrConnectWithoutProjectsTableInput = {
    where: csvObjTableWhereUniqueInput
    create: XOR<csvObjTableCreateWithoutProjectsTableInput, csvObjTableUncheckedCreateWithoutProjectsTableInput>
  }

  export type cropTableUpsertWithWhereUniqueWithoutProjectsTableInput = {
    where: cropTableWhereUniqueInput
    update: XOR<cropTableUpdateWithoutProjectsTableInput, cropTableUncheckedUpdateWithoutProjectsTableInput>
    create: XOR<cropTableCreateWithoutProjectsTableInput, cropTableUncheckedCreateWithoutProjectsTableInput>
  }

  export type cropTableUpdateWithWhereUniqueWithoutProjectsTableInput = {
    where: cropTableWhereUniqueInput
    data: XOR<cropTableUpdateWithoutProjectsTableInput, cropTableUncheckedUpdateWithoutProjectsTableInput>
  }

  export type cropTableUpdateManyWithWhereWithoutProjectsTableInput = {
    where: cropTableScalarWhereInput
    data: XOR<cropTableUpdateManyMutationInput, cropTableUncheckedUpdateManyWithoutProjectsTableInput>
  }

  export type landTableUpsertWithWhereUniqueWithoutProjectsTableInput = {
    where: landTableWhereUniqueInput
    update: XOR<landTableUpdateWithoutProjectsTableInput, landTableUncheckedUpdateWithoutProjectsTableInput>
    create: XOR<landTableCreateWithoutProjectsTableInput, landTableUncheckedCreateWithoutProjectsTableInput>
  }

  export type landTableUpdateWithWhereUniqueWithoutProjectsTableInput = {
    where: landTableWhereUniqueInput
    data: XOR<landTableUpdateWithoutProjectsTableInput, landTableUncheckedUpdateWithoutProjectsTableInput>
  }

  export type landTableUpdateManyWithWhereWithoutProjectsTableInput = {
    where: landTableScalarWhereInput
    data: XOR<landTableUpdateManyMutationInput, landTableUncheckedUpdateManyWithoutProjectsTableInput>
  }

  export type projectStakeholdersTableUpsertWithWhereUniqueWithoutProjectsTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    update: XOR<projectStakeholdersTableUpdateWithoutProjectsTableInput, projectStakeholdersTableUncheckedUpdateWithoutProjectsTableInput>
    create: XOR<projectStakeholdersTableCreateWithoutProjectsTableInput, projectStakeholdersTableUncheckedCreateWithoutProjectsTableInput>
  }

  export type projectStakeholdersTableUpdateWithWhereUniqueWithoutProjectsTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    data: XOR<projectStakeholdersTableUpdateWithoutProjectsTableInput, projectStakeholdersTableUncheckedUpdateWithoutProjectsTableInput>
  }

  export type projectStakeholdersTableUpdateManyWithWhereWithoutProjectsTableInput = {
    where: projectStakeholdersTableScalarWhereInput
    data: XOR<projectStakeholdersTableUpdateManyMutationInput, projectStakeholdersTableUncheckedUpdateManyWithoutProjectsTableInput>
  }

  export type csvObjTableUpsertWithoutProjectsTableInput = {
    update: XOR<csvObjTableUpdateWithoutProjectsTableInput, csvObjTableUncheckedUpdateWithoutProjectsTableInput>
    create: XOR<csvObjTableCreateWithoutProjectsTableInput, csvObjTableUncheckedCreateWithoutProjectsTableInput>
    where?: csvObjTableWhereInput
  }

  export type csvObjTableUpdateToOneWithWhereWithoutProjectsTableInput = {
    where?: csvObjTableWhereInput
    data: XOR<csvObjTableUpdateWithoutProjectsTableInput, csvObjTableUncheckedUpdateWithoutProjectsTableInput>
  }

  export type csvObjTableUpdateWithoutProjectsTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUpdateManyWithoutCsvObjTableNestedInput
    landTable?: landTableUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUpdateManyWithoutCsvObjTableNestedInput
  }

  export type csvObjTableUncheckedUpdateWithoutProjectsTableInput = {
    csvobjId?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    landTable?: landTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
    metadataTable?: metadataTableUncheckedUpdateManyWithoutCsvObjTableNestedInput
  }

  export type cropTableCreateWithoutSpeciesTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    cropNotes?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutCropTableInput
    csvObjTable?: csvObjTableCreateNestedOneWithoutCropTableInput
    organizationsTable?: organizationsTableCreateNestedOneWithoutCropTableInput
    projectsTable?: projectsTableCreateNestedOneWithoutCropTableInput
    plantingTable?: plantingTableCreateNestedManyWithoutCropTableInput
  }

  export type cropTableUncheckedCreateWithoutSpeciesTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutCropTableInput
    plantingTable?: plantingTableUncheckedCreateNestedManyWithoutCropTableInput
  }

  export type cropTableCreateOrConnectWithoutSpeciesTableInput = {
    where: cropTableWhereUniqueInput
    create: XOR<cropTableCreateWithoutSpeciesTableInput, cropTableUncheckedCreateWithoutSpeciesTableInput>
  }

  export type cropTableCreateManySpeciesTableInputEnvelope = {
    data: cropTableCreateManySpeciesTableInput | cropTableCreateManySpeciesTableInput[]
    skipDuplicates?: boolean
  }

  export type cropTableUpsertWithWhereUniqueWithoutSpeciesTableInput = {
    where: cropTableWhereUniqueInput
    update: XOR<cropTableUpdateWithoutSpeciesTableInput, cropTableUncheckedUpdateWithoutSpeciesTableInput>
    create: XOR<cropTableCreateWithoutSpeciesTableInput, cropTableUncheckedCreateWithoutSpeciesTableInput>
  }

  export type cropTableUpdateWithWhereUniqueWithoutSpeciesTableInput = {
    where: cropTableWhereUniqueInput
    data: XOR<cropTableUpdateWithoutSpeciesTableInput, cropTableUncheckedUpdateWithoutSpeciesTableInput>
  }

  export type cropTableUpdateManyWithWhereWithoutSpeciesTableInput = {
    where: cropTableScalarWhereInput
    data: XOR<cropTableUpdateManyMutationInput, cropTableUncheckedUpdateManyWithoutSpeciesTableInput>
  }

  export type cropStakeholdersTableCreateWithoutStakeholderTypesTableInput = {
    cropStakeholderId?: string
    cropTable: cropTableCreateNestedOneWithoutCropStakeholdersTableInput
    organizationsTable: organizationsTableCreateNestedOneWithoutCropStakeholdersTableInput
  }

  export type cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput = {
    cropStakeholderId?: string
    cropId: string
    organizationId: string
  }

  export type cropStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    create: XOR<cropStakeholdersTableCreateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type cropStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope = {
    data: cropStakeholdersTableCreateManyStakeholderTypesTableInput | cropStakeholdersTableCreateManyStakeholderTypesTableInput[]
    skipDuplicates?: boolean
  }

  export type landStakeholdersTableCreateWithoutStakeholderTypesTableInput = {
    landStakeholderId?: string
    landTable: landTableCreateNestedOneWithoutLandStakeholdersTableInput
    organizationsTable: organizationsTableCreateNestedOneWithoutLandStakeholdersTableInput
  }

  export type landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput = {
    landStakeholderId?: string
    landId: string
    organizationId: string
  }

  export type landStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    create: XOR<landStakeholdersTableCreateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type landStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope = {
    data: landStakeholdersTableCreateManyStakeholderTypesTableInput | landStakeholdersTableCreateManyStakeholderTypesTableInput[]
    skipDuplicates?: boolean
  }

  export type organizationsTableCreateWithoutStakeholderTypesTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropStakeholdersTable?: cropStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
    profilesTable?: profilesTableCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    cropTable?: cropTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    landStakeholdersTable?: landStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    profilesTable?: profilesTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedCreateNestedManyWithoutOrganizationsTableInput
  }

  export type organizationsTableCreateOrConnectWithoutStakeholderTypesTableInput = {
    where: organizationsTableWhereUniqueInput
    create: XOR<organizationsTableCreateWithoutStakeholderTypesTableInput, organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type organizationsTableCreateManyStakeholderTypesTableInputEnvelope = {
    data: organizationsTableCreateManyStakeholderTypesTableInput | organizationsTableCreateManyStakeholderTypesTableInput[]
    skipDuplicates?: boolean
  }

  export type projectStakeholdersTableCreateWithoutStakeholderTypesTableInput = {
    stakeholderId?: string
    organizationsTable: organizationsTableCreateNestedOneWithoutProjectStakeholdersTableInput
    projectsTable: projectsTableCreateNestedOneWithoutProjectStakeholdersTableInput
  }

  export type projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput = {
    stakeholderId?: string
    organizationId: string
    projectId: string
  }

  export type projectStakeholdersTableCreateOrConnectWithoutStakeholderTypesTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    create: XOR<projectStakeholdersTableCreateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type projectStakeholdersTableCreateManyStakeholderTypesTableInputEnvelope = {
    data: projectStakeholdersTableCreateManyStakeholderTypesTableInput | projectStakeholdersTableCreateManyStakeholderTypesTableInput[]
    skipDuplicates?: boolean
  }

  export type cropStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    update: XOR<cropStakeholdersTableUpdateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput>
    create: XOR<cropStakeholdersTableCreateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type cropStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: cropStakeholdersTableWhereUniqueInput
    data: XOR<cropStakeholdersTableUpdateWithoutStakeholderTypesTableInput, cropStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput>
  }

  export type cropStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput = {
    where: cropStakeholdersTableScalarWhereInput
    data: XOR<cropStakeholdersTableUpdateManyMutationInput, cropStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableInput>
  }

  export type landStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    update: XOR<landStakeholdersTableUpdateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput>
    create: XOR<landStakeholdersTableCreateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type landStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: landStakeholdersTableWhereUniqueInput
    data: XOR<landStakeholdersTableUpdateWithoutStakeholderTypesTableInput, landStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput>
  }

  export type landStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput = {
    where: landStakeholdersTableScalarWhereInput
    data: XOR<landStakeholdersTableUpdateManyMutationInput, landStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableInput>
  }

  export type organizationsTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: organizationsTableWhereUniqueInput
    update: XOR<organizationsTableUpdateWithoutStakeholderTypesTableInput, organizationsTableUncheckedUpdateWithoutStakeholderTypesTableInput>
    create: XOR<organizationsTableCreateWithoutStakeholderTypesTableInput, organizationsTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type organizationsTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: organizationsTableWhereUniqueInput
    data: XOR<organizationsTableUpdateWithoutStakeholderTypesTableInput, organizationsTableUncheckedUpdateWithoutStakeholderTypesTableInput>
  }

  export type organizationsTableUpdateManyWithWhereWithoutStakeholderTypesTableInput = {
    where: organizationsTableScalarWhereInput
    data: XOR<organizationsTableUpdateManyMutationInput, organizationsTableUncheckedUpdateManyWithoutStakeholderTypesTableInput>
  }

  export type organizationsTableScalarWhereInput = {
    AND?: organizationsTableScalarWhereInput | organizationsTableScalarWhereInput[]
    OR?: organizationsTableScalarWhereInput[]
    NOT?: organizationsTableScalarWhereInput | organizationsTableScalarWhereInput[]
    organizationId?: UuidFilter<"organizationsTable"> | string
    organizationName?: StringFilter<"organizationsTable"> | string
    contactName?: StringNullableFilter<"organizationsTable"> | string | null
    contactEmail?: StringNullableFilter<"organizationsTable"> | string | null
    contactPhone?: StringNullableFilter<"organizationsTable"> | string | null
    address?: StringNullableFilter<"organizationsTable"> | string | null
    website?: StringNullableFilter<"organizationsTable"> | string | null
    organizationNotes?: StringNullableFilter<"organizationsTable"> | string | null
    createdAt?: DateTimeNullableFilter<"organizationsTable"> | Date | string | null
    lastEditedAt?: DateTimeNullableFilter<"organizationsTable"> | Date | string | null
    editedBy?: UuidNullableFilter<"organizationsTable"> | string | null
    deleted?: BoolNullableFilter<"organizationsTable"> | boolean | null
    gpsLat?: FloatNullableFilter<"organizationsTable"> | number | null
    gpsLon?: FloatNullableFilter<"organizationsTable"> | number | null
    stakeholderTypeId?: UuidNullableFilter<"organizationsTable"> | string | null
  }

  export type projectStakeholdersTableUpsertWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    update: XOR<projectStakeholdersTableUpdateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput>
    create: XOR<projectStakeholdersTableCreateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedCreateWithoutStakeholderTypesTableInput>
  }

  export type projectStakeholdersTableUpdateWithWhereUniqueWithoutStakeholderTypesTableInput = {
    where: projectStakeholdersTableWhereUniqueInput
    data: XOR<projectStakeholdersTableUpdateWithoutStakeholderTypesTableInput, projectStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput>
  }

  export type projectStakeholdersTableUpdateManyWithWhereWithoutStakeholderTypesTableInput = {
    where: projectStakeholdersTableScalarWhereInput
    data: XOR<projectStakeholdersTableUpdateManyMutationInput, projectStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableInput>
  }

  export type saml_relay_statesCreateManyFlow_stateInput = {
    id: string
    sso_provider_id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type saml_relay_statesUpdateWithoutFlow_stateInput = {
    id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sso_providers?: sso_providersUpdateOneRequiredWithoutSaml_relay_statesNestedInput
  }

  export type saml_relay_statesUncheckedUpdateWithoutFlow_stateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type saml_relay_statesUncheckedUpdateManyWithoutFlow_stateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sso_provider_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mfa_challengesCreateManyMfa_factorsInput = {
    id: string
    created_at: Date | string
    verified_at?: Date | string | null
    ip_address: string
    otp_code?: string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesUpdateWithoutMfa_factorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
    otp_code?: NullableStringFieldUpdateOperationsInput | string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesUncheckedUpdateWithoutMfa_factorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
    otp_code?: NullableStringFieldUpdateOperationsInput | string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_challengesUncheckedUpdateManyWithoutMfa_factorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: StringFieldUpdateOperationsInput | string
    otp_code?: NullableStringFieldUpdateOperationsInput | string | null
    web_authn_session_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type mfa_amr_claimsCreateManySessionsInput = {
    created_at: Date | string
    updated_at: Date | string
    authentication_method: string
    id: string
  }

  export type refresh_tokensCreateManySessionsInput = {
    instance_id?: string | null
    id?: bigint | number
    token?: string | null
    user_id?: string | null
    revoked?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parent?: string | null
  }

  export type mfa_amr_claimsUpdateWithoutSessionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authentication_method?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type mfa_amr_claimsUncheckedUpdateWithoutSessionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authentication_method?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type mfa_amr_claimsUncheckedUpdateManyWithoutSessionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    authentication_method?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type refresh_tokensUpdateWithoutSessionsInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refresh_tokensUncheckedUpdateWithoutSessionsInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refresh_tokensUncheckedUpdateManyWithoutSessionsInput = {
    instance_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_providersCreateManySso_providersInput = {
    id: string
    entity_id: string
    metadata_xml: string
    metadata_url?: string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name_id_format?: string | null
  }

  export type saml_relay_statesCreateManySso_providersInput = {
    id: string
    request_id: string
    for_email?: string | null
    redirect_to?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    flow_state_id?: string | null
  }

  export type sso_domainsCreateManySso_providersInput = {
    id: string
    domain: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type saml_providersUpdateWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    metadata_xml?: StringFieldUpdateOperationsInput | string
    metadata_url?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name_id_format?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_providersUncheckedUpdateWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    metadata_xml?: StringFieldUpdateOperationsInput | string
    metadata_url?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name_id_format?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_providersUncheckedUpdateManyWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    metadata_xml?: StringFieldUpdateOperationsInput | string
    metadata_url?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_mapping?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name_id_format?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_relay_statesUpdateWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow_state?: flow_stateUpdateOneWithoutSaml_relay_statesNestedInput
  }

  export type saml_relay_statesUncheckedUpdateWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow_state_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saml_relay_statesUncheckedUpdateManyWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    for_email?: NullableStringFieldUpdateOperationsInput | string | null
    redirect_to?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flow_state_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sso_domainsUpdateWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sso_domainsUncheckedUpdateWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sso_domainsUncheckedUpdateManyWithoutSso_providersInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type identitiesCreateManyUsersInput = {
    provider_id: string
    identity_data: JsonNullValueInput | InputJsonValue
    provider: string
    last_sign_in_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    email?: string | null
    id?: string
  }

  export type mfa_factorsCreateManyUsersInput = {
    id: string
    friendly_name?: string | null
    factor_type: $Enums.factor_type
    status: $Enums.factor_status
    created_at: Date | string
    updated_at: Date | string
    secret?: string | null
    phone?: string | null
    last_challenged_at?: Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: string | null
  }

  export type one_time_tokensCreateManyUsersInput = {
    id: string
    token_type: $Enums.one_time_token_type
    token_hash: string
    relates_to: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type sessionsCreateManyUsersInput = {
    id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    factor_id?: string | null
    aal?: $Enums.aal_level | null
    not_after?: Date | string | null
    refreshed_at?: Date | string | null
    user_agent?: string | null
    ip?: string | null
    tag?: string | null
  }

  export type identitiesUpdateWithoutUsersInput = {
    provider_id?: StringFieldUpdateOperationsInput | string
    identity_data?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type identitiesUncheckedUpdateWithoutUsersInput = {
    provider_id?: StringFieldUpdateOperationsInput | string
    identity_data?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type identitiesUncheckedUpdateManyWithoutUsersInput = {
    provider_id?: StringFieldUpdateOperationsInput | string
    identity_data?: JsonNullValueInput | InputJsonValue
    provider?: StringFieldUpdateOperationsInput | string
    last_sign_in_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type mfa_factorsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_challenges?: mfa_challengesUpdateManyWithoutMfa_factorsNestedInput
  }

  export type mfa_factorsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_challenges?: mfa_challengesUncheckedUpdateManyWithoutMfa_factorsNestedInput
  }

  export type mfa_factorsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendly_name?: NullableStringFieldUpdateOperationsInput | string | null
    factor_type?: Enumfactor_typeFieldUpdateOperationsInput | $Enums.factor_type
    status?: Enumfactor_statusFieldUpdateOperationsInput | $Enums.factor_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_challenged_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    web_authn_credential?: NullableJsonNullValueInput | InputJsonValue
    web_authn_aaguid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type one_time_tokensUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token_type?: Enumone_time_token_typeFieldUpdateOperationsInput | $Enums.one_time_token_type
    token_hash?: StringFieldUpdateOperationsInput | string
    relates_to?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type one_time_tokensUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token_type?: Enumone_time_token_typeFieldUpdateOperationsInput | $Enums.one_time_token_type
    token_hash?: StringFieldUpdateOperationsInput | string
    relates_to?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type one_time_tokensUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token_type?: Enumone_time_token_typeFieldUpdateOperationsInput | $Enums.one_time_token_type
    token_hash?: StringFieldUpdateOperationsInput | string
    relates_to?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_amr_claims?: mfa_amr_claimsUpdateManyWithoutSessionsNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_amr_claims?: mfa_amr_claimsUncheckedUpdateManyWithoutSessionsNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factor_id?: NullableStringFieldUpdateOperationsInput | string | null
    aal?: NullableEnumaal_levelFieldUpdateOperationsInput | $Enums.aal_level | null
    not_after?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cropStakeholdersTableCreateManyCropTableInput = {
    cropStakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type plantingTableCreateManyCropTableInput = {
    plantingId?: string
    landId?: string | null
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    plantingNotes?: string | null
  }

  export type cropStakeholdersTableUpdateWithoutCropTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
  }

  export type cropStakeholdersTableUncheckedUpdateWithoutCropTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type cropStakeholdersTableUncheckedUpdateManyWithoutCropTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type plantingTableUpdateWithoutCropTableInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    landTable?: landTableUpdateOneWithoutPlantingTableNestedInput
  }

  export type plantingTableUncheckedUpdateWithoutCropTableInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    landId?: NullableStringFieldUpdateOperationsInput | string | null
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plantingTableUncheckedUpdateManyWithoutCropTableInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    landId?: NullableStringFieldUpdateOperationsInput | string | null
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cropTableCreateManyCsvObjTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    speciesTemp?: string | null
  }

  export type landTableCreateManyCsvObjTableInput = {
    landId?: string
    landName: string
    projectId?: string | null
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
  }

  export type metadataTableCreateManyCsvObjTableInput = {
    metadataId?: string
    csvKey: string
    dbKey: string
    createdAt?: Date | string | null
  }

  export type projectsTableCreateManyCsvObjTableInput = {
    projectId?: string
    projectName: string
    projectNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    source?: string | null
  }

  export type cropTableUpdateWithoutCsvObjTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutCropTableNestedInput
    organizationsTable?: organizationsTableUpdateOneWithoutCropTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutCropTableNestedInput
    speciesTable?: speciesTableUpdateOneWithoutCropTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateWithoutCsvObjTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutCropTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateManyWithoutCsvObjTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type landTableUpdateWithoutCsvObjTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutLandTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutLandTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutLandTableNestedInput
  }

  export type landTableUncheckedUpdateWithoutCsvObjTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutLandTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutLandTableNestedInput
  }

  export type landTableUncheckedUpdateManyWithoutCsvObjTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
  }

  export type metadataTableUpdateWithoutCsvObjTableInput = {
    metadataId?: StringFieldUpdateOperationsInput | string
    csvKey?: StringFieldUpdateOperationsInput | string
    dbKey?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metadataTableUncheckedUpdateWithoutCsvObjTableInput = {
    metadataId?: StringFieldUpdateOperationsInput | string
    csvKey?: StringFieldUpdateOperationsInput | string
    dbKey?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metadataTableUncheckedUpdateManyWithoutCsvObjTableInput = {
    metadataId?: StringFieldUpdateOperationsInput | string
    csvKey?: StringFieldUpdateOperationsInput | string
    dbKey?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectsTableUpdateWithoutCsvObjTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUpdateManyWithoutProjectsTableNestedInput
    landTable?: landTableUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutProjectsTableNestedInput
  }

  export type projectsTableUncheckedUpdateWithoutCsvObjTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUncheckedUpdateManyWithoutProjectsTableNestedInput
    landTable?: landTableUncheckedUpdateManyWithoutProjectsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutProjectsTableNestedInput
  }

  export type projectsTableUncheckedUpdateManyWithoutCsvObjTableInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type landStakeholdersTableCreateManyLandTableInput = {
    landStakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type plantingTableCreateManyLandTableInput = {
    plantingId?: string
    planted?: number | null
    plantingDate?: Date | string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    deleted?: boolean | null
    cropId?: string | null
    plantingNotes?: string | null
  }

  export type landStakeholdersTableUpdateWithoutLandTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
  }

  export type landStakeholdersTableUncheckedUpdateWithoutLandTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type landStakeholdersTableUncheckedUpdateManyWithoutLandTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type plantingTableUpdateWithoutLandTableInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cropTable?: cropTableUpdateOneWithoutPlantingTableNestedInput
  }

  export type plantingTableUncheckedUpdateWithoutLandTableInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plantingTableUncheckedUpdateManyWithoutLandTableInput = {
    plantingId?: StringFieldUpdateOperationsInput | string
    planted?: NullableIntFieldUpdateOperationsInput | number | null
    plantingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cropStakeholdersTableCreateManyOrganizationsTableInput = {
    cropStakeholderId?: string
    cropId: string
    stakeholderTypeId: string
  }

  export type cropTableCreateManyOrganizationsTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
  }

  export type landStakeholdersTableCreateManyOrganizationsTableInput = {
    landStakeholderId?: string
    landId: string
    stakeholderTypeId: string
  }

  export type profilesTableCreateManyOrganizationsTableInput = {
    id?: string
    user_id: string
    firstname: string
    lastname: string
    phonenumber?: string | null
    isactive?: boolean | null
    isverified?: boolean | null
    role?: $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: Date | string | null
    updatedat?: Date | string | null
    lastlogin?: Date | string | null
    twofactorenabled?: boolean | null
    twofactorsecret?: string | null
    locale?: string | null
    timezone?: string | null
  }

  export type projectStakeholdersTableCreateManyOrganizationsTableInput = {
    stakeholderId?: string
    stakeholderTypeId: string
    projectId: string
  }

  export type cropStakeholdersTableUpdateWithoutOrganizationsTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropTable?: cropTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
  }

  export type cropStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type cropTableUpdateWithoutOrganizationsTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutCropTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutCropTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutCropTableNestedInput
    speciesTable?: speciesTableUpdateOneWithoutCropTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateWithoutOrganizationsTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutCropTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateManyWithoutOrganizationsTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type landStakeholdersTableUpdateWithoutOrganizationsTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landTable?: landTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
  }

  export type landStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type profilesTableUpdateWithoutOrganizationsTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutProfilesTableNestedInput
  }

  export type profilesTableUncheckedUpdateWithoutOrganizationsTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profilesTableUncheckedUpdateManyWithoutOrganizationsTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twofactorenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twofactorsecret?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type projectStakeholdersTableUpdateWithoutOrganizationsTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    projectsTable?: projectsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
  }

  export type projectStakeholdersTableUncheckedUpdateWithoutOrganizationsTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type cropTableCreateManyProjectsTableInput = {
    cropId?: string
    cropName: string
    speciesId?: string | null
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
  }

  export type landTableCreateManyProjectsTableInput = {
    landId?: string
    landName: string
    hectares?: Decimal | DecimalJsLike | number | string | null
    gpsLat?: Decimal | DecimalJsLike | number | string | null
    gpsLon?: Decimal | DecimalJsLike | number | string | null
    landNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    preparation?: $Enums.Preparation | null
    csvobjId?: string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
  }

  export type projectStakeholdersTableCreateManyProjectsTableInput = {
    stakeholderId?: string
    organizationId: string
    stakeholderTypeId: string
  }

  export type cropTableUpdateWithoutProjectsTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutCropTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutCropTableNestedInput
    organizationsTable?: organizationsTableUpdateOneWithoutCropTableNestedInput
    speciesTable?: speciesTableUpdateOneWithoutCropTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateWithoutProjectsTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutCropTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateManyWithoutProjectsTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableStringFieldUpdateOperationsInput | string | null
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type landTableUpdateWithoutProjectsTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutLandTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutLandTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutLandTableNestedInput
  }

  export type landTableUncheckedUpdateWithoutProjectsTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutLandTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutLandTableNestedInput
  }

  export type landTableUncheckedUpdateManyWithoutProjectsTableInput = {
    landId?: StringFieldUpdateOperationsInput | string
    landName?: StringFieldUpdateOperationsInput | string
    hectares?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gpsLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preparation?: NullableEnumPreparationFieldUpdateOperationsInput | $Enums.Preparation | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    polygon?: NullableJsonNullValueInput | InputJsonValue
  }

  export type projectStakeholdersTableUpdateWithoutProjectsTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
    stakeholderTypesTable?: stakeholderTypesTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
  }

  export type projectStakeholdersTableUncheckedUpdateWithoutProjectsTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type projectStakeholdersTableUncheckedUpdateManyWithoutProjectsTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stakeholderTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type cropTableCreateManySpeciesTableInput = {
    cropId?: string
    cropName: string
    seedInfo?: string | null
    cropStock?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    projectId?: string | null
    organizationId?: string | null
    cropNotes?: string | null
    csvobjId?: string | null
    speciesTemp?: string | null
  }

  export type cropTableUpdateWithoutSpeciesTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutCropTableNestedInput
    csvObjTable?: csvObjTableUpdateOneWithoutCropTableNestedInput
    organizationsTable?: organizationsTableUpdateOneWithoutCropTableNestedInput
    projectsTable?: projectsTableUpdateOneWithoutCropTableNestedInput
    plantingTable?: plantingTableUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateWithoutSpeciesTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutCropTableNestedInput
    plantingTable?: plantingTableUncheckedUpdateManyWithoutCropTableNestedInput
  }

  export type cropTableUncheckedUpdateManyWithoutSpeciesTableInput = {
    cropId?: StringFieldUpdateOperationsInput | string
    cropName?: StringFieldUpdateOperationsInput | string
    seedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    cropStock?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    cropNotes?: NullableStringFieldUpdateOperationsInput | string | null
    csvobjId?: NullableStringFieldUpdateOperationsInput | string | null
    speciesTemp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cropStakeholdersTableCreateManyStakeholderTypesTableInput = {
    cropStakeholderId?: string
    cropId: string
    organizationId: string
  }

  export type landStakeholdersTableCreateManyStakeholderTypesTableInput = {
    landStakeholderId?: string
    landId: string
    organizationId: string
  }

  export type organizationsTableCreateManyStakeholderTypesTableInput = {
    organizationId?: string
    organizationName: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    website?: string | null
    organizationNotes?: string | null
    createdAt?: Date | string | null
    lastEditedAt?: Date | string | null
    editedBy?: string | null
    deleted?: boolean | null
    gpsLat?: number | null
    gpsLon?: number | null
  }

  export type projectStakeholdersTableCreateManyStakeholderTypesTableInput = {
    stakeholderId?: string
    organizationId: string
    projectId: string
  }

  export type cropStakeholdersTableUpdateWithoutStakeholderTypesTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropTable?: cropTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutCropStakeholdersTableNestedInput
  }

  export type cropStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type cropStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableInput = {
    cropStakeholderId?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type landStakeholdersTableUpdateWithoutStakeholderTypesTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landTable?: landTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutLandStakeholdersTableNestedInput
  }

  export type landStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type landStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableInput = {
    landStakeholderId?: StringFieldUpdateOperationsInput | string
    landId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type organizationsTableUpdateWithoutStakeholderTypesTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropStakeholdersTable?: cropStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateWithoutStakeholderTypesTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
    cropStakeholdersTable?: cropStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    cropTable?: cropTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    landStakeholdersTable?: landStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    profilesTable?: profilesTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
    projectStakeholdersTable?: projectStakeholdersTableUncheckedUpdateManyWithoutOrganizationsTableNestedInput
  }

  export type organizationsTableUncheckedUpdateManyWithoutStakeholderTypesTableInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    organizationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpsLat?: NullableFloatFieldUpdateOperationsInput | number | null
    gpsLon?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type projectStakeholdersTableUpdateWithoutStakeholderTypesTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationsTable?: organizationsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
    projectsTable?: projectsTableUpdateOneRequiredWithoutProjectStakeholdersTableNestedInput
  }

  export type projectStakeholdersTableUncheckedUpdateWithoutStakeholderTypesTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type projectStakeholdersTableUncheckedUpdateManyWithoutStakeholderTypesTableInput = {
    stakeholderId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}